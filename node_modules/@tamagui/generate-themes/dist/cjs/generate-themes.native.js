"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: !0
    });
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
    return to;
  };
var __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
  value: !0
}), mod);
var generate_themes_exports = {};
__export(generate_themes_exports, {
  generateThemes: () => generateThemes
});
module.exports = __toCommonJS(generate_themes_exports);
var import_path = require("path"),
  didRegisterOnce = !1;
async function generateThemes(inputFile) {
  var inputFilePath = inputFile[0] === "." ? (0, import_path.join)(process.cwd(), inputFile) : inputFile;
  didRegisterOnce ? purgeCache(inputFilePath) : (didRegisterOnce = !0, require("esbuild-register/dist/node").register({
    hookIgnoreNodeModules: !1
  }));
  var og = process.env.TAMAGUI_KEEP_THEMES;
  process.env.TAMAGUI_KEEP_THEMES = "1", process.env.TAMAGUI_RUN_THEMEBUILDER = "1";
  try {
    var requiredThemes = require(inputFilePath),
      themes = requiredThemes.default || requiredThemes.themes || requiredThemes[Object.keys(requiredThemes)[0]],
      generatedThemes = generatedThemesToTypescript(themes);
    return {
      generated: generatedThemes
    };
  } catch (err) {
    console.warn(` \u26A0\uFE0F Error running theme builder:
`, err?.stack || err);
  } finally {
    process.env.TAMAGUI_KEEP_THEMES = og;
  }
}
var dedupedTokens = /* @__PURE__ */new Map();
function generatedThemesToTypescript(themes) {
  var dedupedThemes = /* @__PURE__ */new Map(),
    dedupedThemeToNames = /* @__PURE__ */new Map(),
    i = 0;
  for (var name in themes) {
    i++;
    var theme = themes[name],
      j = 0,
      _iteratorNormalCompletion = !0,
      _didIteratorError = !1,
      _iteratorError = void 0;
    try {
      for (var _iterator = Object.entries(theme)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var [key, value] = _step.value;
        i++;
        var uniqueKey = `t${i}${j}`;
        dedupedTokens.has(value) || dedupedTokens.set(value, uniqueKey);
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    var key1 = JSON.stringify(theme);
    dedupedThemes.has(key1) ? dedupedThemeToNames.set(key1, [...dedupedThemeToNames.get(key1), name]) : (dedupedThemes.set(key1, theme), dedupedThemeToNames.set(key1, [name]));
  }
  if (!themes) throw new Error("Didn't find any themes exported or returned");
  var baseKeys = Object.entries(themes.light || themes[Object.keys(themes)[0]]),
    baseTypeString = `type Theme = {
${baseKeys.map(function (param) {
      var [k] = param;
      return `  ${k}: string;
`;
    }).join("")}
}`,
    out = `${baseTypeString}
`;
  out += `
function t(a: [number, number][]) {
  let res: Record<string,string> = {}
  for (const [ki, vi] of a) {
    res[ks[ki] as string] = colors[vi] as string
  }
  return res as Theme
}
`, out += `export const colors = [
`;
  var index = 0,
    valueToIndex = {};
  dedupedTokens.forEach(function (name2, value2) {
    valueToIndex[value2] = index, index++, out += `  '${value2}',
`;
  }), out += `]

`;
  var keys = baseKeys.map(function (param) {
    var [k] = param;
    return k;
  });
  out += `const ks = [
`, out += keys.map(function (k) {
    return `'${k}'`;
  }).join(`,
`), out += `]

`;
  var nameI = 0,
    themeTypes = "type ThemeNames =",
    exported = "export const themes: Record<ThemeNames, Theme> = {";
  return dedupedThemes.forEach(function (theme2) {
    nameI++;
    var key2 = JSON.stringify(theme2),
      names = dedupedThemeToNames.get(key2),
      name2 = `n${nameI}`,
      baseTheme = `const ${name2} = ${objectToJsString(theme2, keys, valueToIndex)}`;
    out += `
${baseTheme}`, names.forEach(function (n) {
      exported += `
  ${n}: ${name2},`, n.toLowerCase() === n && (themeTypes += `
 | '${n}'`);
    });
  }), out += `

${themeTypes}

${exported}
}
`, out;
}
function objectToJsString(obj, keys, valueToIndex) {
  var arrItems = [];
  for (var key in obj) {
    var ki = keys.indexOf(key),
      vi = valueToIndex[obj[key]];
    arrItems.push(`[${ki}, ${vi}]`);
  }
  return `t([${arrItems.join(",")}])`;
}
function purgeCache(moduleName) {
  searchCache(moduleName, function (mod) {
    delete require.cache[mod.id];
  }), !(!module.constructor || !module.constructor._pathCache) && Object.keys(module.constructor._pathCache).forEach(function (cacheKey) {
    cacheKey.indexOf(moduleName) > 0 && delete module.constructor._pathCache[cacheKey];
  });
}
function searchCache(moduleName, callback) {
  var mod = require.resolve(moduleName);
  mod && (mod = require.cache[mod]) !== void 0 && function traverse(mod2) {
    var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    depth > 10 || (mod2.children.forEach(function (child) {
      traverse(child, depth + 1);
    }), callback(mod2));
  }(mod);
}
//# sourceMappingURL=generate-themes.native.js.map
