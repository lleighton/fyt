var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf,
  __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
      get: all[name],
      enumerable: !0
    });
  },
  __copyProps = (to, from, except, desc) => {
    if (from && typeof from == "object" || typeof from == "function") for (let key of __getOwnPropNames(from)) !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    });
    return to;
  };
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
    value: mod,
    enumerable: !0
  }) : target, mod)),
  __toCommonJS = mod => __copyProps(__defProp({}, "__esModule", {
    value: !0
  }), mod);
var extractToClassNames_exports = {};
__export(extractToClassNames_exports, {
  extractToClassNames: () => extractToClassNames
});
module.exports = __toCommonJS(extractToClassNames_exports);
var import_generator = __toESM(require("@babel/generator")),
  t = __toESM(require("@babel/types")),
  import_web = require("@tamagui/web"),
  path = __toESM(require("node:path")),
  util = __toESM(require("node:util")),
  import_requireTamaguiCore = require("../helpers/requireTamaguiCore.cjs"),
  import_babelParse = require("./babelParse.cjs"),
  import_createLogger = require("./createLogger.cjs"),
  import_extractMediaStyle = require("./extractMediaStyle.cjs"),
  import_normalizeTernaries = require("./normalizeTernaries.cjs"),
  import_propsToFontFamilyCache = require("./propsToFontFamilyCache.cjs"),
  import_timer = require("./timer.cjs"),
  import_errors = require("./errors.cjs"),
  import_concatClassName = require("./concatClassName.cjs");
const remove = () => {},
  spaceString = t.stringLiteral(" ");
async function extractToClassNames({
  extractor,
  source,
  sourcePath = "",
  options,
  shouldPrintDebug
}) {
  const tm = (0, import_timer.timer)(),
    {
      getCSSStylesAtomic,
      createMediaStyle
    } = (0, import_requireTamaguiCore.requireTamaguiCore)("web");
  if (sourcePath.includes("node_modules")) return null;
  if (shouldPrintDebug && console.warn(`--- ${sourcePath} --- 

`), typeof source != "string") throw new Error("`source` must be a string of javascript");
  if (!path.isAbsolute(sourcePath)) throw new Error("`sourcePath` must be an absolute path to a .js file, got: " + sourcePath);
  /.[tj]sx?$/i.test(sourcePath || "") || console.warn(`${sourcePath.slice(0, 100)} - bad filename.`), !options.disableExtraction && !options._disableLoadTamagui && (await extractor.loadTamagui(options));
  const printLog = (0, import_createLogger.createLogger)(sourcePath, options);
  let ast;
  try {
    ast = (0, import_babelParse.babelParse)(source, sourcePath);
  } catch (err) {
    throw console.error("babel parse error:", sourcePath.slice(0, 100)), err;
  }
  tm.mark("babel-parse", shouldPrintDebug === "verbose");
  const cssMap = /* @__PURE__ */new Map(),
    tamaguiConfig = extractor.getTamagui(),
    res = await extractor.parse(ast, {
      shouldPrintDebug,
      ...options,
      platform: "web",
      sourcePath,
      extractStyledDefinitions: !0,
      onStyledDefinitionRule(identifier, rules) {
        const css = rules.join(";");
        shouldPrintDebug && console.info(`adding styled() rule: .${identifier} ${css}`), cssMap.set(`.${identifier}`, {
          css,
          commentTexts: []
        });
      },
      getFlattenedNode: ({
        tag
      }) => tag,
      onExtractTag: ({
        parserProps,
        attrs,
        node,
        attemptEval,
        jsxPath,
        originalNodeName,
        filePath,
        lineNumbers,
        staticConfig
      }) => {
        if (staticConfig.acceptsClassName === !1) throw new import_errors.BailOptimizationError();
        const finalAttrs = [];
        let mergeForwardBaseStyle = null,
          attrClassName = null,
          baseFontFamily = "",
          mediaStylesSeen = 1;
        const comment = util.format("/* %s:%s (%s) */", filePath, lineNumbers, originalNodeName);
        function addStyle(style) {
          const identifier = style[import_web.StyleObjectIdentifier],
            rules = style[import_web.StyleObjectRules],
            selector = `.${identifier}`;
          return cssMap.has(selector) ? cssMap.get(selector).commentTexts.push(comment) : rules.length && cssMap.set(selector, {
            css: rules.join(`
`),
            commentTexts: [comment]
          }), identifier;
        }
        function addStyles(style) {
          const cssStyles = getCSSStylesAtomic(style),
            classNames = [];
          for (const style2 of cssStyles) {
            const mediaName = style2[0].slice(1);
            if (mediaName.startsWith("group-")) throw new import_errors.BailOptimizationError();
            const mediaTypeMatch = mediaName.match(/^(theme|platform)-/);
            if (mediaTypeMatch) {
              const mediaType = mediaTypeMatch[1],
                mediaStyle = createMediaStyle(style2, mediaName, extractor.getTamagui().media, mediaType, !1, mediaStylesSeen),
                identifier2 = addStyle(mediaStyle);
              classNames.push(identifier2);
              continue;
            }
            if (mediaName in tamaguiConfig.media) {
              const mediaStyle = createMediaStyle(style2, mediaName, extractor.getTamagui().media, !0, !1, mediaStylesSeen),
                identifier2 = addStyle(mediaStyle);
              classNames.push(identifier2);
              continue;
            }
            const identifier = addStyle(style2);
            classNames.push(identifier);
          }
          return classNames;
        }
        const onlyTernaries = attrs.flatMap(attr => {
            if (attr.type === "attr") {
              const value = attr.value;
              if (t.isJSXSpreadAttribute(value)) return console.error("Should never happen"), [];
              if (value.name.name === "className") {
                let inner = value.value;
                t.isJSXExpressionContainer(inner) && (inner = inner.expression);
                try {
                  const evaluatedValue = inner ? attemptEval(inner) : null;
                  typeof evaluatedValue == "string" && (attrClassName = t.stringLiteral(evaluatedValue));
                } catch {
                  inner && (attrClassName ||= inner);
                }
                return [];
              }
              return finalAttrs.push(value), [];
            }
            if (attr.type === "style") return mergeForwardBaseStyle = (0, import_web.mergeProps)(mergeForwardBaseStyle || {}, attr.value), baseFontFamily = (0, import_propsToFontFamilyCache.getFontFamilyNameFromProps)(attr.value) || "", [];
            let ternary = attr.value;
            if (ternary.inlineMediaQuery) {
              const mediaExtraction = (0, import_extractMediaStyle.extractMediaStyle)(parserProps, attr.value, jsxPath, extractor.getTamagui(), sourcePath || "", mediaStylesSeen++, shouldPrintDebug);
              if (mediaExtraction) if (mediaExtraction.mediaStyles && (mergeForwardBaseStyle = (0, import_web.mergeProps)(mergeForwardBaseStyle || {}, {
                [`$${ternary.inlineMediaQuery}`]: attr.value.consequent
              })), mediaExtraction.ternaryWithoutMedia) ternary = mediaExtraction.ternaryWithoutMedia;else return [];
            }
            let mergedAlternate, mergedConsequent;
            return ternary.alternate && Object.keys(ternary.alternate).length && (mergedAlternate = (0, import_web.mergeProps)(mergeForwardBaseStyle || {}, ternary.alternate || {}), (0, import_propsToFontFamilyCache.forwardFontFamilyName)(ternary.alternate, mergedAlternate, baseFontFamily)), ternary.consequent && Object.keys(ternary.consequent).length && (mergedConsequent = (0, import_web.mergeProps)(mergeForwardBaseStyle || {}, ternary.consequent || {}), (0, import_propsToFontFamilyCache.forwardFontFamilyName)(ternary.consequent, mergedConsequent, baseFontFamily)), {
              ...ternary,
              alternate: mergedAlternate,
              consequent: mergedConsequent
            };
          }),
          hasTernaries = !!onlyTernaries.length,
          baseClassNames = mergeForwardBaseStyle ? addStyles(mergeForwardBaseStyle) : null;
        let baseClassNameStr = baseClassNames ? baseClassNames.join(" ") : "";
        !hasTernaries && baseFontFamily && (baseClassNameStr = `font_${baseFontFamily}${baseClassNameStr ? ` ${baseClassNameStr}` : ""}`);
        let base = staticConfig.componentName ? t.stringLiteral(`is_${staticConfig.componentName}${baseClassNameStr ? ` ${baseClassNameStr}` : ""}`) : t.stringLiteral(baseClassNameStr || "");
        attrClassName = attrClassName;
        const baseClassNameExpression = attrClassName ? t.isStringLiteral(attrClassName) ? t.stringLiteral(base.value ? `${base.value} ${attrClassName.value}` : attrClassName.value) : t.binaryExpression("+", t.binaryExpression("+", attrClassName, spaceString), base) : base,
          expandedTernaries = [];
        if (onlyTernaries.length) {
          const normalizedTernaries = (0, import_normalizeTernaries.normalizeTernaries)(onlyTernaries);
          for (const ternary of normalizedTernaries) {
            if (!expandedTernaries.length) {
              expandTernary(ternary);
              continue;
            }
            for (const prev of [...expandedTernaries]) expandTernary(ternary, prev);
          }
        }
        function expandTernary(ternary, prev) {
          if (ternary.consequent && Object.keys(ternary.consequent).length) {
            const fontFamily = (0, import_propsToFontFamilyCache.getFontFamilyNameFromProps)(ternary.consequent);
            expandedTernaries.push({
              fontFamily,
              // prevTest && test: merge consequent
              test: prev ? t.logicalExpression("&&", prev.test, ternary.test) : ternary.test,
              consequent: prev ? (0, import_web.mergeProps)(prev.consequent, ternary.consequent) : ternary.consequent,
              remove,
              alternate: null
            }), prev && expandedTernaries.push({
              fontFamily,
              // !prevTest && test: just consequent
              test: t.logicalExpression("&&", t.unaryExpression("!", prev.test), ternary.test),
              consequent: ternary.consequent,
              alternate: null,
              remove
            });
          }
          if (ternary.alternate && Object.keys(ternary.alternate).length) {
            const fontFamily = (0, import_propsToFontFamilyCache.getFontFamilyNameFromProps)(ternary.alternate),
              negated = t.unaryExpression("!", ternary.test);
            expandedTernaries.push({
              fontFamily,
              // prevTest && !test: merge alternate
              test: prev ? t.logicalExpression("&&", prev.test, negated) : negated,
              consequent: prev ? (0, import_web.mergeProps)(prev.alternate, ternary.alternate) : ternary.alternate,
              remove,
              alternate: null
            }), prev && expandedTernaries.push({
              fontFamily,
              test: t.logicalExpression("&&", t.unaryExpression("!", prev.test), ternary.test),
              consequent: ternary.alternate,
              remove,
              alternate: null
            });
          }
        }
        let ternaryClassNameExpr = null;
        if (hasTernaries) for (const ternary of expandedTernaries) {
          if (!ternary.consequent) continue;
          const classNames = addStyles(ternary.consequent);
          ternary.fontFamily && classNames.unshift(`font_${ternary.fontFamily}`);
          const baseString = t.isStringLiteral(baseClassNameExpression) ? baseClassNameExpression.value : "",
            fullClassNameWithDups = (baseString ? `${baseString} ` : "") + classNames.join(" "),
            fullClassName = (0, import_concatClassName.concatClassName)(fullClassNameWithDups),
            classNameLiteral = t.stringLiteral(fullClassName);
          ternaryClassNameExpr ? ternaryClassNameExpr = t.conditionalExpression(ternary.test, classNameLiteral, ternaryClassNameExpr) : ternaryClassNameExpr = t.conditionalExpression(ternary.test, classNameLiteral, baseClassNameExpression);
        }
        let finalExpression = ternaryClassNameExpr || baseClassNameExpression || null;
        if (shouldPrintDebug && (console.info("attrs", JSON.stringify(attrs, null, 2)), console.info("expandedTernaries", JSON.stringify(expandedTernaries, null, 2)), console.info("finalExpression", JSON.stringify(finalExpression, null, 2)), console.info({
          hasTernaries,
          baseClassNameExpression
        })), finalExpression) {
          finalExpression = hoistClassNames(jsxPath, finalExpression);
          const classNameProp = t.jsxAttribute(t.jsxIdentifier("className"), t.jsxExpressionContainer(finalExpression));
          finalAttrs.unshift(classNameProp);
        }
        node.attributes = finalAttrs;
      }
    });
  if (!res || !res.modified && !res.optimized && !res.flattened && !res.styled) return shouldPrintDebug && console.info("no res or none modified", res), null;
  const styles = Array.from(cssMap.values()).map(x => x.css).join(`
`).trim(),
    result = (0, import_generator.default)(ast, {
      concise: !1,
      filename: sourcePath,
      // this makes the debug output terrible, and i think sourcemap works already
      retainLines: !1,
      sourceFileName: sourcePath,
      sourceMaps: !0
    }, source);
  return shouldPrintDebug && (console.info(`
 -------- output code ------- 

`, result.code.split(`
`).filter(x => !x.startsWith("//")).join(`
`)), console.info(`
 -------- output style -------- 

`, styles)), printLog(res), {
    ast,
    styles,
    js: result.code,
    map: result.map
  };
}
function hoistClassNames(path2, expr) {
  if (t.isStringLiteral(expr)) return hoistClassName(path2, expr.value);
  if (t.isLogicalExpression(expr)) {
    const left = t.isStringLiteral(expr.left) ? hoistClassName(path2, expr.left.value) : expr.left,
      right = t.isStringLiteral(expr.right) ? hoistClassName(path2, expr.right.value) : hoistClassNames(path2, expr.right);
    return t.logicalExpression(expr.operator, left, right);
  }
  if (t.isConditionalExpression(expr)) {
    const cons = t.isStringLiteral(expr.consequent) ? hoistClassName(path2, expr.consequent.value) : hoistClassNames(path2, expr.consequent),
      alt = t.isStringLiteral(expr.alternate) ? hoistClassName(path2, expr.alternate.value) : hoistClassNames(path2, expr.alternate);
    return t.conditionalExpression(expr.test, cons, alt);
  }
  return expr;
}
function hoistClassName(path2, str) {
  const uid = path2.scope.generateUidIdentifier("cn"),
    parent = path2.findParent(path3 => path3.isProgram());
  if (!parent) throw new Error("no program?");
  const variable = t.variableDeclaration("const", [t.variableDeclarator(uid, t.stringLiteral(cleanupClassName(str)))]);
  return parent.unshiftContainer("body", variable), uid;
}
function cleanupClassName(inStr) {
  const out = /* @__PURE__ */new Set();
  for (const part of inStr.split(" ")) part !== " " && part !== "font_" && out.add(part);
  return [...out].join(" ") + " ";
}