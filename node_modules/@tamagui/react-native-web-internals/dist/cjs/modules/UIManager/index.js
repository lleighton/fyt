var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var UIManager_exports = {};
__export(UIManager_exports, {
  UIManager: () => UIManager
});
module.exports = __toCommonJS(UIManager_exports);
var import_use_element_layout = require("@tamagui/use-element-layout");
const focusableElements = {
  A: !0,
  INPUT: !0,
  SELECT: !0,
  TEXTAREA: !0
}, UIManager = {
  blur(node) {
    try {
      node.blur();
    } catch {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch {
    }
  },
  measure(node, callback) {
    return (0, import_use_element_layout.measure)(node, callback);
  },
  measureInWindow(node, callback) {
    return (0, import_use_element_layout.measureInWindow)(node, callback);
  },
  // note its flipped fail and success on purpose lol
  async measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    return measureLayout(node, relativeToNativeNode, onSuccess);
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
//# sourceMappingURL=index.js.map
