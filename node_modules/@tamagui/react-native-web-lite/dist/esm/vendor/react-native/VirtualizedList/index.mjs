import { invariant } from "@tamagui/react-native-web-internals";
import { ScrollView } from "../../../ScrollView";
import { RefreshControl } from "../../../RefreshControl";
import { Batchinator } from "../Batchinator";
import { ChildListCollection } from "./ChildListCollection.mjs";
import { FillRateHelper } from "../FillRateHelper";
import { StateSafePureComponent } from "./StateSafePureComponent.mjs";
import { ViewabilityHelper } from "../ViewabilityHelper.mjs";
import { CellRenderer } from "./VirtualizedListCellRenderer.mjs";
import { VirtualizedListContext } from "./VirtualizedListContext.mjs";
import { jsx } from "react/jsx-runtime";
const __DEV__ = process.env.NODE_ENV !== "production";
function horizontalOrDefault(horizontal) {
  return horizontal ?? !1;
}
function scrollEventThrottleOrDefault(scrollEventThrottle) {
  return scrollEventThrottle ?? 50;
}
class VirtualizedList extends StateSafePureComponent {
  static contextType = VirtualizedListContext;
  constructor(props) {
    super(props), this._nestedChildLists = new ChildListCollection(), this._viewabilityTuples = [], this._scrollMetrics = {
      contentLength: 0,
      dOffset: 0,
      dt: 10,
      offset: 0,
      timestamp: 0,
      velocity: 0,
      visibleLength: 0
    }, this._highestMeasuredFrameIndex = 0, this._headerLength = 0, this._footerLength = 0, this._averageCellLength = 0, this._hasWarned = {}, this._fillRateHelper = new FillRateHelper(this._getFrameMetrics), this._updateCellsToRenderBatcher = new Batchinator(this._updateCellsToRender, this.props.updateCellsBatchingPeriod ?? 50), this.props.viewabilityConfig && this.props.onViewableItemsChanged && this._viewabilityTuples.push({
      viewabilityHelper: new ViewabilityHelper(this.props.viewabilityConfig),
      onViewableItemsChanged: this.props.onViewableItemsChanged
    });
  }
  scrollToEnd(params) {
    const animated = params ? params.animated : !0,
      veryLast = this.props.getItemCount(this.props.data) - 1;
    if (veryLast < 0) return;
    const frame = this.__getFrameMetricsApprox(veryLast, this.props),
      offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);
    if (this._scrollRef != null) {
      if (this._scrollRef.scrollTo == null) {
        console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
        return;
      }
      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }
  }
  scrollToIndex(params) {
    const {
        data,
        horizontal,
        getItemCount,
        getItemLayout,
        onScrollToIndexFailed
      } = this.props,
      {
        animated,
        index,
        viewOffset,
        viewPosition
      } = params;
    if (invariant(index >= 0, `scrollToIndex out of range: requested index ${index} but minimum is 0`), invariant(getItemCount(data) >= 1, `scrollToIndex out of range: item length ${getItemCount(data)} but minimum is 1`), invariant(index < getItemCount(data), `scrollToIndex out of range: requested index ${index} is out of 0 to ${getItemCount(data) - 1}`), !getItemLayout && index > this._highestMeasuredFrameIndex) {
      invariant(!!onScrollToIndexFailed, "scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, otherwise there is no way to know the location of offscreen indices or handle failures."), onScrollToIndexFailed({
        averageItemLength: this._averageCellLength,
        highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
        index
      });
      return;
    }
    const frame = this.__getFrameMetricsApprox(Math.floor(index), this.props),
      offset = Math.max(0, this._getOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);
    this._scrollRef != null && this._scrollRef.scrollTo(horizontalOrDefault(horizontal) ? {
      x: offset,
      animated
    } : {
      y: offset,
      animated
    });
  }
  scrollToItem(params) {
    const {
        data,
        getItem,
        getItemCount,
        horizontal,
        onScrollToIndexFailed
      } = this.props,
      {
        animated,
        item,
        viewPosition,
        viewOffset
      } = params,
      index = this.props.data.indexOf(item);
    if (index !== -1) this.scrollToIndex({
      animated,
      index,
      viewOffset,
      viewPosition
    });else {
      const itemCount = getItemCount(data);
      for (let i = 0; i < itemCount; i++) if (getItem(data, i) === item) {
        this.scrollToIndex({
          animated,
          index: i,
          viewOffset,
          viewPosition
        });
        break;
      }
    }
  }
  scrollToOffset(params) {
    const {
      animated,
      offset
    } = params;
    this._scrollRef != null && this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
      x: offset,
      animated
    } : {
      y: offset,
      animated
    });
  }
  recordInteraction() {
    this._nestedChildLists.forEach(childList => {
      childList.recordInteraction();
    }), this._viewabilityTuples.forEach(viewabilityTuple => {
      viewabilityTuple.viewabilityHelper.recordInteraction();
    });
  }
  flashScrollIndicators() {
    this._scrollRef && this._scrollRef.flashScrollIndicators && this._scrollRef.flashScrollIndicators();
  }
  getScrollResponder() {
    if (this._scrollRef && this._scrollRef.getScrollResponder) return this._scrollRef.getScrollResponder();
  }
  getScrollableNode() {
    if (this._scrollRef && this._scrollRef.getScrollableNode) return this._scrollRef.getScrollableNode();
  }
  getScrollRef() {
    return this._scrollRef;
  }
  setNativeProps(props) {
    this._scrollRef && this._scrollRef.setNativeProps(props);
  }
  render() {
    const {
      ListEmptyComponent,
      ListFooterComponent,
      ListHeaderComponent,
      data,
      debug,
      disableVirtualization,
      getItem,
      getItemCount,
      getItemLayout,
      horizontal,
      keyExtractor,
      numColumns,
      onEndReached,
      onEndReachedThreshold,
      onLayout,
      onRefresh,
      onScroll,
      onScrollBeginDrag,
      onScrollEndDrag,
      onMomentumScrollBegin,
      onMomentumScrollEnd,
      onStartReached,
      onStartReachedThreshold,
      onViewableItemsChanged,
      refreshing,
      removeClippedSubviews,
      renderItem,
      viewabilityConfig,
      viewabilityConfigCallbackPairs,
      ...restProps
    } = this.props;
    return getItemCount(data) === 0 ? ListEmptyComponent ? /* @__PURE__ */jsx(ListEmptyComponent, {}) : null : /* @__PURE__ */jsx(ScrollView, {
      ...restProps,
      ref: this._captureRef,
      onContentSizeChange: this._onContentSizeChange,
      onLayout: this._onLayout,
      onScroll: this._onScroll,
      refreshControl: onRefresh && /* @__PURE__ */jsx(RefreshControl, {
        refreshing,
        onRefresh
      }),
      scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
      removeClippedSubviews,
      children: this._renderChildren()
    });
  }
  _renderChildren() {
    const {
        data,
        getItem,
        getItemCount,
        renderItem
      } = this.props,
      items = [];
    for (let i = 0; i < getItemCount(data); i++) {
      const item = getItem(data, i);
      items.push(/* @__PURE__ */jsx(CellRenderer, {
        cellKey: String(i),
        index: i,
        item,
        renderItem
      }, this.props.keyExtractor ? this.props.keyExtractor(item, i) : i));
    }
    return items;
  }
  _captureRef = ref => {
    this._scrollRef = ref;
  };
  _onContentSizeChange = (width, height) => {};
  _onLayout = event => {};
  _onScroll = event => {};
  __getFrameMetricsApprox(index, props) {
    return {
      length: this._averageCellLength,
      offset: this._averageCellLength * index
    };
  }
  _getOffsetApprox(index, props) {
    return this.__getFrameMetricsApprox(index, props).offset;
  }
}
var VirtualizedList_default = VirtualizedList;
export { VirtualizedList, VirtualizedList_default as default };
//# sourceMappingURL=index.mjs.map
