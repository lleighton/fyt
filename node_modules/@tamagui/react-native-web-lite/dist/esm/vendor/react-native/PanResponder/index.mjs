const currentCentroidXOfTouchesChangedAfter = () => 0,
  currentCentroidYOfTouchesChangedAfter = () => 0,
  previousCentroidXOfTouchesChangedAfter = () => 0,
  previousCentroidYOfTouchesChangedAfter = () => 0,
  PanResponder = {
    _initializeGestureState(gestureState) {
      gestureState.moveX = 0, gestureState.moveY = 0, gestureState.x0 = 0, gestureState.y0 = 0, gestureState.dx = 0, gestureState.dy = 0, gestureState.vx = 0, gestureState.vy = 0, gestureState.numberActiveTouches = 0, gestureState._accountsForMovesUpTo = 0;
    },
    _updateGestureStateOnMove(gestureState, touchHistory) {
      gestureState.numberActiveTouches = touchHistory.numberActiveTouches, gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo), gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      const movedAfter = gestureState._accountsForMovesUpTo,
        prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter),
        prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter),
        nextDX = gestureState.dx + (gestureState.moveX - prevX),
        nextDY = gestureState.dy + (gestureState.moveY - prevY),
        dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
      gestureState.vx = (nextDX - gestureState.dx) / dt, gestureState.vy = (nextDY - gestureState.dy) / dt, gestureState.dx = nextDX, gestureState.dy = nextDY, gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
    },
    create(config) {
      const interactionState = {
          handle: null
        },
        gestureState = {
          stateID: Math.random(),
          moveX: 0,
          moveY: 0,
          x0: 0,
          y0: 0,
          dx: 0,
          dy: 0,
          vx: 0,
          vy: 0,
          numberActiveTouches: 0,
          _accountsForMovesUpTo: 0
        };
      return {
        panHandlers: {
          onStartShouldSetResponder: evt => config.onStartShouldSetPanResponder ? config.onStartShouldSetPanResponder(evt, gestureState) : !1,
          onMoveShouldSetResponder: evt => config.onMoveShouldSetPanResponder ? config.onMoveShouldSetPanResponder(evt, gestureState) : !1,
          onResponderGrant: evt => {
            this._initializeGestureState(gestureState), gestureState.x0 = evt.nativeEvent.pageX || 0, gestureState.y0 = evt.nativeEvent.pageY || 0, config.onPanResponderGrant && config.onPanResponderGrant(evt, gestureState);
          },
          onResponderMove: evt => {
            evt.nativeEvent.touches && evt.nativeEvent.touches.length === 1 && this._updateGestureStateOnMove(gestureState, evt.nativeEvent), config.onPanResponderMove && config.onPanResponderMove(evt, gestureState);
          },
          onResponderRelease: evt => {
            config.onPanResponderRelease && config.onPanResponderRelease(evt, gestureState), interactionState.handle && (interactionState.handle = null);
          },
          onResponderTerminate: evt => {
            config.onPanResponderTerminate && config.onPanResponderTerminate(evt, gestureState), interactionState.handle && (interactionState.handle = null);
          },
          onResponderTerminationRequest: evt => config.onPanResponderTerminationRequest ? config.onPanResponderTerminationRequest(evt, gestureState) : !0
        },
        getInteractionHandle() {
          return interactionState.handle;
        }
      };
    }
  };
var PanResponder_default = PanResponder;
export { PanResponder, PanResponder_default as default };
//# sourceMappingURL=index.mjs.map
