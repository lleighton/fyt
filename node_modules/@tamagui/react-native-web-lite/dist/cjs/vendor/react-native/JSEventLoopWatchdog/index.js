"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var JSEventLoopWatchdog_exports = {};
__export(JSEventLoopWatchdog_exports, {
  JSEventLoopWatchdog: () => JSEventLoopWatchdog,
  default: () => JSEventLoopWatchdog_default
});
module.exports = __toCommonJS(JSEventLoopWatchdog_exports);
var import_infoLog = require("../infoLog");
const JSEventLoopWatchdog = {
  getStats: function() {
    return { stallCount, totalStallTime, longestStall, acceptableBusyTime };
  },
  reset: function() {
    (0, import_infoLog.infoLog)("JSEventLoopWatchdog: reset"), totalStallTime = 0, stallCount = 0, longestStall = 0, lastInterval = window.performance.now();
  },
  addHandler: function(handler) {
    handlers.push(handler);
  },
  install: function({ thresholdMS }) {
    if (acceptableBusyTime = thresholdMS, installed)
      return;
    installed = !0, lastInterval = window.performance.now();
    function iteration() {
      const now = window.performance.now(), busyTime = now - lastInterval;
      if (busyTime >= thresholdMS) {
        const stallTime = busyTime - thresholdMS;
        stallCount++, totalStallTime += stallTime, longestStall = Math.max(longestStall, stallTime);
        let msg = `JSEventLoopWatchdog: JS thread busy for ${busyTime}ms. ${totalStallTime}ms in ${stallCount} stalls so far. `;
        handlers.forEach((handler) => {
          msg += handler.onStall({ lastInterval, busyTime }) || "";
        }), (0, import_infoLog.infoLog)(msg);
      }
      handlers.forEach((handler) => {
        handler.onIterate && handler.onIterate();
      }), lastInterval = now, setTimeout(iteration, thresholdMS / 5);
    }
    iteration();
  }
};
let acceptableBusyTime = 0, installed = !1, totalStallTime = 0, stallCount = 0, longestStall = 0, lastInterval = 0;
const handlers = [];
var JSEventLoopWatchdog_default = JSEventLoopWatchdog;
//# sourceMappingURL=index.js.map
