var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var PanResponder_exports = {};
__export(PanResponder_exports, {
  PanResponder: () => PanResponder,
  default: () => PanResponder_default
});
module.exports = __toCommonJS(PanResponder_exports);
const currentCentroidXOfTouchesChangedAfter = () => 0, currentCentroidYOfTouchesChangedAfter = () => 0, previousCentroidXOfTouchesChangedAfter = () => 0, previousCentroidYOfTouchesChangedAfter = () => 0, PanResponder = {
  _initializeGestureState(gestureState) {
    gestureState.moveX = 0, gestureState.moveY = 0, gestureState.x0 = 0, gestureState.y0 = 0, gestureState.dx = 0, gestureState.dy = 0, gestureState.vx = 0, gestureState.vy = 0, gestureState.numberActiveTouches = 0, gestureState._accountsForMovesUpTo = 0;
  },
  _updateGestureStateOnMove(gestureState, touchHistory) {
    gestureState.numberActiveTouches = touchHistory.numberActiveTouches, gestureState.moveX = currentCentroidXOfTouchesChangedAfter(
      touchHistory,
      gestureState._accountsForMovesUpTo
    ), gestureState.moveY = currentCentroidYOfTouchesChangedAfter(
      touchHistory,
      gestureState._accountsForMovesUpTo
    );
    const movedAfter = gestureState._accountsForMovesUpTo, prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter), prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter), nextDX = gestureState.dx + (gestureState.moveX - prevX), nextDY = gestureState.dy + (gestureState.moveY - prevY), dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
    gestureState.vx = (nextDX - gestureState.dx) / dt, gestureState.vy = (nextDY - gestureState.dy) / dt, gestureState.dx = nextDX, gestureState.dy = nextDY, gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
  },
  create(config) {
    const interactionState = {
      handle: null
    }, gestureState = {
      stateID: Math.random(),
      moveX: 0,
      moveY: 0,
      x0: 0,
      y0: 0,
      dx: 0,
      dy: 0,
      vx: 0,
      vy: 0,
      numberActiveTouches: 0,
      _accountsForMovesUpTo: 0
    };
    return {
      panHandlers: {
        onStartShouldSetResponder: (evt) => config.onStartShouldSetPanResponder ? config.onStartShouldSetPanResponder(evt, gestureState) : !1,
        onMoveShouldSetResponder: (evt) => config.onMoveShouldSetPanResponder ? config.onMoveShouldSetPanResponder(evt, gestureState) : !1,
        onResponderGrant: (evt) => {
          this._initializeGestureState(gestureState), gestureState.x0 = evt.nativeEvent.pageX || 0, gestureState.y0 = evt.nativeEvent.pageY || 0, config.onPanResponderGrant && config.onPanResponderGrant(evt, gestureState);
        },
        onResponderMove: (evt) => {
          evt.nativeEvent.touches && evt.nativeEvent.touches.length === 1 && this._updateGestureStateOnMove(gestureState, evt.nativeEvent), config.onPanResponderMove && config.onPanResponderMove(evt, gestureState);
        },
        onResponderRelease: (evt) => {
          config.onPanResponderRelease && config.onPanResponderRelease(evt, gestureState), interactionState.handle && (interactionState.handle = null);
        },
        onResponderTerminate: (evt) => {
          config.onPanResponderTerminate && config.onPanResponderTerminate(evt, gestureState), interactionState.handle && (interactionState.handle = null);
        },
        onResponderTerminationRequest: (evt) => config.onPanResponderTerminationRequest ? config.onPanResponderTerminationRequest(evt, gestureState) : !0
      },
      getInteractionHandle() {
        return interactionState.handle;
      }
    };
  }
};
var PanResponder_default = PanResponder;
//# sourceMappingURL=index.js.map
