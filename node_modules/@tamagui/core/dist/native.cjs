"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
function _interopNamespaceDefault(e2) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k in e2) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e2, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e2[k]
        });
      }
    }
  }
  n.default = e2;
  return Object.freeze(n);
}
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e2 = m[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k in e2) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e2[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config)
        "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config ? config : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var pseudoDescriptorsBase = {
  // order of keys here important! in priority order
  hoverStyle: {
    name: "hover",
    priority: 2
  },
  pressStyle: {
    name: "active",
    stateKey: "press",
    priority: 3
  },
  focusVisibleStyle: {
    name: "focus-visible",
    priority: 4,
    stateKey: "focusVisible"
  },
  focusStyle: {
    name: "focus",
    priority: 4
  },
  focusWithinStyle: {
    name: "focus-within",
    priority: 4,
    stateKey: "focusWithin"
  },
  disabledStyle: {
    name: "disabled",
    priority: 5,
    stateKey: "disabled"
  }
}, pseudoPriorities = {
  hover: pseudoDescriptorsBase.hoverStyle.priority,
  press: pseudoDescriptorsBase.pressStyle.priority,
  focus: pseudoDescriptorsBase.focusStyle.priority,
  focusVisible: pseudoDescriptorsBase.focusVisibleStyle.priority,
  focusWithin: pseudoDescriptorsBase.focusWithinStyle.priority,
  disabled: pseudoDescriptorsBase.disabledStyle.priority
}, pseudoDescriptors = __spreadProps(__spreadValues({}, pseudoDescriptorsBase), {
  enterStyle: {
    name: "enter",
    selector: ".t_unmounted",
    priority: 4
  },
  exitStyle: {
    name: "exit",
    priority: 5
  }
}), defaultMediaImportance = Object.keys(pseudoDescriptors).length;
function _type_of$9(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var mergeProps = function(defaultProps2, props) {
  var out = {};
  for (var key in defaultProps2) key in props || (out[key] = defaultProps2[key]);
  for (var key1 in props) mergeProp(out, defaultProps2, props, key1);
  return out;
}, mergeComponentProps = function(defaultProps2, contextProps, props) {
  var overriddenContext = null;
  if (!defaultProps2 && !contextProps) return [props, overriddenContext];
  if (defaultProps2 && !contextProps) return [mergeProps(defaultProps2, props), overriddenContext];
  var out = {};
  for (var key in defaultProps2) key in props || (out[key] = defaultProps2[key]);
  for (var key1 in contextProps) if (!(key1 in props)) {
    var contextValue = contextProps[key1];
    contextValue !== void 0 && (out[key1] = contextValue);
  }
  for (var key2 in props) mergeProp(out, defaultProps2, props, key2), contextProps && key2 in contextProps && (overriddenContext || (overriddenContext = {}), overriddenContext[key2] = props[key2]);
  return [out, overriddenContext];
};
function mergeProp(out, defaultProps2, props, key) {
  var val = props[key];
  if (defaultProps2 && key in defaultProps2 && (key in pseudoDescriptors || key[0] === "$") && val && (typeof val > "u" ? "undefined" : _type_of$9(val)) === "object") {
    var defaultVal = defaultProps2[key];
    defaultVal && (typeof defaultVal > "u" ? "undefined" : _type_of$9(defaultVal)) === "object" && (val = mergeProps(defaultVal, val));
  }
  out[key] = val;
}
function _type_of$8(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function objectIdentityKey(obj) {
  var k = "";
  for (var key in obj) {
    k += key;
    var arg = obj[key], type = typeof arg > "u" ? "undefined" : _type_of$8(arg);
    if (!arg || type !== "object" && type !== "function") k += type + arg;
    else if (cache$6.has(arg)) k += cache$6.get(arg);
    else {
      var v = Math.random();
      cache$6.set(arg, v), k += v;
    }
  }
  return k;
}
var cache$6 = /* @__PURE__ */ new WeakMap();
var createReactContext = React["createContext"];
function createStyledContext(defaultValues) {
  var namespace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", OGContext = createReactContext(defaultValues), OGProvider = OGContext.Provider, Context = OGContext, scopedContexts = /* @__PURE__ */ new Map(), LastScopeInNamespace = createReactContext(namespace);
  function getOrCreateScopedContext(scope) {
    var ScopedContext = scopedContexts.get(scope);
    return ScopedContext || (ScopedContext = createReactContext(defaultValues), scopedContexts.set(scope, ScopedContext)), ScopedContext;
  }
  var getNamespacedScope = function(scope) {
    return namespace ? `${namespace}--${scope}` : scope;
  }, Provider = function(param) {
    var _a = param, {
      children,
      scope: scopeIn,
      __disableMergeDefaultValues: __disableMergeDefaultValues
    } = _a, values = __objRest(_a, [
      "children",
      "scope",
      // performance: avoid creating objects
      "__disableMergeDefaultValues"
    ]), scope = getNamespacedScope(scopeIn), next = React.useMemo(function() {
      return __disableMergeDefaultValues ? values : mergeProps(defaultValues, values);
    }, [objectIdentityKey(values)]), ScopedProvider = OGProvider;
    return scope && (ScopedProvider = getOrCreateScopedContext(scope).Provider), /* @__PURE__ */ jsxRuntimeExports.jsx(LastScopeInNamespace.Provider, {
      value: scope,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScopedProvider, {
        value: next,
        children
      })
    });
  }, useStyledContext = function() {
    var scopeIn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", lastScopeInNamespace = React.useContext(LastScopeInNamespace), scope = namespace ? scopeIn ? getNamespacedScope(scopeIn) : lastScopeInNamespace : scopeIn, context = scope ? getOrCreateScopedContext(scope) : OGContext, value = React.useContext(context);
    return value;
  };
  return Context.Provider = Provider, Context.props = defaultValues, Context.context = OGContext, Context.useStyledContext = useStyledContext, Context;
}
var ComponentContext = createStyledContext({
  disableSSR: void 0,
  inText: false,
  language: null,
  animationDriver: null,
  setParentFocusState: null
}), useConfiguration = function() {
  return React.useContext(ComponentContext);
};
var GroupContext = /* @__PURE__ */ React.createContext(null);
function useCreateShallowSetState(setter, debug) {
  return React.useCallback(function(stateOrGetState) {
    setter(function(prev) {
      var next = typeof stateOrGetState == "function" ? stateOrGetState(prev) : stateOrGetState, update2 = mergeIfNotShallowEqual(prev, next);
      return update2;
    });
  }, [setter, debug]);
}
function mergeIfNotShallowEqual(prev, next) {
  return !prev || !next || isEqualShallow(prev, next) ? prev || next : __spreadValues(__spreadValues({}, prev), next);
}
function isEqualShallow(prev, next) {
  for (var key in next) if (prev[key] !== next[key]) return false;
  return true;
}
const assets = [];
function getAssetByID(assetId) {
  return assets[assetId - 1];
}
const defaultProps$1 = {
  children: true,
  dataSet: true,
  nativeID: true,
  ref: true,
  suppressHydrationWarning: true,
  testID: true,
  id: true
}, accessibilityProps = {
  accessibilityActiveDescendant: true,
  accessibilityAtomic: true,
  accessibilityAutoComplete: true,
  accessibilityBusy: true,
  accessibilityChecked: true,
  accessibilityColumnCount: true,
  accessibilityColumnIndex: true,
  accessibilityColumnSpan: true,
  accessibilityControls: true,
  accessibilityCurrent: true,
  accessibilityDescribedBy: true,
  accessibilityDetails: true,
  accessibilityDisabled: true,
  accessibilityErrorMessage: true,
  accessibilityExpanded: true,
  accessibilityFlowTo: true,
  accessibilityHasPopup: true,
  accessibilityHidden: true,
  accessibilityInvalid: true,
  accessibilityKeyShortcuts: true,
  accessibilityLabel: true,
  accessibilityLabelledBy: true,
  accessibilityLevel: true,
  accessibilityLiveRegion: true,
  accessibilityModal: true,
  accessibilityMultiline: true,
  accessibilityMultiSelectable: true,
  accessibilityOrientation: true,
  accessibilityOwns: true,
  accessibilityPlaceholder: true,
  accessibilityPosInSet: true,
  accessibilityPressed: true,
  accessibilityReadOnly: true,
  accessibilityRequired: true,
  accessibilityRole: true,
  accessibilityRoleDescription: true,
  accessibilityRowCount: true,
  accessibilityRowIndex: true,
  accessibilityRowSpan: true,
  accessibilitySelected: true,
  accessibilitySetSize: true,
  accessibilitySort: true,
  accessibilityValueMax: true,
  accessibilityValueMin: true,
  accessibilityValueNow: true,
  accessibilityValueText: true,
  dir: true,
  focusable: true
}, clickProps = {
  onClick: true,
  onClickCapture: true,
  onContextMenu: true
}, focusProps = {
  onBlur: true,
  onFocus: true
}, keyboardProps = {
  onKeyDown: true,
  onKeyDownCapture: true,
  onKeyUp: true,
  onKeyUpCapture: true
}, mouseProps = {
  onMouseDown: true,
  onMouseEnter: true,
  onMouseLeave: true,
  onMouseMove: true,
  onMouseOver: true,
  onMouseOut: true,
  onMouseUp: true
}, touchProps = {
  onTouchCancel: true,
  onTouchCancelCapture: true,
  onTouchEnd: true,
  onTouchEndCapture: true,
  onTouchMove: true,
  onTouchMoveCapture: true,
  onTouchStart: true,
  onTouchStartCapture: true
}, styleProps = {
  classList: true,
  style: true
}, forwardedProps = {
  defaultProps: defaultProps$1,
  accessibilityProps,
  clickProps,
  focusProps,
  keyboardProps,
  mouseProps,
  touchProps,
  styleProps
}, forwardPropsListText = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultProps$1), accessibilityProps), clickProps), focusProps), keyboardProps), mouseProps), touchProps), styleProps), {
  href: true,
  lang: true,
  pointerEvents: true
}), forwardPropsListView = __spreadProps(__spreadValues({}, forwardPropsListText), {
  onScroll: true,
  onWheel: true
});
function mergeRefs(...args) {
  return function(node) {
    args.forEach((ref) => {
      if (ref != null) {
        if (typeof ref == "function") {
          ref(node);
          return;
        }
        if (typeof ref == "object") {
          ref.current = node;
          return;
        }
        console.error(`mergeRefs cannot handle Refs of type boolean, number or string, received ref ${String(ref)}`);
      }
    });
  };
}
const canUseDOM$1 = !!(typeof window < "u" && window.document && window.document.createElement);
const emptyFunction$1 = () => {
};
function supportsPassiveEvents() {
  let supported = false;
  if (canUseDOM$1) try {
    const options = {};
    Object.defineProperty(options, "passive", {
      get() {
        return supported = true, false;
      }
    }), window.addEventListener("test", null, options), window.removeEventListener("test", null, options);
  } catch (e2) {
  }
  return supported;
}
const canUsePassiveEvents = supportsPassiveEvents();
function getOptions(options) {
  return options == null ? false : canUsePassiveEvents ? options : !!options.capture;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function normalizeEvent(event) {
  return event.nativeEvent = event, event.persist = emptyFunction$1, event.isDefaultPrevented = isDefaultPrevented, event.isPropagationStopped = isPropagationStopped, event;
}
function createEventHandle(type, options) {
  const opts2 = getOptions(options);
  return function(target, listener) {
    if (target == null || typeof target.addEventListener != "function") throw new Error("createEventHandle: called on an invalid target.");
    const element = target;
    if (listener != null) {
      const compatListener = (e2) => listener(normalizeEvent(e2));
      return element.addEventListener(type, compatListener, opts2), function() {
        element == null ? void 0 : element.removeEventListener(type, compatListener, opts2);
      };
    } else return emptyFunction$1;
  };
}
const supportsPointerEvent$1 = () => typeof window < "u" && window.PointerEvent != null;
let activeModality = "keyboard", modality = "keyboard", previousModality, previousActiveModality, isEmulatingMouseEvents$1 = false;
const listeners$3 = /* @__PURE__ */ new Set(), KEYBOARD = "keyboard", MOUSE = "mouse", TOUCH = "touch", BLUR = "blur", CONTEXTMENU = "contextmenu", FOCUS = "focus", KEYDOWN = "keydown", MOUSEDOWN = "mousedown", MOUSEMOVE = "mousemove", MOUSEUP = "mouseup", POINTERDOWN = "pointerdown", POINTERMOVE = "pointermove", SCROLL$1 = "scroll", SELECTIONCHANGE = "selectionchange", TOUCHCANCEL = "touchcancel", TOUCHMOVE = "touchmove", TOUCHSTART = "touchstart", VISIBILITYCHANGE = "visibilitychange", bubbleOptions = {
  passive: true
}, captureOptions = {
  capture: true,
  passive: true
}, addBlurListener = createEventHandle(BLUR, bubbleOptions), addFocusListener = createEventHandle(FOCUS, bubbleOptions), addVisibilityChangeListener = createEventHandle(VISIBILITYCHANGE, captureOptions), addKeyDownListener = createEventHandle(KEYDOWN, captureOptions), addPointerDownListener = createEventHandle(POINTERDOWN, captureOptions), addPointerMoveListener = createEventHandle(POINTERMOVE, captureOptions), addContextMenuListener = createEventHandle(CONTEXTMENU, captureOptions), addMouseDownListener = createEventHandle(MOUSEDOWN, captureOptions), addMouseMoveListener = createEventHandle(MOUSEMOVE, captureOptions), addMouseUpListener = createEventHandle(MOUSEUP, captureOptions), addScrollListener = createEventHandle(SCROLL$1, captureOptions), addSelectiomChangeListener = createEventHandle(SELECTIONCHANGE, captureOptions), addTouchCancelListener = createEventHandle(TOUCHCANCEL, captureOptions), addTouchMoveListener = createEventHandle(TOUCHMOVE, captureOptions), addTouchStartListener = createEventHandle(TOUCHSTART, captureOptions);
function restoreModality() {
  (previousModality != null || previousActiveModality != null) && (previousModality != null && (modality = previousModality, previousModality = null), previousActiveModality != null && (activeModality = previousActiveModality, previousActiveModality = null), callListeners());
}
function onBlurWindow() {
  previousModality = modality, previousActiveModality = activeModality, activeModality = KEYBOARD, modality = KEYBOARD, callListeners(), isEmulatingMouseEvents$1 = false;
}
function onFocusWindow() {
  restoreModality();
}
function onKeyDown(event) {
  event.metaKey || event.altKey || event.ctrlKey || modality !== KEYBOARD && (modality = KEYBOARD, activeModality = KEYBOARD, callListeners());
}
function onVisibilityChange() {
  document.visibilityState !== "hidden" && restoreModality();
}
function onPointerish(event) {
  const eventType = event.type;
  if (supportsPointerEvent$1()) {
    if (eventType === POINTERDOWN) {
      activeModality !== event.pointerType && (modality = event.pointerType, activeModality = event.pointerType, callListeners());
      return;
    }
    if (eventType === POINTERMOVE) {
      modality !== event.pointerType && (modality = event.pointerType, callListeners());
      return;
    }
  } else {
    if (isEmulatingMouseEvents$1 || (eventType === MOUSEDOWN && activeModality !== MOUSE && (modality = MOUSE, activeModality = MOUSE, callListeners()), eventType === MOUSEMOVE && modality !== MOUSE && (modality = MOUSE, callListeners())), eventType === TOUCHSTART) {
      isEmulatingMouseEvents$1 = true, event.touches && event.touches.length > 1 && (isEmulatingMouseEvents$1 = false), activeModality !== TOUCH && (modality = TOUCH, activeModality = TOUCH, callListeners());
      return;
    }
    (eventType === CONTEXTMENU || eventType === MOUSEUP || eventType === SELECTIONCHANGE || eventType === SCROLL$1 || eventType === TOUCHCANCEL || eventType === TOUCHMOVE) && (isEmulatingMouseEvents$1 = false);
  }
}
canUseDOM$1 && (addBlurListener(window, onBlurWindow), addFocusListener(window, onFocusWindow), addKeyDownListener(document, onKeyDown), addPointerDownListener(document, onPointerish), addPointerMoveListener(document, onPointerish), addVisibilityChangeListener(document, onVisibilityChange), addContextMenuListener(document, onPointerish), addMouseDownListener(document, onPointerish), addMouseMoveListener(document, onPointerish), addMouseUpListener(document, onPointerish), addTouchCancelListener(document, onPointerish), addTouchMoveListener(document, onPointerish), addTouchStartListener(document, onPointerish), addSelectiomChangeListener(document, onPointerish), addScrollListener(document, onPointerish));
function callListeners() {
  const value = {
    activeModality,
    modality
  };
  listeners$3.forEach((listener) => {
    listener(value);
  });
}
function getModality() {
  return modality;
}
const rtlScripts = /* @__PURE__ */ new Set(["Arab", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]), rtlLangs = /* @__PURE__ */ new Set([
  "ae",
  // Avestan
  "ar",
  // Arabic
  "arc",
  // Aramaic
  "bcc",
  // Southern Balochi
  "bqi",
  // Bakthiari
  "ckb",
  // Sorani
  "dv",
  // Dhivehi
  "fa",
  "far",
  // Persian
  "glk",
  // Gilaki
  "he",
  "iw",
  // Hebrew
  "khw",
  // Khowar
  "ks",
  // Kashmiri
  "ku",
  // Kurdish
  "mzn",
  // Mazanderani
  "nqo",
  // N'Ko
  "pnb",
  // Western Punjabi
  "ps",
  // Pashto
  "sd",
  // Sindhi
  "ug",
  // Uyghur
  "ur",
  // Urdu
  "yi"
  // Yiddish
]), cache$5 = /* @__PURE__ */ new Map();
function isLocaleRTL(locale) {
  const cachedRTL = cache$5.get(locale);
  if (cachedRTL) return cachedRTL;
  let isRTL = false;
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script;
    isRTL = rtlScripts.has(script);
  } else {
    const lang = locale.split("-")[0];
    isRTL = rtlLangs.has(lang);
  }
  return cache$5.set(locale, isRTL), isRTL;
}
const defaultLocale = {
  direction: "ltr",
  locale: "en-US"
}, LocaleContext = React.createContext(defaultLocale);
function getLocaleDirection(locale) {
  return isLocaleRTL(locale) ? "rtl" : "ltr";
}
function LocaleProvider(props) {
  const {
    direction,
    locale,
    children
  } = props;
  return direction || locale ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleContext.Provider, {
    value: {
      direction: locale ? getLocaleDirection(locale) : direction,
      locale
    },
    children
  }) : children;
}
function useLocaleContext() {
  return React.useContext(LocaleContext);
}
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
var LayoutHandlers = /* @__PURE__ */ new WeakMap(), LayoutDisableKey = /* @__PURE__ */ new WeakMap(), Nodes = /* @__PURE__ */ new Set(), IntersectionState = /* @__PURE__ */ new WeakMap(), DisableLayoutContextKey = /* @__PURE__ */ React.createContext(""), LayoutMeasurementController = function(param) {
  var {
    disable,
    children
  } = param, id2 = React.useId();
  return useIsomorphicLayoutEffect(function() {
  }, [disable, id2]), /* @__PURE__ */ jsxRuntimeExports.jsx(DisableLayoutContextKey.Provider, {
    value: id2,
    children
  });
};
function setOnLayoutStrategy(state) {
}
var NodeRectCache = /* @__PURE__ */ new WeakMap(), LastChangeTime = /* @__PURE__ */ new WeakMap(), avoidUpdates = true, queuedUpdates = /* @__PURE__ */ new Map();
function enable() {
  avoidUpdates && (avoidUpdates = false, queuedUpdates && (queuedUpdates.forEach(function(cb) {
    return cb();
  }), queuedUpdates.clear()));
}
var getElementLayoutEvent = function(nodeRect, parentRect) {
  return {
    nativeEvent: {
      layout: getRelativeDimensions(nodeRect, parentRect),
      target: nodeRect
    },
    timeStamp: Date.now()
  };
}, getRelativeDimensions = function(a, b2) {
  var {
    height,
    left,
    top,
    width
  } = a, x = left - b2.left, y = top - b2.top;
  return {
    x,
    y,
    width,
    height,
    pageX: a.left,
    pageY: a.top
  };
};
function useElementLayout$1(ref, onLayout) {
  var _ref_current, disableKey = React.useContext(DisableLayoutContextKey), node = ensureWebElement((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.host);
  node && onLayout && (LayoutHandlers.set(node, onLayout), LayoutDisableKey.set(node, disableKey)), useIsomorphicLayoutEffect(function() {
    var _ref_current2;
    if (onLayout) {
      var node2 = (_ref_current2 = ref.current) === null || _ref_current2 === void 0 ? void 0 : _ref_current2.host;
      if (node2) {
        Nodes.add(node2);
        var parentNode = node2.parentNode;
        return parentNode && onLayout(getElementLayoutEvent(node2.getBoundingClientRect(), parentNode.getBoundingClientRect())), function() {
          Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2), LastChangeTime.delete(node2), IntersectionState.delete(node2);
        };
      }
    }
  }, [ref, !!onLayout]);
}
function ensureWebElement(x) {
  if (!(typeof HTMLElement > "u")) return _instanceof(x, HTMLElement) ? x : void 0;
}
var getBoundingClientRectAsync = function(node) {
  return new Promise(function(res) {
    if (!node || node.nodeType !== 1) return res(false);
    var io = new IntersectionObserver(function(entries) {
      return io.disconnect(), res(entries[0].boundingClientRect);
    }, {
      threshold: 0
    });
    io.observe(node);
  });
}, measureNode = function(node, relativeTo) {
  return __async(this, null, function* () {
    var relativeNode = relativeTo || (node == null ? void 0 : node.parentElement);
    if (_instanceof(relativeNode, HTMLElement)) {
      var [nodeDim, relativeNodeDim] = yield Promise.all([getBoundingClientRectAsync(node), getBoundingClientRectAsync(relativeNode)]);
      if (relativeNodeDim && nodeDim) return getRelativeDimensions(nodeDim, relativeNodeDim);
    }
    return null;
  });
}, measure = function(node, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, _instanceof(node.parentNode, HTMLElement) ? node.parentNode : null);
    return out && (callback == null ? void 0 : callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
  });
};
function createMeasure(node) {
  return function(callback) {
    return measure(node, callback);
  };
}
var measureInWindow = function(node, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, null);
    return out && (callback == null ? void 0 : callback(out.pageX, out.pageY, out.width, out.height)), out;
  });
}, createMeasureInWindow = function(node) {
  return function(callback) {
    return measureInWindow(node, callback);
  };
}, measureLayout$1 = function(node, relativeNode, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, relativeNode);
    return out && (callback == null ? void 0 : callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
  });
};
function createMeasureLayout(node) {
  return function(relativeTo, callback) {
    return measureLayout$1(node, relativeTo, callback);
  };
}
const UNINITIALIZED = typeof Symbol == "function" && typeof Symbol() == "symbol" ? Symbol() : Object.freeze({});
function useStable(getInitialValue) {
  const ref = React__namespace.useRef(UNINITIALIZED);
  return ref.current === UNINITIALIZED && (ref.current = getInitialValue()), ref.current;
}
function usePlatformMethods({
  pointerEvents,
  style
}) {
  return useStable(() => (hostNode) => {
    hostNode != null && (hostNode.measure = createMeasure(hostNode), hostNode.measureLayout = createMeasureLayout(hostNode), hostNode.measureInWindow = createMeasureInWindow(hostNode));
  });
}
const TextAncestorContext = React.createContext(false);
function _class_call_check$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$2(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties$2(Constructor.prototype, protoProps), Constructor;
}
function _define_property$2(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var DELAY = "DELAY", ERROR = "ERROR", LONG_PRESS_DETECTED = "LONG_PRESS_DETECTED", NOT_RESPONDER = "NOT_RESPONDER", RESPONDER_ACTIVE_LONG_PRESS_START = "RESPONDER_ACTIVE_LONG_PRESS_START", RESPONDER_ACTIVE_PRESS_START = "RESPONDER_ACTIVE_PRESS_START", RESPONDER_INACTIVE_PRESS_START = "RESPONDER_INACTIVE_PRESS_START", RESPONDER_GRANT = "RESPONDER_GRANT", RESPONDER_RELEASE = "RESPONDER_RELEASE", RESPONDER_TERMINATED = "RESPONDER_TERMINATED", Transitions = Object.freeze({
  NOT_RESPONDER: {
    DELAY: ERROR,
    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
    RESPONDER_RELEASE: ERROR,
    RESPONDER_TERMINATED: ERROR,
    LONG_PRESS_DETECTED: ERROR
  },
  RESPONDER_INACTIVE_PRESS_START: {
    DELAY: RESPONDER_ACTIVE_PRESS_START,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: ERROR
  },
  RESPONDER_ACTIVE_PRESS_START: {
    DELAY: ERROR,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
  },
  RESPONDER_ACTIVE_LONG_PRESS_START: {
    DELAY: ERROR,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
  },
  ERROR: {
    DELAY: NOT_RESPONDER,
    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: NOT_RESPONDER
  }
}), isActiveSignal = function(signal) {
  return signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
}, isButtonRole = function(element) {
  return element.getAttribute("role") === "button";
}, isPressStartSignal = function(signal) {
  return signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
}, isTerminalSignal = function(signal) {
  return signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;
}, isValidKeyPress = function(event) {
  var key = event.key, target = event.target, role = target.getAttribute("role"), isSpacebar = key === " " || key === "Spacebar";
  return key === "Enter" || isSpacebar && role === "button";
}, DEFAULT_LONG_PRESS_DELAY_MS = 450, DEFAULT_PRESS_DELAY_MS = 50, PressResponder = /* @__PURE__ */ (function() {
  function PressResponder2(config) {
    _class_call_check$2(this, PressResponder2), _define_property$2(this, "_touchActivatePosition", null), _define_property$2(this, "_pressDelayTimeout", 0), _define_property$2(this, "_selectionTerminated", false), _define_property$2(this, "_isPointerTouch", false), _define_property$2(this, "_longPressDelayTimeout", 0), _define_property$2(this, "_longPressDispatched", false), _define_property$2(this, "_pressOutDelayTimeout", 0), _define_property$2(this, "_touchState", NOT_RESPONDER), _define_property$2(this, "_config", null), _define_property$2(this, "_eventHandlers", null), this.configure(config);
  }
  return _create_class$2(PressResponder2, [{
    key: "configure",
    value: function(config) {
      this._config = config;
    }
  }, {
    /**
    * Resets any pending timers. This should be called on unmount.
    */
    key: "reset",
    value: function() {
      this._cancelLongPressDelayTimeout(), this._cancelPressDelayTimeout(), this._cancelPressOutDelayTimeout();
    }
  }, {
    /**
    * Returns a set of props to spread into the interactive element.
    */
    key: "getEventHandlers",
    value: function() {
      return this._eventHandlers == null && (this._eventHandlers = this._createEventHandlers()), this._eventHandlers;
    }
  }, {
    key: "_createEventHandlers",
    value: function() {
      var _this = this, start = function(event, shouldDelay) {
        event.persist(), _this._cancelPressOutDelayTimeout(), _this._longPressDispatched = false, _this._selectionTerminated = false, _this._touchState = NOT_RESPONDER, _this._isPointerTouch = event.nativeEvent.type === "touchstart", _this._receiveSignal(RESPONDER_GRANT, event);
        var delayPressStart = normalizeDelay(_this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);
        shouldDelay !== false && delayPressStart > 0 ? _this._pressDelayTimeout = setTimeout(function() {
          _this._receiveSignal(DELAY, event);
        }, delayPressStart) : _this._receiveSignal(DELAY, event);
        var delayLongPress = normalizeDelay(_this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);
        _this._longPressDelayTimeout = setTimeout(function() {
          _this._handleLongPress(event);
        }, delayLongPress + delayPressStart);
      }, end = function(event) {
        _this._receiveSignal(RESPONDER_RELEASE, event);
      }, keyupHandler = function(event) {
        var onPress = _this._config.onPress, target = event.target;
        if (_this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {
          end(event), document.removeEventListener("keyup", keyupHandler);
          var role = target.getAttribute("role"), elementType = target.tagName.toLowerCase(), isNativeInteractiveElement = role === "link" || elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea";
          onPress != null && !isNativeInteractiveElement && onPress(event);
        }
      };
      return {
        onStartShouldSetResponder: function(event) {
          var disabled = _this._config.disabled;
          return disabled && isButtonRole(event.currentTarget) && event.stopPropagation(), disabled == null ? true : !disabled;
        },
        onKeyDown: function(event) {
          var disabled = _this._config.disabled, key = event.key, target = event.target;
          if (!disabled && isValidKeyPress(event)) {
            _this._touchState === NOT_RESPONDER && (start(event, false), document.addEventListener("keyup", keyupHandler));
            var role = target.getAttribute("role"), isSpacebarKey = key === " " || key === "Spacebar", _isButtonRole = role === "button" || role === "menuitem";
            isSpacebarKey && _isButtonRole && event.preventDefault(), event.stopPropagation();
          }
        },
        onResponderGrant: function(event) {
          return start(event);
        },
        onResponderMove: function(event) {
          _this._config.onPressMove != null && _this._config.onPressMove(event);
          var touch = getTouchFromResponderEvent(event);
          if (_this._touchActivatePosition != null) {
            var deltaX = _this._touchActivatePosition.pageX - touch.pageX, deltaY = _this._touchActivatePosition.pageY - touch.pageY;
            Math.hypot(deltaX, deltaY) > 10 && _this._cancelLongPressDelayTimeout();
          }
        },
        onResponderRelease: function(event) {
          return end(event);
        },
        onResponderTerminate: function(event) {
          event.nativeEvent.type === "selectionchange" && (_this._selectionTerminated = true), _this._receiveSignal(RESPONDER_TERMINATED, event);
        },
        onResponderTerminationRequest: function(event) {
          var _this$_config = _this._config, cancelable = _this$_config.cancelable, disabled = _this$_config.disabled, onLongPress = _this$_config.onLongPress;
          return !disabled && onLongPress != null && _this._isPointerTouch && event.nativeEvent.type === "contextmenu" ? false : cancelable != null ? cancelable : true;
        },
        // NOTE: this diverges from react-native in 3 significant ways:
        // * The `onPress` callback is not connected to the responder system (the native
        //  `click` event must be used but is dispatched in many scenarios where no pointers
        //   are on the screen.) Therefore, it's possible for `onPress` to be called without
        //   `onPress{Start,End}` being called first.
        // * The `onPress` callback is only be called on the first ancestor of the native
        //   `click` target that is using the PressResponder.
        // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.
        onClick: function(event) {
          var _this$_config2 = _this._config, disabled = _this$_config2.disabled, onPress = _this$_config2.onPress;
          disabled ? isButtonRole(event.currentTarget) && event.stopPropagation() : (event.stopPropagation(), _this._longPressDispatched || _this._selectionTerminated ? event.preventDefault() : onPress != null && event.altKey === false && onPress(event));
        },
        // If `onLongPress` is provided and a touch pointer is being used, prevent the
        // default context menu from opening.
        onContextMenu: function(event) {
          var _this$_config3 = _this._config, disabled = _this$_config3.disabled, onLongPress = _this$_config3.onLongPress;
          disabled ? isButtonRole(event.currentTarget) && event.stopPropagation() : onLongPress != null && _this._isPointerTouch && !event.defaultPrevented && (event.preventDefault(), event.stopPropagation());
        }
      };
    }
  }, {
    /**
    * Receives a state machine signal, performs side effects of the transition
    * and stores the new state. Validates the transition as well.
    */
    key: "_receiveSignal",
    value: function(signal, event) {
      var prevState = this._touchState, nextState = null;
      Transitions[prevState] != null && (nextState = Transitions[prevState][signal]), !(this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) && (nextState == null || nextState === ERROR ? console.error(`PressResponder: Invalid signal ${signal} for state ${prevState} on responder`) : prevState !== nextState && (this._performTransitionSideEffects(prevState, nextState, signal, event), this._touchState = nextState));
    }
  }, {
    /**
    * Performs a transition between touchable states and identify any activations
    * or deactivations (and callback invocations).
    */
    key: "_performTransitionSideEffects",
    value: function(prevState, nextState, signal, event) {
      var _this = this;
      if (isTerminalSignal(signal) && (setTimeout(function() {
        _this._isPointerTouch = false;
      }, 0), this._touchActivatePosition = null, this._cancelLongPressDelayTimeout()), isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {
        var onLongPress = this._config.onLongPress;
        onLongPress != null && event.nativeEvent.key == null && (onLongPress(event), this._longPressDispatched = true);
      }
      var isPrevActive = isActiveSignal(prevState), isNextActive = isActiveSignal(nextState);
      if (!isPrevActive && isNextActive ? this._activate(event) : isPrevActive && !isNextActive && this._deactivate(event), isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {
        var _this$_config4 = this._config, _onLongPress = _this$_config4.onLongPress, onPress = _this$_config4.onPress;
        if (onPress != null) {
          var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;
          isPressCanceledByLongPress || isNextActive || isPrevActive || (this._activate(event), this._deactivate(event));
        }
      }
      this._cancelPressDelayTimeout();
    }
  }, {
    key: "_activate",
    value: function(event) {
      var _this$_config5 = this._config, onPressChange = _this$_config5.onPressChange, onPressStart = _this$_config5.onPressStart, touch = getTouchFromResponderEvent(event);
      this._touchActivatePosition = {
        pageX: touch.pageX,
        pageY: touch.pageY
      }, onPressStart == null ? void 0 : onPressStart(event), onPressChange == null ? void 0 : onPressChange(true);
    }
  }, {
    key: "_deactivate",
    value: function(event) {
      var _this$_config6 = this._config, onPressChange = _this$_config6.onPressChange, onPressEnd = _this$_config6.onPressEnd;
      function end() {
        onPressEnd == null ? void 0 : onPressEnd(event), onPressChange == null ? void 0 : onPressChange(false);
      }
      var delayPressEnd = normalizeDelay(this._config.delayPressEnd);
      delayPressEnd > 0 ? this._pressOutDelayTimeout = setTimeout(function() {
        end();
      }, delayPressEnd) : end();
    }
  }, {
    key: "_handleLongPress",
    value: function(event) {
      (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) && this._receiveSignal(LONG_PRESS_DETECTED, event);
    }
  }, {
    key: "_cancelLongPressDelayTimeout",
    value: function() {
      this._longPressDelayTimeout != null && (clearTimeout(this._longPressDelayTimeout), this._longPressDelayTimeout = null);
    }
  }, {
    key: "_cancelPressDelayTimeout",
    value: function() {
      this._pressDelayTimeout != null && (clearTimeout(this._pressDelayTimeout), this._pressDelayTimeout = null);
    }
  }, {
    key: "_cancelPressOutDelayTimeout",
    value: function() {
      this._pressOutDelayTimeout != null && (clearTimeout(this._pressOutDelayTimeout), this._pressOutDelayTimeout = null);
    }
  }]), PressResponder2;
})();
function normalizeDelay(delay, min, fallback) {
  return min === void 0 && (min = 0), fallback === void 0 && (fallback = 0), Math.max(min, delay != null ? delay : fallback);
}
function getTouchFromResponderEvent(event) {
  var _event$nativeEvent = event.nativeEvent, changedTouches = _event$nativeEvent.changedTouches, touches = _event$nativeEvent.touches;
  return touches != null && touches.length > 0 ? touches[0] : changedTouches != null && changedTouches.length > 0 ? changedTouches[0] : event.nativeEvent;
}
function usePressEvents(_, config) {
  var pressResponderRef = React.useRef(null);
  pressResponderRef.current == null && (pressResponderRef.current = new PressResponder(config));
  var pressResponder = pressResponderRef.current;
  return React.useEffect(function() {
    pressResponder.configure(config);
  }, [config, pressResponder]), React.useEffect(function() {
    return function() {
      pressResponder.reset();
    };
  }, [pressResponder]), React.useDebugValue(config), pressResponder.getEventHandlers();
}
var keyName = "__reactResponderId", canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement), getBoundingClientRect = function(node) {
  if (node && node.nodeType === 1 && node.getBoundingClientRect) return node.getBoundingClientRect();
};
function getEventPath(domEvent) {
  if (domEvent.type === "selectionchange") {
    var _window_getSelection, target = (_window_getSelection = window.getSelection()) === null || _window_getSelection === void 0 ? void 0 : _window_getSelection.anchorNode;
    return composedPathFallback(target);
  }
  var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
  return path;
}
function composedPathFallback(target) {
  for (var path = []; target != null && target !== document.body; ) path.push(target), target = target.parentNode;
  return path;
}
function getResponderId(node) {
  return node != null ? node[keyName] : null;
}
function setResponderId(node, id2) {
  node != null && (node[keyName] = id2);
}
function getResponderPaths(domEvent) {
  for (var idPath = [], nodePath = [], eventPath = getEventPath(domEvent), i = 0; i < eventPath.length; i++) {
    var node = eventPath[i], id2 = getResponderId(node);
    id2 != null && (idPath.push(id2), nodePath.push(node));
  }
  return {
    idPath,
    nodePath
  };
}
function getLowestCommonAncestor(pathA, pathB) {
  var pathALength = pathA.length, pathBLength = pathB.length;
  if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]
  ) return null;
  var itemA = pathA[0], indexA = 0, itemB = pathB[0], indexB = 0;
  pathALength - pathBLength > 0 && (indexA = pathALength - pathBLength, itemA = pathA[indexA], pathALength = pathBLength), pathBLength - pathALength > 0 && (indexB = pathBLength - pathALength, itemB = pathB[indexB], pathBLength = pathALength);
  for (var depth = pathALength; depth--; ) {
    if (itemA === itemB) return itemA;
    itemA = pathA[indexA++], itemB = pathB[indexB++];
  }
  return null;
}
function hasTargetTouches(target, touches) {
  if (!touches || touches.length === 0) return false;
  for (var i = 0; i < touches.length; i++) {
    var node = touches[i].target;
    if (node != null && target.contains(node)) return true;
  }
  return false;
}
function hasValidSelection(domEvent) {
  return domEvent.type === "selectionchange" ? isSelectionValid() : domEvent.type === "select";
}
function isPrimaryPointerDown(domEvent) {
  var {
    altKey,
    button,
    buttons,
    ctrlKey,
    type
  } = domEvent, isTouch = type === "touchstart" || type === "touchmove", isPrimaryMouseDown = type === "mousedown" && (button === 0 || buttons === 1), isPrimaryMouseMove = type === "mousemove" && buttons === 1, noModifiers = altKey === false && ctrlKey === false;
  return !!(isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers);
}
function isSelectionValid() {
  var selection = window.getSelection();
  if (!selection) return false;
  var string = selection.toString(), anchorNode = selection.anchorNode, focusNode = selection.focusNode, isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
  return string.length >= 1 && string !== `
` && !!isTextNode;
}
var emptyFunction = function() {
}, emptyObject$9 = {}, emptyArray = [];
function normalizeIdentifier(identifier) {
  return identifier > 20 ? identifier % 20 : identifier;
}
function createResponderEvent(domEvent, responderTouchHistoryStore2) {
  var rect, propagationWasStopped = false, changedTouches, touches, domEventChangedTouches = domEvent.changedTouches, domEventType = domEvent.type, metaKey = domEvent.metaKey === true, shiftKey = domEvent.shiftKey === true, force = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].force) || 0, identifier = normalizeIdentifier((domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].identifier) || 0), clientX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientX) || domEvent.clientX, clientY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientY) || domEvent.clientY, pageX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageX) || domEvent.pageX, pageY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageY) || domEvent.pageY, preventDefault = typeof domEvent.preventDefault == "function" ? domEvent.preventDefault.bind(domEvent) : emptyFunction, timestamp = domEvent.timeStamp;
  function normalizeTouches(touches2) {
    return Array.prototype.slice.call(touches2).map(function(touch) {
      return {
        force: touch.force,
        identifier: normalizeIdentifier(touch.identifier),
        get locationX() {
          return locationX(touch.clientX);
        },
        get locationY() {
          return locationY(touch.clientY);
        },
        pageX: touch.pageX,
        pageY: touch.pageY,
        target: touch.target,
        timestamp
      };
    });
  }
  if (domEventChangedTouches != null) changedTouches = normalizeTouches(domEventChangedTouches), touches = normalizeTouches(domEvent.touches);
  else {
    var emulatedTouches = [{
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp
    }];
    changedTouches = emulatedTouches, touches = domEventType === "mouseup" || domEventType === "dragstart" ? emptyArray : emulatedTouches;
  }
  var responderEvent = {
    bubbles: true,
    cancelable: true,
    // `currentTarget` is set before dispatch
    currentTarget: null,
    defaultPrevented: domEvent.defaultPrevented,
    dispatchConfig: emptyObject$9,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented() {
      return domEvent.defaultPrevented;
    },
    isPropagationStopped() {
      return propagationWasStopped;
    },
    isTrusted: domEvent.isTrusted,
    nativeEvent: {
      altKey: false,
      ctrlKey: false,
      metaKey,
      shiftKey,
      changedTouches,
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp,
      touches,
      type: domEventType
    },
    persist: emptyFunction,
    preventDefault,
    stopPropagation() {
      propagationWasStopped = true;
    },
    target: domEvent.target,
    timeStamp: timestamp,
    touchHistory: responderTouchHistoryStore2.touchHistory
  };
  function locationX(x) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return x - rect.left;
  }
  function locationY(y) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return y - rect.top;
  }
  return responderEvent;
}
var MOUSE_DOWN = "mousedown", MOUSE_MOVE = "mousemove", MOUSE_UP = "mouseup", MOUSE_CANCEL = "dragstart", TOUCH_START = "touchstart", TOUCH_MOVE = "touchmove", TOUCH_END = "touchend", TOUCH_CANCEL = "touchcancel", SCROLL = "scroll", SELECT = "select", SELECTION_CHANGE = "selectionchange";
function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}
function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}
function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}
function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}
function isScroll(eventType) {
  return eventType === SCROLL;
}
function isSelectionChange(eventType) {
  return eventType === SELECT || eventType === SELECTION_CHANGE;
}
function _class_call_check$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$1(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties$1(Constructor.prototype, protoProps), Constructor;
}
function _define_property$1(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var ResponderTouchHistoryStore = /* @__PURE__ */ (function() {
  function ResponderTouchHistoryStore2() {
    _class_call_check$1(this, ResponderTouchHistoryStore2), _define_property$1(this, "_touchHistory", {
      touchBank: [],
      //Array<TouchRecord>
      numberActiveTouches: 0,
      // If there is only one active touch, we remember its location. This prevents
      // us having to loop through all of the touches all the time in the most
      // common case.
      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    });
  }
  return _create_class$1(ResponderTouchHistoryStore2, [{
    key: "recordTouchTrack",
    value: function(topLevelType, nativeEvent) {
      var touchHistory = this._touchHistory;
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchMove(touch, touchHistory);
      });
      else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchStart(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1 && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);
      else if (isEndish(topLevelType) && (nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchEnd(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1)) {
        for (var {
          touchBank
        } = touchHistory, i = 0; i < touchBank.length; i++) {
          var touchTrackToCheck = touchBank[i];
          if (touchTrackToCheck == null ? void 0 : touchTrackToCheck.touchActive) {
            touchHistory.indexOfSingleActiveTouch = i;
            break;
          }
        }
      }
    }
  }, {
    key: "touchHistory",
    get: function() {
      return this._touchHistory;
    }
  }]), ResponderTouchHistoryStore2;
})(), MAX_TOUCH_BANK = 20;
function timestampForTouch(touch) {
  return touch.timeStamp || touch.timestamp;
}
function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}
function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch);
}
function getTouchIdentifier(param) {
  var {
    identifier
  } = param;
  return identifier == null && console.error("Touch object is missing identifier."), identifier;
}
function recordTouchStart(touch, touchHistory) {
  var identifier = getTouchIdentifier(touch), touchRecord = touchHistory.touchBank[identifier];
  touchRecord ? resetTouchRecord(touchRecord, touch) : touchHistory.touchBank[identifier] = createTouchRecord(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}
function recordTouchMove(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch move without a touch start.
`, `Touch Move: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function recordTouchEnd(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch end without a touch start.
`, `Touch End: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}
function printTouchBank(touchHistory) {
  var {
    touchBank
  } = touchHistory, printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
  return touchBank.length > MAX_TOUCH_BANK && (printed += ` (original size: ${touchBank.length})`), printed;
}
var emptyObject$8 = {}, startRegistration = ["onStartShouldSetResponderCapture", "onStartShouldSetResponder", {
  bubbles: true
}], moveRegistration = ["onMoveShouldSetResponderCapture", "onMoveShouldSetResponder", {
  bubbles: true
}], scrollRegistration = ["onScrollShouldSetResponderCapture", "onScrollShouldSetResponder", {
  bubbles: false
}], shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
}, emptyResponder = {
  id: null,
  idPath: null,
  node: null
}, responderListenersMap = /* @__PURE__ */ new Map(), isEmulatingMouseEvents = false, trackedTouchCount = 0, currentResponder = {
  id: null,
  node: null,
  idPath: null
}, responderTouchHistoryStore = new ResponderTouchHistoryStore();
function changeCurrentResponder(responder) {
  currentResponder = responder;
}
function getResponderConfig(id2) {
  var config = responderListenersMap.get(id2);
  return config != null ? config : emptyObject$8;
}
function eventListener(domEvent) {
  var eventType = domEvent.type, eventTarget = domEvent.target;
  if (eventType === "touchstart" && (isEmulatingMouseEvents = true), (eventType === "touchmove" || trackedTouchCount > 1) && (isEmulatingMouseEvents = false), // Ignore browser emulated mouse events
  !(eventType === "mousedown" && isEmulatingMouseEvents || eventType === "mousemove" && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
  eventType === "mousemove" && trackedTouchCount < 1)) {
    if (isEmulatingMouseEvents && eventType === "mouseup") {
      trackedTouchCount === 0 && (isEmulatingMouseEvents = false);
      return;
    }
    var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent), isMoveEvent = isMoveish(eventType), isEndEvent = isEndish(eventType), isScrollEvent = isScroll(eventType), isSelectionChangeEvent = isSelectionChange(eventType), responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);
    (isStartEvent || isMoveEvent || isEndEvent) && (domEvent.touches ? trackedTouchCount = domEvent.touches.length : isStartEvent ? trackedTouchCount = 1 : isEndEvent && (trackedTouchCount = 0), responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent));
    var eventPaths = getResponderPaths(domEvent), wasNegotiated = false, wantsResponder;
    if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
      var currentResponderIdPath = currentResponder.idPath, eventIdPath = eventPaths.idPath;
      if (currentResponderIdPath != null && eventIdPath != null) {
        var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);
        if (lowestCommonAncestor != null) {
          var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor), index2 = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
          eventPaths = {
            idPath: eventIdPath.slice(index2),
            nodePath: eventPaths.nodePath.slice(index2)
          };
        } else eventPaths = null;
      }
      eventPaths != null && (wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent), wantsResponder != null && (attemptTransfer(responderEvent, wantsResponder), wasNegotiated = true));
    }
    if (currentResponder.id != null && currentResponder.node != null) {
      var {
        id: id2,
        node
      } = currentResponder, {
        onResponderStart,
        onResponderMove,
        onResponderEnd,
        onResponderRelease,
        onResponderTerminate,
        onResponderTerminationRequest
      } = getResponderConfig(id2);
      if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node, isStartEvent) onResponderStart != null && (responderEvent.dispatchConfig.registrationName = "onResponderStart", onResponderStart(responderEvent));
      else if (isMoveEvent) onResponderMove != null && (responderEvent.dispatchConfig.registrationName = "onResponderMove", onResponderMove(responderEvent));
      else {
        var isTerminateEvent = isCancelish(eventType) || // native context menu
        eventType === "contextmenu" || // window blur
        eventType === "blur" && eventTarget === window || // responder (or ancestors) blur
        eventType === "blur" && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer
        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node
        isSelectionChangeEvent && hasValidSelection(domEvent), isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);
        if (isEndEvent && onResponderEnd != null && (responderEvent.dispatchConfig.registrationName = "onResponderEnd", onResponderEnd(responderEvent)), isReleaseEvent && (onResponderRelease != null && (responderEvent.dispatchConfig.registrationName = "onResponderRelease", onResponderRelease(responderEvent)), changeCurrentResponder(emptyResponder)), isTerminateEvent) {
          var shouldTerminate = true;
          (eventType === "contextmenu" || eventType === "scroll" || eventType === "selectionchange") && (wasNegotiated ? shouldTerminate = false : onResponderTerminationRequest != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (shouldTerminate = false))), shouldTerminate && (onResponderTerminate != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), changeCurrentResponder(emptyResponder), isEmulatingMouseEvents = false, trackedTouchCount = 0);
        }
      }
    }
  }
}
function findWantsResponder(eventPaths, domEvent, responderEvent) {
  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];
  if (shouldSetCallbacks != null) {
    for (var {
      idPath,
      nodePath
    } = eventPaths, shouldSetCallbackCaptureName = shouldSetCallbacks[0], shouldSetCallbackBubbleName = shouldSetCallbacks[1], {
      bubbles
    } = shouldSetCallbacks[2], check = function(id3, node3, callbackName) {
      var config = getResponderConfig(id3), shouldSetCallback = config[callbackName];
      if (shouldSetCallback != null && (responderEvent.currentTarget = node3, shouldSetCallback(responderEvent) === true)) {
        var prunedIdPath = idPath.slice(idPath.indexOf(id3));
        return {
          id: id3,
          node: node3,
          idPath: prunedIdPath
        };
      }
    }, i = idPath.length - 1; i >= 0; i--) {
      var id2 = idPath[i], node = nodePath[i], result = check(id2, node, shouldSetCallbackCaptureName);
      if (result != null) return result;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    if (bubbles) for (var i1 = 0; i1 < idPath.length; i1++) {
      var id1 = idPath[i1], node1 = nodePath[i1], result1 = check(id1, node1, shouldSetCallbackBubbleName);
      if (result1 != null) return result1;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    else {
      var id22 = idPath[0], node2 = nodePath[0], target = domEvent.target;
      if (target === node2) return check(id22, node2, shouldSetCallbackBubbleName);
    }
  }
}
function attemptTransfer(responderEvent, wantsResponder) {
  var {
    id: currentId,
    node: currentNode
  } = currentResponder, {
    id: id2,
    node
  } = wantsResponder, {
    onResponderGrant,
    onResponderReject
  } = getResponderConfig(id2);
  if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node, currentId == null) onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder);
  else {
    var {
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(currentId), allowTransfer = true;
    onResponderTerminationRequest != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (allowTransfer = false)), allowTransfer ? (onResponderTerminate != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder)) : onResponderReject != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderReject", onResponderReject(responderEvent));
  }
}
var documentEventsCapturePhase = ["blur", "scroll"], documentEventsBubblePhase = [
  // mouse
  "mousedown",
  "mousemove",
  "mouseup",
  "dragstart",
  // touch
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  // other
  "contextmenu",
  "select",
  "selectionchange"
], isTamaguiResponderActive = Symbol();
function attachListeners() {
  canUseDOM && !window[isTamaguiResponderActive] && (window.addEventListener("blur", eventListener), documentEventsBubblePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener);
  }), documentEventsCapturePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener, true);
  }), window[isTamaguiResponderActive] = true);
}
function addNode(id2, node, config) {
  setResponderId(node, id2), responderListenersMap.set(id2, config);
}
function removeNode(id2) {
  currentResponder.id === id2 && terminateResponder(), responderListenersMap.has(id2) && responderListenersMap.delete(id2);
}
function terminateResponder() {
  var {
    id: id2,
    node
  } = currentResponder;
  if (id2 != null && node != null) {
    var {
      onResponderTerminate
    } = getResponderConfig(id2);
    if (onResponderTerminate != null) {
      var event = createResponderEvent({}, responderTouchHistoryStore);
      event.currentTarget = node, onResponderTerminate(event);
    }
    changeCurrentResponder(emptyResponder);
  }
  isEmulatingMouseEvents = false, trackedTouchCount = 0;
}
var emptyObject$7 = {}, Attached = /* @__PURE__ */ new WeakMap(), Ids = /* @__PURE__ */ new WeakMap();
function useResponderEvents(hostRef) {
  var configIn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emptyObject$7, _hostRef_current, config = getResponderConfigIfDefined(configIn), node = (hostRef == null || (_hostRef_current = hostRef.current) === null || _hostRef_current === void 0 ? void 0 : _hostRef_current.host) || (hostRef == null ? void 0 : hostRef.current);
  React__namespace.useEffect(function() {
    if (config !== emptyObject$7) {
      attachListeners(), Ids.has(hostRef) || Ids.set(hostRef, `${Math.random()}`);
      var id2 = Ids.get(hostRef);
      return addNode(id2, node, config), Attached.set(hostRef, true), function() {
        removeNode(node), Attached.set(hostRef, false);
      };
    }
  }, [config, hostRef]);
}
function getResponderConfigIfDefined(param) {
  var {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } = param;
  return onMoveShouldSetResponder || onMoveShouldSetResponderCapture || onResponderEnd || onResponderGrant || onResponderMove || onResponderReject || onResponderRelease || onResponderStart || onResponderTerminate || onResponderTerminationRequest || onScrollShouldSetResponder || onScrollShouldSetResponderCapture || onSelectionChangeShouldSetResponder || onSelectionChangeShouldSetResponderCapture || onStartShouldSetResponder || onStartShouldSetResponderCapture ? {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } : emptyObject$7;
}
const isDisabled$1 = (props) => props.disabled || Array.isArray(props.accessibilityStates) && props.accessibilityStates.indexOf("disabled") > -1;
const accessibilityRoleToWebRole = {
  adjustable: "slider",
  button: "button",
  header: "heading",
  image: "img",
  imagebutton: null,
  keyboardkey: null,
  label: null,
  link: "link",
  none: "presentation",
  search: "search",
  summary: "region",
  text: null
}, propsToAriaRole = ({
  accessibilityRole
}) => {
  if (accessibilityRole) {
    const inferredRole = accessibilityRoleToWebRole[accessibilityRole];
    if (inferredRole !== null) return inferredRole || accessibilityRole;
  }
};
const roleComponents = {
  article: "article",
  banner: "header",
  blockquote: "blockquote",
  code: "code",
  complementary: "aside",
  contentinfo: "footer",
  deletion: "del",
  emphasis: "em",
  figure: "figure",
  insertion: "ins",
  form: "form",
  list: "ul",
  listitem: "li",
  main: "main",
  navigation: "nav",
  region: "section",
  strong: "strong"
}, emptyObject$6 = {}, propsToAccessibilityComponent = (props = emptyObject$6) => {
  if (props.accessibilityRole === "label") return "label";
  const role = propsToAriaRole(props);
  if (role) {
    if (role === "heading") {
      const level = props.accessibilityLevel || props["aria-level"];
      return level != null ? `h${level}` : "h1";
    }
    return roleComponents[role];
  }
};
const AccessibilityUtil = {
  isDisabled: isDisabled$1,
  propsToAccessibilityComponent,
  propsToAriaRole
};
const emptyObject$5 = {}, hasOwnProperty = Object.prototype.hasOwnProperty, isArray = Array.isArray, uppercasePattern = /[A-Z]/g;
function toHyphenLower(match) {
  return "-" + match.toLowerCase();
}
function hyphenateString(str) {
  return str.replace(uppercasePattern, toHyphenLower);
}
function processIDRefList(idRefList) {
  return isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
function flattenStyle$1(style) {
  if (style === null || typeof style != "object") return;
  if (!isArray(style)) return style;
  const result = {};
  for (let i = 0, styleLength = style.length; i < styleLength; ++i) {
    const computedStyle = flattenStyle$1(style[i]);
    if (computedStyle) for (const key in computedStyle) hasOwnProperty.call(computedStyle, key) && (result[key] = computedStyle[key]);
  }
  return result;
}
const stylesFromProps = /* @__PURE__ */ new WeakMap(), createDOMProps = (elementType, props, options) => {
  props || (props = emptyObject$5);
  const _a = props, {
    accessibilityActiveDescendant,
    accessibilityAtomic,
    accessibilityAutoComplete,
    accessibilityBusy,
    accessibilityChecked,
    accessibilityColumnCount,
    accessibilityColumnIndex,
    accessibilityColumnSpan,
    accessibilityControls,
    accessibilityCurrent,
    accessibilityDescribedBy,
    accessibilityDetails,
    accessibilityDisabled,
    accessibilityErrorMessage,
    accessibilityExpanded,
    accessibilityFlowTo,
    accessibilityHasPopup,
    accessibilityHidden,
    accessibilityInvalid,
    accessibilityKeyShortcuts,
    accessibilityLabel,
    accessibilityLabelledBy,
    accessibilityLevel,
    accessibilityLiveRegion,
    accessibilityModal,
    accessibilityMultiline,
    accessibilityMultiSelectable,
    accessibilityOrientation,
    accessibilityOwns,
    accessibilityPlaceholder,
    accessibilityPosInSet,
    accessibilityPressed,
    accessibilityReadOnly,
    accessibilityRequired,
    accessibilityRole: accessibilityRole,
    accessibilityRoleDescription: accessibilityRoleDescription,
    accessibilityRowCount,
    accessibilityRowIndex,
    accessibilityRowSpan,
    accessibilitySelected,
    accessibilitySetSize,
    accessibilitySort,
    accessibilityValueMax,
    accessibilityValueMin,
    accessibilityValueNow,
    accessibilityValueText,
    dataSet,
    focusable,
    nativeID,
    pointerEvents,
    style,
    testID,
    id: id2
  } = _a, domProps = __objRest(_a, [
    "accessibilityActiveDescendant",
    "accessibilityAtomic",
    "accessibilityAutoComplete",
    "accessibilityBusy",
    "accessibilityChecked",
    "accessibilityColumnCount",
    "accessibilityColumnIndex",
    "accessibilityColumnSpan",
    "accessibilityControls",
    "accessibilityCurrent",
    "accessibilityDescribedBy",
    "accessibilityDetails",
    "accessibilityDisabled",
    "accessibilityErrorMessage",
    "accessibilityExpanded",
    "accessibilityFlowTo",
    "accessibilityHasPopup",
    "accessibilityHidden",
    "accessibilityInvalid",
    "accessibilityKeyShortcuts",
    "accessibilityLabel",
    "accessibilityLabelledBy",
    "accessibilityLevel",
    "accessibilityLiveRegion",
    "accessibilityModal",
    "accessibilityMultiline",
    "accessibilityMultiSelectable",
    "accessibilityOrientation",
    "accessibilityOwns",
    "accessibilityPlaceholder",
    "accessibilityPosInSet",
    "accessibilityPressed",
    "accessibilityReadOnly",
    "accessibilityRequired",
    /* eslint-disable */
    "accessibilityRole",
    /* eslint-enable */
    "accessibilityRoleDescription",
    "accessibilityRowCount",
    "accessibilityRowIndex",
    "accessibilityRowSpan",
    "accessibilitySelected",
    "accessibilitySetSize",
    "accessibilitySort",
    "accessibilityValueMax",
    "accessibilityValueMin",
    "accessibilityValueNow",
    "accessibilityValueText",
    "dataSet",
    "focusable",
    "nativeID",
    "pointerEvents",
    "style",
    "testID",
    "id"
  ]), disabled = accessibilityDisabled, role = AccessibilityUtil.propsToAriaRole(props);
  accessibilityActiveDescendant != null && (domProps["aria-activedescendant"] = accessibilityActiveDescendant), accessibilityAtomic != null && (domProps["aria-atomic"] = accessibilityAtomic), accessibilityAutoComplete != null && (domProps["aria-autocomplete"] = accessibilityAutoComplete), accessibilityBusy != null && (domProps["aria-busy"] = accessibilityBusy), accessibilityChecked != null && (domProps["aria-checked"] = accessibilityChecked), accessibilityColumnCount != null && (domProps["aria-colcount"] = accessibilityColumnCount), accessibilityColumnIndex != null && (domProps["aria-colindex"] = accessibilityColumnIndex), accessibilityColumnSpan != null && (domProps["aria-colspan"] = accessibilityColumnSpan), accessibilityControls != null && (domProps["aria-controls"] = processIDRefList(accessibilityControls)), accessibilityCurrent != null && (domProps["aria-current"] = accessibilityCurrent), accessibilityDescribedBy != null && (domProps["aria-describedby"] = processIDRefList(accessibilityDescribedBy)), accessibilityDetails != null && (domProps["aria-details"] = accessibilityDetails), disabled === true && (domProps["aria-disabled"] = true, (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.disabled = true)), accessibilityErrorMessage != null && (domProps["aria-errormessage"] = accessibilityErrorMessage), accessibilityExpanded != null && (domProps["aria-expanded"] = accessibilityExpanded), accessibilityFlowTo != null && (domProps["aria-flowto"] = processIDRefList(accessibilityFlowTo)), accessibilityHasPopup != null && (domProps["aria-haspopup"] = accessibilityHasPopup), accessibilityHidden === true && (domProps["aria-hidden"] = accessibilityHidden), accessibilityInvalid != null && (domProps["aria-invalid"] = accessibilityInvalid), accessibilityKeyShortcuts != null && Array.isArray(accessibilityKeyShortcuts) && (domProps["aria-keyshortcuts"] = accessibilityKeyShortcuts.join(" ")), accessibilityLabel != null && (domProps["aria-label"] = accessibilityLabel), accessibilityLabelledBy != null && (domProps["aria-labelledby"] = processIDRefList(accessibilityLabelledBy)), accessibilityLevel != null && (domProps["aria-level"] = accessibilityLevel), accessibilityLiveRegion != null && (domProps["aria-live"] = accessibilityLiveRegion === "none" ? "off" : accessibilityLiveRegion), accessibilityModal != null && (domProps["aria-modal"] = accessibilityModal), accessibilityMultiline != null && (domProps["aria-multiline"] = accessibilityMultiline), accessibilityMultiSelectable != null && (domProps["aria-multiselectable"] = accessibilityMultiSelectable), accessibilityOrientation != null && (domProps["aria-orientation"] = accessibilityOrientation), accessibilityOwns != null && (domProps["aria-owns"] = processIDRefList(accessibilityOwns)), accessibilityPlaceholder != null && (domProps["aria-placeholder"] = accessibilityPlaceholder), accessibilityPosInSet != null && (domProps["aria-posinset"] = accessibilityPosInSet), accessibilityPressed != null && (domProps["aria-pressed"] = accessibilityPressed), accessibilityReadOnly != null && (domProps["aria-readonly"] = accessibilityReadOnly, (elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.readOnly = true)), accessibilityRequired != null && (domProps["aria-required"] = accessibilityRequired, (elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.required = true)), role != null && (domProps.role = role === "none" ? "presentation" : role), accessibilityRoleDescription != null && (domProps["aria-roledescription"] = accessibilityRoleDescription), accessibilityRowCount != null && (domProps["aria-rowcount"] = accessibilityRowCount), accessibilityRowIndex != null && (domProps["aria-rowindex"] = accessibilityRowIndex), accessibilityRowSpan != null && (domProps["aria-rowspan"] = accessibilityRowSpan), accessibilitySelected != null && (domProps["aria-selected"] = accessibilitySelected), accessibilitySetSize != null && (domProps["aria-setsize"] = accessibilitySetSize), accessibilitySort != null && (domProps["aria-sort"] = accessibilitySort), accessibilityValueMax != null && (domProps["aria-valuemax"] = accessibilityValueMax), accessibilityValueMin != null && (domProps["aria-valuemin"] = accessibilityValueMin), accessibilityValueNow != null && (domProps["aria-valuenow"] = accessibilityValueNow), accessibilityValueText != null && (domProps["aria-valuetext"] = accessibilityValueText);
  const tmgCN = dataSet ? dataSet.className : void 0, tmgID = dataSet ? dataSet.id : void 0;
  if (dataSet != null) {
    for (const dataProp in dataSet) if (!(dataProp === "className" || dataProp === "id") && hasOwnProperty.call(dataSet, dataProp)) {
      const dataName = hyphenateString(dataProp), dataValue = dataSet[dataProp];
      dataValue != null && (domProps[`data-${dataName}`] = dataValue);
    }
  }
  focusable === false && (domProps.tabIndex = "-1"), // These native elements are keyboard focusable by default
  elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea" ? (focusable === false || accessibilityDisabled === true) && (domProps.tabIndex = "-1") : (
    /* These roles are made keyboard focusable by default */
    role === "button" || role === "checkbox" || role === "link" || role === "radio" || role === "textbox" || role === "switch" ? focusable !== false && (domProps.tabIndex = "0") : focusable === true && (domProps.tabIndex = "0")
  );
  flattenStyle$1(style);
  let className = tmgCN || "";
  props.className && (className += ` ${props.className}`);
  const stylesAtomic = getCSSStylesAtomic();
  stylesFromProps.set(domProps, stylesAtomic), domProps.style = stylesAtomic.reduce((acc, [key, value]) => key[0] === "_" || key.startsWith("is_") || key.startsWith("font_") ? (className += ` ${key}`, acc) : (key === "$$css" || key === "" || (acc[key] = value), acc), {}), className && (domProps.className = className);
  const _id = tmgID || id2 || nativeID;
  return _id && (domProps.id = _id), testID != null && (domProps["data-testid"] = testID), domProps;
};
const isWebColor$1 = (color) => color === "currentcolor" || color === "currentColor" || color === "inherit" || color.startsWith("var(");
var normalizeColor_1;
var hasRequiredNormalizeColor;
function requireNormalizeColor() {
  if (hasRequiredNormalizeColor) return normalizeColor_1;
  hasRequiredNormalizeColor = 1;
  function normalizeColor2(color) {
    if (typeof color === "number") {
      if (color >>> 0 === color && color >= 0 && color <= 4294967295) {
        return color;
      }
      return null;
    }
    if (typeof color !== "string") {
      return null;
    }
    const matchers = getMatchers();
    let match;
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + "ff", 16) >>> 0;
    }
    const colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | // r
      parse255(match[2]) << 16 | // g
      parse255(match[3]) << 8 | // b
      255) >>> // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      if (match[6] !== void 0) {
        return (parse255(match[6]) << 24 | // r
        parse255(match[7]) << 16 | // g
        parse255(match[8]) << 8 | // b
        parse1(match[9])) >>> // a
        0;
      }
      return (parse255(match[2]) << 24 | // r
      parse255(match[3]) << 16 | // g
      parse255(match[4]) << 8 | // b
      parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        "ff",
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        match[4] + match[4],
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // s
        parsePercentage(match[3])
        // l
      ) | 255) >>> // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      if (match[6] !== void 0) {
        return (hslToRgb(
          parse360(match[6]),
          // h
          parsePercentage(match[7]),
          // s
          parsePercentage(match[8])
          // l
        ) | parse1(match[9])) >>> // a
        0;
      }
      return (hslToRgb(
        parse360(match[2]),
        // h
        parsePercentage(match[3]),
        // s
        parsePercentage(match[4])
        // l
      ) | parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // w
        parsePercentage(match[3])
        // b
      ) | 255) >>> // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p + (q - p) * 6 * t2;
    }
    if (t2 < 1 / 2) {
      return q;
    }
    if (t2 < 2 / 3) {
      return p + (q - p) * (2 / 3 - t2) * 6;
    }
    return p;
  }
  function hslToRgb(h2, s2, l) {
    const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h2 + 1 / 3);
    const g = hue2rgb(p, q, h2);
    const b2 = hue2rgb(p, q, h2 - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function hwbToRgb(h2, w2, b2) {
    if (w2 + b2 >= 1) {
      const gray = Math.round(w2 * 255 / (w2 + b2));
      return gray << 24 | gray << 16 | gray << 8;
    }
    const red = hue2rgb(0, 1, h2 + 1 / 3) * (1 - w2 - b2) + w2;
    const green = hue2rgb(0, 1, h2) * (1 - w2 - b2) + w2;
    const blue = hue2rgb(0, 1, h2 - 1 / 3) * (1 - w2 - b2) + w2;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call(...args) {
    return "\\(\\s*(" + args.join(")\\s*,?\\s*(") + ")\\s*\\)";
  }
  function callWithSlashSeparator(...args) {
    return "\\(\\s*(" + args.slice(0, args.length - 1).join(")\\s*,?\\s*(") + ")\\s*/\\s*(" + args[args.length - 1] + ")\\s*\\)";
  }
  function commaSeparatedCall(...args) {
    return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  let cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === void 0) {
      cachedMatchers = {
        rgb: new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp(
          "rgba(" + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + "|" + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ")"
        ),
        hsl: new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp(
          "hsla(" + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + "|" + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ")"
        ),
        hwb: new RegExp("hwb" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    switch (name) {
      case "transparent":
        return 0;
      // http://www.w3.org/TR/css3-color/#svg-color
      case "aliceblue":
        return 4042850303;
      case "antiquewhite":
        return 4209760255;
      case "aqua":
        return 16777215;
      case "aquamarine":
        return 2147472639;
      case "azure":
        return 4043309055;
      case "beige":
        return 4126530815;
      case "bisque":
        return 4293182719;
      case "black":
        return 255;
      case "blanchedalmond":
        return 4293643775;
      case "blue":
        return 65535;
      case "blueviolet":
        return 2318131967;
      case "brown":
        return 2771004159;
      case "burlywood":
        return 3736635391;
      case "burntsienna":
        return 3934150143;
      case "cadetblue":
        return 1604231423;
      case "chartreuse":
        return 2147418367;
      case "chocolate":
        return 3530104575;
      case "coral":
        return 4286533887;
      case "cornflowerblue":
        return 1687547391;
      case "cornsilk":
        return 4294499583;
      case "crimson":
        return 3692313855;
      case "cyan":
        return 16777215;
      case "darkblue":
        return 35839;
      case "darkcyan":
        return 9145343;
      case "darkgoldenrod":
        return 3095792639;
      case "darkgray":
        return 2846468607;
      case "darkgreen":
        return 6553855;
      case "darkgrey":
        return 2846468607;
      case "darkkhaki":
        return 3182914559;
      case "darkmagenta":
        return 2332068863;
      case "darkolivegreen":
        return 1433087999;
      case "darkorange":
        return 4287365375;
      case "darkorchid":
        return 2570243327;
      case "darkred":
        return 2332033279;
      case "darksalmon":
        return 3918953215;
      case "darkseagreen":
        return 2411499519;
      case "darkslateblue":
        return 1211993087;
      case "darkslategray":
        return 793726975;
      case "darkslategrey":
        return 793726975;
      case "darkturquoise":
        return 13554175;
      case "darkviolet":
        return 2483082239;
      case "deeppink":
        return 4279538687;
      case "deepskyblue":
        return 12582911;
      case "dimgray":
        return 1768516095;
      case "dimgrey":
        return 1768516095;
      case "dodgerblue":
        return 512819199;
      case "firebrick":
        return 2988581631;
      case "floralwhite":
        return 4294635775;
      case "forestgreen":
        return 579543807;
      case "fuchsia":
        return 4278255615;
      case "gainsboro":
        return 3705462015;
      case "ghostwhite":
        return 4177068031;
      case "gold":
        return 4292280575;
      case "goldenrod":
        return 3668254975;
      case "gray":
        return 2155905279;
      case "green":
        return 8388863;
      case "greenyellow":
        return 2919182335;
      case "grey":
        return 2155905279;
      case "honeydew":
        return 4043305215;
      case "hotpink":
        return 4285117695;
      case "indianred":
        return 3445382399;
      case "indigo":
        return 1258324735;
      case "ivory":
        return 4294963455;
      case "khaki":
        return 4041641215;
      case "lavender":
        return 3873897215;
      case "lavenderblush":
        return 4293981695;
      case "lawngreen":
        return 2096890111;
      case "lemonchiffon":
        return 4294626815;
      case "lightblue":
        return 2916673279;
      case "lightcoral":
        return 4034953471;
      case "lightcyan":
        return 3774873599;
      case "lightgoldenrodyellow":
        return 4210742015;
      case "lightgray":
        return 3553874943;
      case "lightgreen":
        return 2431553791;
      case "lightgrey":
        return 3553874943;
      case "lightpink":
        return 4290167295;
      case "lightsalmon":
        return 4288707327;
      case "lightseagreen":
        return 548580095;
      case "lightskyblue":
        return 2278488831;
      case "lightslategray":
        return 2005441023;
      case "lightslategrey":
        return 2005441023;
      case "lightsteelblue":
        return 2965692159;
      case "lightyellow":
        return 4294959359;
      case "lime":
        return 16711935;
      case "limegreen":
        return 852308735;
      case "linen":
        return 4210091775;
      case "magenta":
        return 4278255615;
      case "maroon":
        return 2147483903;
      case "mediumaquamarine":
        return 1724754687;
      case "mediumblue":
        return 52735;
      case "mediumorchid":
        return 3126187007;
      case "mediumpurple":
        return 2473647103;
      case "mediumseagreen":
        return 1018393087;
      case "mediumslateblue":
        return 2070474495;
      case "mediumspringgreen":
        return 16423679;
      case "mediumturquoise":
        return 1221709055;
      case "mediumvioletred":
        return 3340076543;
      case "midnightblue":
        return 421097727;
      case "mintcream":
        return 4127193855;
      case "mistyrose":
        return 4293190143;
      case "moccasin":
        return 4293178879;
      case "navajowhite":
        return 4292783615;
      case "navy":
        return 33023;
      case "oldlace":
        return 4260751103;
      case "olive":
        return 2155872511;
      case "olivedrab":
        return 1804477439;
      case "orange":
        return 4289003775;
      case "orangered":
        return 4282712319;
      case "orchid":
        return 3664828159;
      case "palegoldenrod":
        return 4008225535;
      case "palegreen":
        return 2566625535;
      case "paleturquoise":
        return 2951671551;
      case "palevioletred":
        return 3681588223;
      case "papayawhip":
        return 4293907967;
      case "peachpuff":
        return 4292524543;
      case "peru":
        return 3448061951;
      case "pink":
        return 4290825215;
      case "plum":
        return 3718307327;
      case "powderblue":
        return 2967529215;
      case "purple":
        return 2147516671;
      case "rebeccapurple":
        return 1714657791;
      case "red":
        return 4278190335;
      case "rosybrown":
        return 3163525119;
      case "royalblue":
        return 1097458175;
      case "saddlebrown":
        return 2336560127;
      case "salmon":
        return 4202722047;
      case "sandybrown":
        return 4104413439;
      case "seagreen":
        return 780883967;
      case "seashell":
        return 4294307583;
      case "sienna":
        return 2689740287;
      case "silver":
        return 3233857791;
      case "skyblue":
        return 2278484991;
      case "slateblue":
        return 1784335871;
      case "slategray":
        return 1887473919;
      case "slategrey":
        return 1887473919;
      case "snow":
        return 4294638335;
      case "springgreen":
        return 16744447;
      case "steelblue":
        return 1182971135;
      case "tan":
        return 3535047935;
      case "teal":
        return 8421631;
      case "thistle":
        return 3636451583;
      case "tomato":
        return 4284696575;
      case "turquoise":
        return 1088475391;
      case "violet":
        return 4001558271;
      case "wheat":
        return 4125012991;
      case "white":
        return 4294967295;
      case "whitesmoke":
        return 4126537215;
      case "yellow":
        return 4294902015;
      case "yellowgreen":
        return 2597139199;
    }
    return null;
  }
  normalizeColor_1 = normalizeColor2;
  return normalizeColor_1;
}
var normalizeColorExports = requireNormalizeColor();
const index = /* @__PURE__ */ getDefaultExportFromCjs(normalizeColorExports);
const normalizeColor$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [normalizeColorExports]);
var norm = index || normalizeColor$3, normalizeCSSColor = norm;
function rgba(colorInt) {
  var r = Math.round((colorInt & 4278190080) >>> 24), g = Math.round((colorInt & 16711680) >>> 16), b2 = Math.round((colorInt & 65280) >>> 8), a = ((colorInt & 255) >>> 0) / 255;
  return {
    r,
    g,
    b: b2,
    a
  };
}
var index_default = normalizeCSSColor;
const processColor$1 = (color) => {
  if (color == null)
    return color;
  let int32Color = index_default(color);
  if (int32Color != null)
    return int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0, int32Color;
};
const normalizeColor$2 = (color, opacity = 1) => {
  if (color == null) return;
  if (typeof color == "string" && isWebColor$1(color)) return color;
  const colorInt = processColor$1(color);
  if (colorInt != null) {
    const r = colorInt >> 16 & 255, g = colorInt >> 8 & 255, b2 = colorInt & 255, alpha = ((colorInt >> 24 & 255) / 255 * opacity).toFixed(2);
    return `rgba(${r},${g},${b2},${alpha})`;
  }
  if (typeof color == "string") return color;
};
function normalizeValueWithProperty$1(value, property) {
  let returnValue = value;
  return typeof value == "number" ? returnValue = `${value}px` : property != null, returnValue;
}
const focusableElements$1 = {
  A: true,
  INPUT: true,
  SELECT: true,
  TEXTAREA: true
}, UIManager$1 = {
  blur(node) {
    try {
      node.blur();
    } catch (e2) {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements$1[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch (e2) {
    }
  },
  measure(node, callback) {
    return measure(node, callback);
  },
  measureInWindow(node, callback) {
    return measureInWindow(node, callback);
  },
  // note its flipped fail and success on purpose lol
  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    return __async(this, null, function* () {
      return measureLayout(node, relativeToNativeNode, onSuccess);
    });
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
const TextInputState = {
  /**
   * Internal state
   */
  _currentlyFocusedNode: null,
  /**
   * Returns the ID of the currently focused text field, if one exists
   * If no text field is focused it returns null
   */
  currentlyFocusedField() {
    return document.activeElement !== this._currentlyFocusedNode && (this._currentlyFocusedNode = null), this._currentlyFocusedNode;
  },
  /**
   * @param {Object} TextInputID id of the text field to focus
   * Focuses the specified text field
   * noop if the text field was already focused
   */
  focusTextInput(textFieldNode) {
    textFieldNode !== null && (this._currentlyFocusedNode = textFieldNode, document.activeElement !== textFieldNode && UIManager$1.focus(textFieldNode));
  },
  /**
   * @param {Object} textFieldNode id of the text field to focus
   * Unfocuses the specified text field
   * noop if it wasn't focused
   */
  blurTextInput(textFieldNode) {
    textFieldNode !== null && (this._currentlyFocusedNode = null, document.activeElement === textFieldNode && UIManager$1.blur(textFieldNode));
  }
};
const dismissKeyboard = () => {
  TextInputState.blurTextInput(TextInputState.currentlyFocusedField());
};
const dataUriPattern = /^data:/;
const _ImageUriCache = class _ImageUriCache {
  static has(uri) {
    const entries = _ImageUriCache._entries;
    return dataUriPattern.test(uri) || !!entries[uri];
  }
  static add(uri) {
    const entries = _ImageUriCache._entries, lastUsedTimestamp = Date.now();
    entries[uri] ? (entries[uri].lastUsedTimestamp = lastUsedTimestamp, entries[uri].refCount += 1) : entries[uri] = {
      lastUsedTimestamp,
      refCount: 1
    };
  }
  static remove(uri) {
    const entries = _ImageUriCache._entries;
    entries[uri] && (entries[uri].refCount -= 1), _ImageUriCache._cleanUpIfNeeded();
  }
  static _cleanUpIfNeeded() {
    const entries = _ImageUriCache._entries, imageUris = Object.keys(entries);
    if (imageUris.length + 1 > _ImageUriCache._maximumEntries) {
      let leastRecentlyUsedKey, leastRecentlyUsedEntry;
      imageUris.forEach((uri) => {
        const entry = entries[uri];
        (!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0 && (leastRecentlyUsedKey = uri, leastRecentlyUsedEntry = entry);
      }), leastRecentlyUsedKey && delete entries[leastRecentlyUsedKey];
    }
  }
};
__publicField(_ImageUriCache, "_maximumEntries", 256);
__publicField(_ImageUriCache, "_entries", {});
let ImageUriCache = _ImageUriCache;
let id = 0;
const requests = {}, ImageLoader = {
  abort(requestId) {
    let image = requests[`${requestId}`];
    image && (image.onerror = null, image.onload = null, image = null, delete requests[`${requestId}`]);
  },
  getSize(uri, success, failure) {
    let complete = false;
    const interval = setInterval(callback, 16), requestId = ImageLoader.load(uri, callback, errorCallback);
    function callback() {
      const image = requests[`${requestId}`];
      if (image) {
        const {
          naturalHeight,
          naturalWidth
        } = image;
        naturalHeight && naturalWidth && (success(naturalWidth, naturalHeight), complete = true);
      }
      complete && (ImageLoader.abort(requestId), clearInterval(interval));
    }
    function errorCallback() {
      typeof failure == "function" && failure(), ImageLoader.abort(requestId), clearInterval(interval);
    }
  },
  has(uri) {
    return ImageUriCache.has(uri);
  },
  load(uri, onLoad, onError) {
    id += 1;
    const image = new window.Image();
    return image.onerror = onError, image.onload = (e2) => {
      const onDecode = () => onLoad({
        nativeEvent: e2
      });
      typeof image.decode == "function" ? image.decode().then(onDecode, onDecode) : setTimeout(onDecode, 0);
    }, image.src = uri, requests[`${id}`] = image, id;
  },
  prefetch(uri) {
    return new Promise((resolve, reject) => {
      ImageLoader.load(uri, () => {
        ImageUriCache.add(uri), ImageUriCache.remove(uri), resolve();
      }, reject);
    });
  },
  queryCache(uris) {
    const result = {};
    return uris.forEach((u) => {
      ImageUriCache.has(u) && (result[u] = "disk/memory");
    }), Promise.resolve(result);
  }
};
const isWebColor = (color) => color === "currentcolor" || color === "currentColor" || color === "inherit" || color.startsWith("var(");
const processColor = (color) => {
  if (color == null) return color;
  let int32Color = index_default(color);
  if (int32Color != null) return int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0, int32Color;
};
const normalizeColor$1 = (color, opacity = 1) => {
  if (color == null) return;
  if (typeof color == "string" && isWebColor(color)) return color;
  const colorInt = processColor(color);
  if (colorInt != null) {
    const r = colorInt >> 16 & 255, g = colorInt >> 8 & 255, b2 = colorInt & 255, alpha = ((colorInt >> 24 & 255) / 255 * opacity).toFixed(2);
    return `rgba(${r},${g},${b2},${alpha})`;
  }
};
function pick(obj, list) {
  const nextObj = {};
  for (const key in obj) obj.hasOwnProperty(key) && list[key] === true && (nextObj[key] = obj[key]);
  return nextObj;
}
const Platform = {
  OS: "web"
};
const defaultOffset$1 = {
  height: 0,
  width: 0
}, createBoxShadowValue = (style) => {
  const {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius
  } = style, {
    height,
    width
  } = shadowOffset || defaultOffset$1, offsetX = normalizeValueWithProperty$1(width), offsetY = normalizeValueWithProperty$1(height), blurRadius = normalizeValueWithProperty$1(shadowRadius || 0), color = normalizeColor$2(shadowColor || "black", shadowOpacity);
  if (color != null && offsetX != null && offsetY != null && blurRadius != null) return `${offsetX} ${offsetY} ${blurRadius} ${color}`;
};
const absoluteFillObject = {
  position: "absolute",
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
}, absoluteFill = absoluteFillObject;
function create(styles2) {
  return styles2;
}
function compose(style1, style2) {
  return flatten(style1, style2);
}
function flatten(...styles2) {
  return styles2.flat().flat().flat().flat().reduce((acc, cur) => (cur && Object.assign(acc, cur), acc), {});
}
function getSheet() {
  return {
    id: "",
    textContent: sheet.getTextContent()
  };
}
function StyleSheet(styles2, options) {
}
StyleSheet.absoluteFill = absoluteFill;
StyleSheet.absoluteFillObject = absoluteFillObject;
StyleSheet.create = create;
StyleSheet.compose = compose;
StyleSheet.flatten = flatten;
StyleSheet.getSheet = getSheet;
StyleSheet.hairlineWidth = 1;
const _requestIdleCallback = function(cb, options) {
  return setTimeout(() => {
    const start = Date.now();
    cb({
      didTimeout: false,
      timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
}, isSupported = canUseDOM$1 && typeof window.requestIdleCallback < "u", requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;
const focusableElements = {
  A: true,
  INPUT: true,
  SELECT: true,
  TEXTAREA: true
}, UIManager = {
  blur(node) {
    try {
      node.blur();
    } catch (e2) {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch (e2) {
    }
  },
  measure(node, callback) {
    return measure(node, callback);
  },
  measureInWindow(node, callback) {
    return measureInWindow(node, callback);
  },
  // note its flipped fail and success on purpose lol
  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    return __async(this, null, function* () {
      return measureLayout(node, relativeToNativeNode, onSuccess);
    });
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
function useElementLayout(ref, onLayout) {
  const wrappedRef = React.useMemo(() => ({
    current: {
      get host() {
        return ref.current;
      }
    }
  }), [ref]);
  return React.useEffect(() => {
    enable();
  }, []), useElementLayout$1(wrappedRef, onLayout);
}
const useLayoutEffectImpl = canUseDOM$1 ? React.useLayoutEffect : React.useEffect;
function useEvent$1(event, options) {
  const targetListeners = useStable(() => /* @__PURE__ */ new Map()), addListener = useStable(() => {
    const addEventListener = createEventHandle(event, options);
    return (target, callback) => {
      const removeTargetListener = targetListeners.get(target);
      removeTargetListener == null ? void 0 : removeTargetListener(), callback == null && targetListeners.delete(target);
      const removeEventListener = addEventListener(target, callback);
      return targetListeners.set(target, removeEventListener), removeEventListener;
    };
  });
  return useLayoutEffectImpl(() => () => {
    targetListeners.forEach((removeListener) => {
      removeListener();
    }), targetListeners.clear();
  }, [targetListeners]), addListener;
}
const emptyObject$4 = {}, opts = {
  passive: true
}, lockEventType = "react-gui:hover:lock", unlockEventType = "react-gui:hover:unlock", supportsPointerEvent = () => typeof window < "u" && window.PointerEvent != null;
function dispatchCustomEvent(target, type, payload) {
  const event = document.createEvent("CustomEvent"), {
    bubbles = true,
    cancelable = true,
    detail
  } = emptyObject$4;
  event.initCustomEvent(type, bubbles, cancelable, detail), target.dispatchEvent(event);
}
function getPointerType(event) {
  const {
    pointerType
  } = event;
  return pointerType != null ? pointerType : getModality();
}
function useHover(targetRef, config) {
  const {
    contain,
    disabled,
    onHoverStart,
    onHoverChange,
    onHoverUpdate,
    onHoverEnd
  } = config, canUsePE = supportsPointerEvent(), addMoveListener = useEvent$1(canUsePE ? "pointermove" : "mousemove", opts), addEnterListener = useEvent$1(canUsePE ? "pointerenter" : "mouseenter", opts), addLeaveListener = useEvent$1(canUsePE ? "pointerleave" : "mouseleave", opts), addLockListener = useEvent$1(lockEventType, opts), addUnlockListener = useEvent$1(unlockEventType, opts);
  useLayoutEffectImpl(() => {
    const target = targetRef.current;
    if (target !== null) {
      const hoverEnd = function(e2) {
        onHoverEnd == null ? void 0 : onHoverEnd(e2), onHoverChange == null ? void 0 : onHoverChange(false), addMoveListener(target, null), addLeaveListener(target, null);
      }, leaveListener = function(e2) {
        const target2 = targetRef.current;
        target2 != null && getPointerType(e2) !== "touch" && (contain && dispatchCustomEvent(target2, unlockEventType), hoverEnd(e2));
      }, moveListener = function(e2) {
        getPointerType(e2) !== "touch" && onHoverUpdate != null && (e2.x == null && (e2.x = e2.clientX), e2.y == null && (e2.y = e2.clientY), onHoverUpdate(e2));
      }, hoverStart = function(e2) {
        onHoverStart == null ? void 0 : onHoverStart(e2), onHoverChange == null ? void 0 : onHoverChange(true), onHoverUpdate != null && addMoveListener(target, disabled ? null : moveListener), addLeaveListener(target, disabled ? null : leaveListener);
      };
      addEnterListener(target, disabled ? null : function(e2) {
        const target2 = targetRef.current;
        if (target2 != null && getPointerType(e2) !== "touch") {
          contain && dispatchCustomEvent(target2, lockEventType), hoverStart(e2);
          const lockListener = function(lockEvent) {
            lockEvent.target !== target2 && hoverEnd(e2);
          }, unlockListener = function(lockEvent) {
            lockEvent.target !== target2 && hoverStart(e2);
          };
          addLockListener(target2, disabled ? null : lockListener), addUnlockListener(target2, disabled ? null : unlockListener);
        }
      });
    }
  }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);
}
function invariant(condition, log, ...logVars) {
  if (!condition) throw new Error(log);
}
function warning(condition, log, ...logVars) {
}
let EventEmitter$1 = class EventEmitter {
  constructor() {
    __publicField(this, "_registry", {});
  }
  addListener(eventType, listener, context) {
    const registrations = this._allocate(eventType), registration = {
      context,
      listener,
      remove: () => {
        registrations.delete(registration);
      }
    };
    return registrations.add(registration), registration;
  }
  emit(eventType, ...args) {
    const registrations = this._registry[eventType];
    if (registrations != null) for (const registration of Array.from(registrations)) registration.listener.apply(registration.context, args);
  }
  _allocate(eventType) {
    let registrations = this._registry[eventType];
    return registrations == null && (registrations = /* @__PURE__ */ new Set(), this._registry[eventType] = registrations), registrations;
  }
};
class TaskQueue {
  constructor({
    onMoreTasks
  }) {
    __publicField(this, "_queueStack");
    __publicField(this, "_onMoreTasks");
    this._onMoreTasks = onMoreTasks, this._queueStack = [{
      tasks: [],
      popable: true
    }];
  }
  enqueueTasks(tasks) {
    tasks.forEach((task) => this._enqueue(task));
  }
  cancelTasks(tasksToCancel) {
    this._queueStack = this._queueStack.map((queue2) => __spreadProps(__spreadValues({}, queue2), {
      tasks: queue2.tasks.filter((task) => !tasksToCancel.includes(task))
    })).filter((queue2, idx) => queue2.tasks.length > 0 || idx === 0);
  }
  hasTasksToProcess() {
    return this._getCurrentQueue().length > 0;
  }
  processNext() {
    const queue2 = this._getCurrentQueue();
    if (queue2.length) {
      const task = queue2.shift();
      try {
        typeof task == "object" && task && "gen" in task ? this._genPromise(task) : typeof task == "object" && task && "run" in task ? task.run() : (invariant(typeof task == "function", `Expected Function, SimpleTask, or PromiseTask, but got:
` + JSON.stringify(task, null, 2)), task());
      } catch (e2) {
        if (e2 instanceof Error) {
          const taskName = task && typeof task == "object" && "name" in task ? task.name : "";
          e2.message = "TaskQueue: Error with task " + taskName + ": " + e2.message;
        }
        throw e2;
      }
    }
  }
  _enqueue(task) {
    this._getCurrentQueue().push(task);
  }
  _getCurrentQueue() {
    const stackIdx = this._queueStack.length - 1, queue2 = this._queueStack[stackIdx];
    return queue2.popable && queue2.tasks.length === 0 && stackIdx > 0 ? (this._queueStack.pop(), this._getCurrentQueue()) : queue2.tasks;
  }
  _genPromise(task) {
    const stackIdx = this._queueStack.push({
      tasks: [],
      popable: false
    }) - 1, stackItem = this._queueStack[stackIdx];
    task.gen().then(() => {
      stackItem.popable = true, this.hasTasksToProcess() && this._onMoreTasks();
    }).catch((ex) => {
      setTimeout(() => {
        throw ex instanceof Error && (ex.message = `TaskQueue: Error resolving Promise in task ${task.name}: ${ex.message}`), ex;
      }, 0);
    });
  }
}
const _emitter = new EventEmitter$1(), InteractionManager = {
  Events: {
    interactionStart: "interactionStart",
    interactionComplete: "interactionComplete"
  },
  /**
   * Schedule a function to run after all interactions have completed.
   */
  runAfterInteractions(task) {
    const tasks = [], promise = new Promise((resolve) => {
      _scheduleUpdate(), task && tasks.push(task), tasks.push({
        run: resolve,
        name: "resolve " + (task && typeof task == "object" && "name" in task && task.name || "?")
      }), _taskQueue.enqueueTasks(tasks);
    });
    return {
      then: promise.then.bind(promise),
      done: promise.then.bind(promise),
      cancel: () => {
        _taskQueue.cancelTasks(tasks);
      }
    };
  },
  /**
   * Notify manager that an interaction has started.
   */
  createInteractionHandle() {
    _scheduleUpdate();
    const handle = ++_inc;
    return _addInteractionSet.add(handle), handle;
  },
  /**
   * Notify manager that an interaction has completed.
   */
  clearInteractionHandle(handle) {
    invariant(!!handle, "Must provide a handle to clear."), _scheduleUpdate(), _addInteractionSet.delete(handle), _deleteInteractionSet.add(handle);
  },
  addListener: _emitter.addListener.bind(_emitter),
  /**
   * Set deadline for task processing
   */
  setDeadline(deadline) {
    _deadline = deadline;
  }
}, _interactionSet = /* @__PURE__ */ new Set(), _addInteractionSet = /* @__PURE__ */ new Set(), _deleteInteractionSet = /* @__PURE__ */ new Set(), _taskQueue = new TaskQueue({
  onMoreTasks: _scheduleUpdate
});
let _nextUpdateHandle = null, _inc = 0, _deadline = -1;
function _scheduleUpdate() {
  _nextUpdateHandle || (_deadline > 0 ? _nextUpdateHandle = setTimeout(_processUpdate) : _nextUpdateHandle = requestIdleCallback(_processUpdate));
}
function _processUpdate() {
  _nextUpdateHandle = null;
  const interactionCount = _interactionSet.size;
  _addInteractionSet.forEach((handle) => _interactionSet.add(handle)), _deleteInteractionSet.forEach((handle) => _interactionSet.delete(handle));
  const nextInteractionCount = _interactionSet.size;
  if (interactionCount !== 0 && nextInteractionCount === 0 ? _emitter.emit("interactionComplete") : interactionCount === 0 && nextInteractionCount !== 0 && _emitter.emit("interactionStart"), nextInteractionCount === 0) {
    const begin = Date.now();
    for (; _taskQueue.hasTasksToProcess(); ) if (_taskQueue.processNext(), _deadline > 0 && Date.now() - begin >= _deadline) {
      _scheduleUpdate();
      break;
    }
  }
  _addInteractionSet.clear(), _deleteInteractionSet.clear();
}
function useMergeRefs$1(...args) {
  return React__namespace.useMemo(
    () => mergeRefs(...args),
    // eslint-disable-next-line
    [...args]
  );
}
const useCreateElement$1 = (component, props, options) => {
  const {
    element,
    styles: styles2
  } = createElementAndStyles$1(component, props);
  useDidFinishSSR();
  const styleTags = React.useMemo(() => null, [
    // never changes
  ]);
  return React.useInsertionEffect(() => {
    if (!styles2) return;
    const styleObj = {};
    for (const style of styles2) styleObj[style[0]] = style;
  }, [styles2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [element, styleTags]
  });
}, createElement$1 = (component, props, options) => {
  const {
    element,
    styles: styles2
  } = createElementAndStyles$1(component, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [element, styles2 ? getStyleTags() : null]
  });
}, createElementAndStyles$1 = (component, props, options) => {
  let accessibilityComponent;
  component && component.constructor === String && (accessibilityComponent = AccessibilityUtil.propsToAccessibilityComponent(props));
  const Component = accessibilityComponent || component, domProps = createDOMProps(Component, props), styles2 = stylesFromProps.get(domProps);
  let element = React.createElement(Component, domProps);
  return {
    element: domProps.dir ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleProvider, {
      direction: domProps.dir,
      locale: domProps.lang,
      children: element
    }) : element,
    styles: styles2
  };
};
const spec = {
  createAnimatedNode: (tag, config) => {
  },
  getValue: (tag, saveValueCallback) => {
  },
  startListeningToAnimatedNodeValue: (tag) => {
  },
  stopListeningToAnimatedNodeValue: (tag) => {
  },
  connectAnimatedNodes: (parentTag, childTag) => {
  },
  disconnectAnimatedNodes: (parentTag, childTag) => {
  },
  startAnimatingNode: (animationId, nodeTag, config, endCallback) => {
  },
  stopAnimation: (animationId) => {
  },
  setAnimatedNodeValue: (nodeTag, value) => {
  },
  setAnimatedNodeOffset: (nodeTag, offset) => {
  },
  flattenAnimatedNodeOffset: (nodeTag) => {
  },
  extractAnimatedNodeOffset: (nodeTag) => {
  },
  connectAnimatedNodeToView: (nodeTag, viewTag) => {
  },
  disconnectAnimatedNodeFromView: (nodeTag, viewTag) => {
  },
  restoreDefaultValues: (nodeTag) => {
  },
  dropAnimatedNode: (tag) => {
  },
  addAnimatedEventToView: (viewTag, eventName, eventMapping) => {
  },
  removeAnimatedEventFromView: (viewTag, eventName, animatedNodeTag) => {
  }
}, NativeAnimatedNonTurboModule = spec;
class _EventSubscription {
  /**
   * @param {EventSubscriptionVendor} subscriber the subscriber that controls
   *   this subscription.
   */
  constructor(subscriber) {
    this.subscriber = subscriber;
  }
  /**
   * Removes this subscription from the subscriber that controls it.
   */
  remove() {
    this.subscriber.removeSubscription(this);
  }
}
class EmitterSubscription extends _EventSubscription {
  /**
   * @param {EventEmitter} emitter - The event emitter that registered this
   *   subscription
   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls
   *   this subscription
   * @param {function} listener - Function to invoke when the specified event is
   *   emitted
   * @param {*} context - Optional context object to use when invoking the
   *   listener
   */
  constructor(emitter, subscriber, listener, context) {
    super(subscriber), this.emitter = emitter, this.listener = listener, this.context = context;
  }
  /**
   * Removes this subscription from the emitter that registered it.
   * Note: we're overriding the `remove()` method of _EventSubscription here
   * but deliberately not calling `super.remove()` as the responsibility
   * for removing the subscription lies with the EventEmitter.
   */
  remove() {
    this.emitter.removeSubscription(this);
  }
}
class EventSubscriptionVendor {
  constructor() {
    this._subscriptionsForType = {};
  }
  /**
   * Adds a subscription keyed by an event type.
   *
   * @param {string} eventType
   * @param {EventSubscription} subscription
   */
  addSubscription(eventType, subscription) {
    invariant(subscription.subscriber === this, "The subscriber of the subscription is incorrectly set."), this._subscriptionsForType[eventType] || (this._subscriptionsForType[eventType] = []);
    var key = this._subscriptionsForType[eventType].length;
    return this._subscriptionsForType[eventType].push(subscription), subscription.eventType = eventType, subscription.key = key, subscription;
  }
  /**
   * Removes a bulk set of the subscriptions.
   *
   * @param {?string} eventType - Optional name of the event type whose
   *   registered supscriptions to remove, if null remove all subscriptions.
   */
  removeAllSubscriptions(eventType) {
    eventType == null ? this._subscriptionsForType = {} : delete this._subscriptionsForType[eventType];
  }
  /**
   * Removes a specific subscription. Instead of calling this function, call
   * `subscription.remove()` directly.
   *
   * @param {object} subscription
   */
  removeSubscription(subscription) {
    var eventType = subscription.eventType, key = subscription.key, subscriptionsForType = this._subscriptionsForType[eventType];
    subscriptionsForType && delete subscriptionsForType[key];
  }
  /**
   * Returns the array of subscriptions that are currently registered for the
   * given event type.
   *
   * Note: This array can be potentially sparse as subscriptions are deleted
   * from it when they are removed.
   *
   * TODO: This returns a nullable array. wat?
   *
   * @param {string} eventType
   * @returns {?array}
   */
  getSubscriptionsForType(eventType) {
    return this._subscriptionsForType[eventType];
  }
}
var sparseFilterPredicate = () => true;
class EventEmitter2 {
  /**
   * @constructor
   *
   * @param {EventSubscriptionVendor} subscriber - Optional subscriber instance
   *   to use. If omitted, a new subscriber will be created for the emitter.
   */
  constructor(subscriber = new EventSubscriptionVendor()) {
    this._subscriber = subscriber;
  }
  /**
   * Adds a listener to be invoked when events of the specified type are
   * emitted. An optional calling context may be provided. The data arguments
   * emitted will be passed to the listener function.
   *
   * TODO: Annotate the listener arg's type. This is tricky because listeners
   *       can be invoked with varargs.
   *
   * @param {string} eventType - Name of the event to listen to
   * @param {function} listener - Function to invoke when the specified event is
   *   emitted
   * @param {*} context - Optional context object to use when invoking the
   *   listener
   */
  addListener(eventType, listener, context) {
    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this, this._subscriber, listener, context));
  }
  /**
   * Removes all of the registered listeners, including those registered as
   * listener maps.
   *
   * @param {?string} eventType - Optional name of the event whose registered
   *   listeners to remove
   */
  removeAllListeners(eventType) {
    this._subscriber.removeAllSubscriptions(eventType);
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeSubscription(subscription) {
    invariant(subscription.emitter === this, "Subscription does not belong to this emitter."), this._subscriber.removeSubscription(subscription);
  }
  /**
   * Returns the number of listeners that are currently registered for the given
   * event.
   *
   * @param {string} eventType - Name of the event to query
   * @returns {number}
   */
  listenerCount(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    return subscriptions ? (
      // "callbackfn is called only for elements of the array which actually
      // exist; it is not called for missing elements of the array."
      // https://www.ecma-international.org/ecma-262/9.0/index.html#sec-array.prototype.filter
      subscriptions.filter(sparseFilterPredicate).length
    ) : 0;
  }
  /**
   * Emits an event of the given type with the given data. All handlers of that
   * particular type will be notified.
   *
   * @param {string} eventType - Name of the event to emit
   * @param {...*} Arbitrary arguments to be passed to each registered listener
   *
   * @example
   *   emitter.addListener('someEvent', function(message) {
   *     console.log(message);
   *   });
   *
   *   emitter.emit('someEvent', 'abc'); // logs 'abc'
   */
  emit(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    if (subscriptions) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
      for (var i = 0, l = subscriptions.length; i < l; i++) {
        var subscription = subscriptions[i];
        subscription && subscription.listener && subscription.listener.apply(subscription.context, args);
      }
    }
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeListener(eventType, listener) {
    console.error("EventEmitter.removeListener('" + eventType + "', ...): Method has been deprecated. Please instead use `remove()` on the subscription returned by `EventEmitter.addListener`.");
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    if (subscriptions) for (var i = 0, l = subscriptions.length; i < l; i++) {
      var subscription = subscriptions[i];
      subscription && subscription.listener === listener && subscription.remove();
    }
  }
}
const RCTDeviceEventEmitter = new EventEmitter2();
class NativeEventEmitter {
  constructor(nativeModule) {
    __publicField(this, "_nativeModule");
  }
  addListener(eventType, listener, context) {
    var _a;
    (_a = this._nativeModule) == null ? void 0 : _a.addListener(eventType);
    let subscription = RCTDeviceEventEmitter.addListener(eventType, listener, context);
    return {
      remove: () => {
        var _a2;
        subscription != null && ((_a2 = this._nativeModule) == null ? void 0 : _a2.removeListeners(1), subscription.remove(), subscription = null);
      }
    };
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeListener(eventType, listener) {
    var _a;
    (_a = this._nativeModule) == null ? void 0 : _a.removeListeners(1), RCTDeviceEventEmitter.removeListener(eventType, listener);
  }
  emit(eventType, ...args) {
    RCTDeviceEventEmitter.emit(eventType, ...args);
  }
  removeAllListeners(eventType) {
    var _a;
    invariant(eventType != null, "`NativeEventEmitter.removeAllListener()` requires a non-null argument."), (_a = this._nativeModule) == null ? void 0 : _a.removeListeners(this.listenerCount(eventType)), RCTDeviceEventEmitter.removeAllListeners(eventType);
  }
  listenerCount(eventType) {
    return RCTDeviceEventEmitter.listenerCount(eventType);
  }
}
const ReactNativeFeatureFlags = {
  isLayoutAnimationEnabled: () => true,
  shouldEmitW3CPointerEvents: () => false,
  shouldPressibilityUseW3CPointerEventsForHover: () => false,
  animatedShouldDebounceQueueFlush: () => false,
  animatedShouldUseSingleOp: () => false
};
const NativeAnimatedModule = NativeAnimatedNonTurboModule;
let __nativeAnimatedNodeTagCount = 1, __nativeAnimationIdCount = 1, nativeEventEmitter, waitingForQueuedOperations = /* @__PURE__ */ new Set(), queueOperations = false, queue = [];
const nativeOps = NativeAnimatedModule, API = {
  getValue: function(tag, saveValueCallback) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.getValue, tag, saveValueCallback);
  },
  setWaitingForIdentifier: function(id2) {
    waitingForQueuedOperations.add(id2), queueOperations = true;
  },
  unsetWaitingForIdentifier: function(id2) {
    waitingForQueuedOperations.delete(id2), waitingForQueuedOperations.size === 0 && (queueOperations = false, API.disableQueue());
  },
  disableQueue: function() {
    if (invariant(nativeOps, "Native animated module is not available"), ReactNativeFeatureFlags.animatedShouldDebounceQueueFlush()) ;
  },
  flushQueue: function() {
  },
  queueOperation: (fn, ...args) => {
    queueOperations || queue.length !== 0 ? queue.push(() => fn(...args)) : fn(...args);
  },
  createAnimatedNode: function(tag, config) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.createAnimatedNode, tag, config);
  },
  updateAnimatedNodeConfig: function(tag, config) {
    invariant(nativeOps, "Native animated module is not available");
  },
  startListeningToAnimatedNodeValue: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.startListeningToAnimatedNodeValue, tag);
  },
  stopListeningToAnimatedNodeValue: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.stopListeningToAnimatedNodeValue, tag);
  },
  connectAnimatedNodes: function(parentTag, childTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.connectAnimatedNodes, parentTag, childTag);
  },
  disconnectAnimatedNodes: function(parentTag, childTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.disconnectAnimatedNodes, parentTag, childTag);
  },
  startAnimatingNode: function(animationId, nodeTag, config, endCallback) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config, endCallback);
  },
  stopAnimation: function(animationId) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.stopAnimation, animationId);
  },
  setAnimatedNodeValue: function(nodeTag, value) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.setAnimatedNodeValue, nodeTag, value);
  },
  setAnimatedNodeOffset: function(nodeTag, offset) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.setAnimatedNodeOffset, nodeTag, offset);
  },
  flattenAnimatedNodeOffset: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.flattenAnimatedNodeOffset, nodeTag);
  },
  extractAnimatedNodeOffset: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.extractAnimatedNodeOffset, nodeTag);
  },
  connectAnimatedNodeToView: function(nodeTag, viewTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.connectAnimatedNodeToView, nodeTag, viewTag);
  },
  disconnectAnimatedNodeFromView: function(nodeTag, viewTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.disconnectAnimatedNodeFromView, nodeTag, viewTag);
  },
  restoreDefaultValues: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), nativeOps.restoreDefaultValues != null && API.queueOperation(nativeOps.restoreDefaultValues, nodeTag);
  },
  dropAnimatedNode: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.dropAnimatedNode, tag);
  },
  addAnimatedEventToView: function(viewTag, eventName, eventMapping) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.addAnimatedEventToView, viewTag, eventName, eventMapping);
  },
  removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.removeAnimatedEventFromView, viewTag, eventName, animatedNodeTag);
  }
};
const SUPPORTED_COLOR_STYLES = {
  backgroundColor: true,
  borderBottomColor: true,
  borderColor: true,
  borderEndColor: true,
  borderLeftColor: true,
  borderRightColor: true,
  borderStartColor: true,
  borderTopColor: true,
  color: true,
  tintColor: true
}, SUPPORTED_STYLES = __spreadProps(__spreadValues({}, SUPPORTED_COLOR_STYLES), {
  borderBottomEndRadius: true,
  borderBottomLeftRadius: true,
  borderBottomRightRadius: true,
  borderBottomStartRadius: true,
  borderRadius: true,
  borderTopEndRadius: true,
  borderTopLeftRadius: true,
  borderTopRightRadius: true,
  borderTopStartRadius: true,
  elevation: true,
  opacity: true,
  transform: true,
  zIndex: true,
  /* ios styles */
  shadowOpacity: true,
  shadowRadius: true,
  /* legacy android transform properties */
  scaleX: true,
  scaleY: true,
  translateX: true,
  translateY: true
}), SUPPORTED_TRANSFORMS = {
  translateX: true,
  translateY: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  rotate: true,
  rotateX: true,
  rotateY: true,
  rotateZ: true,
  perspective: true
}, SUPPORTED_INTERPOLATION_PARAMS = {
  inputRange: true,
  outputRange: true,
  extrapolate: true,
  extrapolateRight: true,
  extrapolateLeft: true
};
function addWhitelistedStyleProp(prop) {
  SUPPORTED_STYLES[prop] = true;
}
function addWhitelistedTransformProp(prop) {
  SUPPORTED_TRANSFORMS[prop] = true;
}
function addWhitelistedInterpolationParam(param) {
  SUPPORTED_INTERPOLATION_PARAMS[param] = true;
}
function isSupportedColorStyleProp(prop) {
  return SUPPORTED_COLOR_STYLES.hasOwnProperty(prop);
}
function isSupportedStyleProp(prop) {
  return SUPPORTED_STYLES.hasOwnProperty(prop);
}
function isSupportedTransformProp(prop) {
  return SUPPORTED_TRANSFORMS.hasOwnProperty(prop);
}
function isSupportedInterpolationParam(param) {
  return SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(param);
}
function validateTransform(configs) {
  configs.forEach((config) => {
    if (!isSupportedTransformProp(config.property)) throw new Error(`Property '${config.property}' is not supported by native animated module`);
  });
}
function validateStyles(styles2) {
  for (const key in styles2) if (!isSupportedStyleProp(key)) throw new Error(`Style property '${key}' is not supported by native animated module`);
}
function validateInterpolation(config) {
  for (const key in config) if (!isSupportedInterpolationParam(key)) throw new Error(`Interpolation property '${key}' is not supported by native animated module`);
}
function generateNewNodeTag() {
  return __nativeAnimatedNodeTagCount++;
}
function generateNewAnimationId() {
  return __nativeAnimationIdCount++;
}
function assertNativeAnimatedModule() {
  invariant(NativeAnimatedModule, "Native animated module is not available");
}
let _warnedMissingNativeAnimated = false;
function shouldUseNativeDriver(config) {
  return config.useNativeDriver == null && console.warn("Animated: `useNativeDriver` was not specified. This is a required option and must be explicitly set to `true` or `false`"), config.useNativeDriver === true && !NativeAnimatedModule ? (_warnedMissingNativeAnimated || (console.warn("Animated: `useNativeDriver` is not supported because the native animated module is missing. Falling back to JS-based animation. To resolve this, add `RCTAnimation` module to this app, or remove `useNativeDriver`. Make sure to run `bundle exec pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md"), _warnedMissingNativeAnimated = true), false) : config.useNativeDriver || false;
}
function transformDataType(value) {
  return typeof value != "string" ? value : /deg$/.test(value) ? (parseFloat(value) || 0) * Math.PI / 180 : value;
}
const NativeAnimatedHelper = {
  API,
  isSupportedColorStyleProp,
  isSupportedStyleProp,
  isSupportedTransformProp,
  isSupportedInterpolationParam,
  addWhitelistedStyleProp,
  addWhitelistedTransformProp,
  addWhitelistedInterpolationParam,
  validateStyles,
  validateTransform,
  validateInterpolation,
  generateNewNodeTag,
  generateNewAnimationId,
  assertNativeAnimatedModule,
  shouldUseNativeDriver,
  transformDataType,
  get nativeEventEmitter() {
    return nativeEventEmitter || (nativeEventEmitter = new NativeEventEmitter(
      // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior
      // If you want to use the native module on other platforms, please remove this condition and test its behavior
      null
    )), nativeEventEmitter;
  }
};
const NativeAnimatedAPI$1 = NativeAnimatedHelper.API;
let _uniqueId = 1;
class AnimatedNode {
  constructor() {
    __publicField(this, "_listeners");
    __publicField(this, "_platformConfig");
    __publicField(this, "__nativeAnimatedValueListener");
    /* Methods and props used by native Animated impl */
    __publicField(this, "__isNative");
    __publicField(this, "__nativeTag");
    __publicField(this, "__shouldUpdateListenersForNewNativeTag");
    this._listeners = {};
  }
  __attach() {
  }
  __detach() {
    this.__isNative && this.__nativeTag != null && (NativeAnimatedHelper.API.dropAnimatedNode(this.__nativeTag), this.__nativeTag = void 0);
  }
  __getValue() {
  }
  __getAnimatedValue() {
    return this.__getValue();
  }
  __addChild(child) {
  }
  __removeChild(child) {
  }
  __getChildren() {
    return [];
  }
  __makeNative(platformConfig) {
    if (!this.__isNative) throw new Error('This node cannot be made a "native" animated node');
    this._platformConfig = platformConfig, this.hasListeners() && this._startListeningToNativeValueUpdates();
  }
  /**
   * Adds an asynchronous listener to the value so you can observe updates from
   * animations.  This is useful because there is no way to
   * synchronously read the value because it might be driven natively.
   *
   * See https://reactnative.dev/docs/animatedvalue#addlistener
   */
  addListener(callback) {
    const id2 = String(_uniqueId++);
    return this._listeners[id2] = callback, this.__isNative && this._startListeningToNativeValueUpdates(), id2;
  }
  /**
   * Unregister a listener. The `id` param shall match the identifier
   * previously returned by `addListener()`.
   *
   * See https://reactnative.dev/docs/animatedvalue#removelistener
   */
  removeListener(id2) {
    delete this._listeners[id2], this.__isNative && !this.hasListeners() && this._stopListeningForNativeValueUpdates();
  }
  /**
   * Remove all registered listeners.
   *
   * See https://reactnative.dev/docs/animatedvalue#removealllisteners
   */
  removeAllListeners() {
    this._listeners = {}, this.__isNative && this._stopListeningForNativeValueUpdates();
  }
  hasListeners() {
    return !!Object.keys(this._listeners).length;
  }
  _startListeningToNativeValueUpdates() {
    this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag || (this.__shouldUpdateListenersForNewNativeTag && (this.__shouldUpdateListenersForNewNativeTag = false, this._stopListeningForNativeValueUpdates()), NativeAnimatedAPI$1.startListeningToAnimatedNodeValue(this.__getNativeTag()), this.__nativeAnimatedValueListener = NativeAnimatedHelper.nativeEventEmitter.addListener("onAnimatedValueUpdate", (data) => {
      data.tag === this.__getNativeTag() && this.__onAnimatedValueUpdateReceived(data.value);
    }));
  }
  __onAnimatedValueUpdateReceived(value) {
    this.__callListeners(value);
  }
  __callListeners(value) {
    for (const key in this._listeners) this._listeners[key]({
      value
    });
  }
  _stopListeningForNativeValueUpdates() {
    this.__nativeAnimatedValueListener && (this.__nativeAnimatedValueListener.remove(), this.__nativeAnimatedValueListener = null, NativeAnimatedAPI$1.stopListeningToAnimatedNodeValue(this.__getNativeTag()));
  }
  __getNativeTag() {
    var _a;
    NativeAnimatedHelper.assertNativeAnimatedModule(), invariant(this.__isNative, 'Attempt to get native tag from node not marked as "native"');
    const nativeTag = (_a = this.__nativeTag) != null ? _a : NativeAnimatedHelper.generateNewNodeTag();
    if (this.__nativeTag == null) {
      this.__nativeTag = nativeTag;
      const config = this.__getNativeConfig();
      this._platformConfig && (config.platformConfig = this._platformConfig), NativeAnimatedHelper.API.createAnimatedNode(nativeTag, config), this.__shouldUpdateListenersForNewNativeTag = true;
    }
    return nativeTag;
  }
  __getNativeConfig() {
    throw new Error("This JS animated node type cannot be used as native animated node");
  }
  toJSON() {
    return this.__getValue();
  }
  __getPlatformConfig() {
    return this._platformConfig;
  }
  __setPlatformConfig(platformConfig) {
    this._platformConfig = platformConfig;
  }
}
class AnimatedWithChildren extends AnimatedNode {
  constructor() {
    super();
    __publicField(this, "_children");
    this._children = [];
  }
  __makeNative(platformConfig) {
    if (!this.__isNative) {
      this.__isNative = true;
      for (const child of this._children) child.__makeNative(platformConfig), NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
    }
    super.__makeNative(platformConfig);
  }
  __addChild(child) {
    this._children.length === 0 && this.__attach(), this._children.push(child), this.__isNative && (child.__makeNative(this.__getPlatformConfig()), NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag()));
  }
  __removeChild(child) {
    const index2 = this._children.indexOf(child);
    if (index2 === -1) {
      console.warn("Trying to remove a child that doesn't exist");
      return;
    }
    this.__isNative && child.__isNative && NativeAnimatedHelper.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag()), this._children.splice(index2, 1), this._children.length === 0 && this.__detach();
  }
  __getChildren() {
    return this._children;
  }
  __callListeners(value) {
    if (super.__callListeners(value), !this.__isNative) for (const child of this._children) child.__getValue && child.__callListeners(child.__getValue());
  }
}
const linear = (t2) => t2;
function createInterpolation(config) {
  if (config.outputRange && typeof config.outputRange[0] == "string") return createInterpolationFromStringOutputRange(config);
  const outputRange = config.outputRange, inputRange = config.inputRange;
  const easing = config.easing || linear;
  let extrapolateLeft = "extend";
  config.extrapolateLeft !== void 0 ? extrapolateLeft = config.extrapolateLeft : config.extrapolate !== void 0 && (extrapolateLeft = config.extrapolate);
  let extrapolateRight = "extend";
  return config.extrapolateRight !== void 0 ? extrapolateRight = config.extrapolateRight : config.extrapolate !== void 0 && (extrapolateRight = config.extrapolate), (input) => {
    invariant(typeof input == "number", "Cannot interpolation an input which is not a number");
    const range = findRange(input, inputRange);
    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
  };
}
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
  let result = input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity") return result;
    extrapolateLeft === "clamp" && (result = inputMin);
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity") return result;
    extrapolateRight === "clamp" && (result = inputMax);
  }
  return outputMin === outputMax ? outputMin : inputMin === inputMax ? input <= inputMin ? outputMin : outputMax : (inputMin === -1 / 0 ? result = -result : inputMax === 1 / 0 ? result = result - inputMin : result = (result - inputMin) / (inputMax - inputMin), result = easing(result), outputMin === -1 / 0 ? result = -result : outputMax === 1 / 0 ? result = result + outputMin : result = result * (outputMax - outputMin) + outputMin, result);
}
function colorToRgba(input) {
  let normalizedColor = normalizeColor$1(input);
  if (normalizedColor === null || typeof normalizedColor != "number") return input;
  normalizedColor = normalizedColor || 0;
  const r = (normalizedColor & 4278190080) >>> 24, g = (normalizedColor & 16711680) >>> 16, b2 = (normalizedColor & 65280) >>> 8, a = (normalizedColor & 255) / 255;
  return `rgba(${r}, ${g}, ${b2}, ${a})`;
}
const stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
function createInterpolationFromStringOutputRange(config) {
  let outputRange = config.outputRange;
  invariant(outputRange.length >= 2, "Bad output range"), outputRange = outputRange.map(colorToRgba), checkPattern(outputRange);
  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach((value) => {
    value.match(stringShapeRegex).forEach((number, i) => {
      outputRanges[i].push(+number);
    });
  });
  const interpolations = outputRange[0].match(stringShapeRegex).map((value, i) => createInterpolation(__spreadProps(__spreadValues({}, config), {
    outputRange: outputRanges[i]
  }))), shouldRound = isRgbOrRgba(outputRange[0]);
  return (input) => {
    let i = 0;
    return outputRange[0].replace(stringShapeRegex, () => {
      let val = +interpolations[i++](input);
      return shouldRound && (val = i < 4 ? Math.round(val) : Math.round(val * 1e3) / 1e3), String(val);
    });
  };
}
function isRgbOrRgba(range) {
  return typeof range == "string" && range.startsWith("rgb");
}
function checkPattern(arr) {
  const pattern = arr[0].replace(stringShapeRegex, "");
  for (let i = 1; i < arr.length; ++i) invariant(pattern === arr[i].replace(stringShapeRegex, ""), "invalid pattern " + arr[0] + " and " + arr[i]);
}
function findRange(input, inputRange) {
  let i;
  for (i = 1; i < inputRange.length - 1 && !(inputRange[i] >= input); ++i) ;
  return i - 1;
}
const _AnimatedInterpolation = class _AnimatedInterpolation extends AnimatedWithChildren {
  constructor(parent, config) {
    super(), this._parent = parent, this._config = config, this._interpolation = createInterpolation(config);
  }
  __makeNative(platformConfig) {
    this._parent.__makeNative(platformConfig), super.__makeNative(platformConfig);
  }
  __getValue() {
    const parentValue = this._parent.__getValue();
    return invariant(typeof parentValue == "number", "Cannot interpolate an input which is not a number."), this._interpolation(parentValue);
  }
  interpolate(config) {
    return new _AnimatedInterpolation(this, config);
  }
  __attach() {
    this._parent.__addChild(this);
  }
  __detach() {
    this._parent.__removeChild(this), super.__detach();
  }
  __transformDataType(range) {
    return range.map(NativeAnimatedHelper.transformDataType);
  }
  __getNativeConfig() {
    return {
      inputRange: this._config.inputRange,
      // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here
      outputRange: this.__transformDataType(this._config.outputRange),
      extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || "extend",
      extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || "extend",
      type: "interpolation"
    };
  }
};
// Export for testing.
__publicField(_AnimatedInterpolation, "__createInterpolation", createInterpolation);
let AnimatedInterpolation = _AnimatedInterpolation;
const NativeAnimatedAPI = NativeAnimatedHelper.API;
function _flush(rootNode) {
  const animatedStyles = /* @__PURE__ */ new Set();
  function findAnimatedStyles(node) {
    typeof node.update == "function" ? animatedStyles.add(node) : node.__getChildren().forEach(findAnimatedStyles);
  }
  findAnimatedStyles(rootNode), animatedStyles.forEach((animatedStyle) => animatedStyle.update());
}
function _executeAsAnimatedBatch(id2, operation) {
  NativeAnimatedAPI.setWaitingForIdentifier(id2), operation(), NativeAnimatedAPI.unsetWaitingForIdentifier(id2);
}
class AnimatedValue extends AnimatedWithChildren {
  constructor(value, config) {
    super();
    __publicField(this, "_value");
    __publicField(this, "_startingValue");
    __publicField(this, "_offset");
    __publicField(this, "_animation");
    __publicField(this, "_tracking");
    if (typeof value != "number") throw new Error("AnimatedValue: Attempting to set value to undefined");
    this._startingValue = this._value = value, this._offset = 0, this._animation = null, config && config.useNativeDriver && this.__makeNative();
  }
  __detach() {
    this.__isNative && NativeAnimatedAPI.getValue(this.__getNativeTag(), (value) => {
      this._value = value - this._offset;
    }), this.stopAnimation(), super.__detach();
  }
  __getValue() {
    return this._value + this._offset;
  }
  /**
   * Directly set the value.  This will stop any animations running on the value
   * and update all the bound properties.
   *
   * See https://reactnative.dev/docs/animatedvalue#setvalue
   */
  setValue(value) {
    this._animation && (this._animation.stop(), this._animation = null), this._updateValue(
      value,
      !this.__isNative
      /* don't perform a flush for natively driven values */
    ), this.__isNative && _executeAsAnimatedBatch(this.__getNativeTag().toString(), () => NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value));
  }
  /**
   * Sets an offset that is applied on top of whatever value is set, whether via
   * `setValue`, an animation, or `Animated.event`.  Useful for compensating
   * things like the start of a pan gesture.
   *
   * See https://reactnative.dev/docs/animatedvalue#setoffset
   */
  setOffset(offset) {
    this._offset = offset, this.__isNative && NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
  }
  /**
   * Merges the offset value into the base value and resets the offset to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue#flattenoffset
   */
  flattenOffset() {
    this._value += this._offset, this._offset = 0, this.__isNative && NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
  }
  /**
   * Sets the offset value to the base value, and resets the base value to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue#extractoffset
   */
  extractOffset() {
    this._offset += this._value, this._value = 0, this.__isNative && NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
  }
  /**
   * Stops any running animation or tracking. `callback` is invoked with the
   * final value after stopping the animation, which is useful for updating
   * state to match the animation position with layout.
   *
   * See https://reactnative.dev/docs/animatedvalue#stopanimation
   */
  stopAnimation(callback) {
    this.stopTracking(), this._animation && this._animation.stop(), this._animation = null, callback && (this.__isNative ? NativeAnimatedAPI.getValue(this.__getNativeTag(), callback) : callback(this.__getValue()));
  }
  /**
   * Stops any animation and resets the value to its original.
   *
   * See https://reactnative.dev/docs/animatedvalue#resetanimation
   */
  resetAnimation(callback) {
    this.stopAnimation(callback), this._value = this._startingValue, this.__isNative && NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
  }
  __onAnimatedValueUpdateReceived(value) {
    this._updateValue(
      value,
      false
      /*flush*/
    );
  }
  /**
   * Interpolates the value before updating the property, e.g. mapping 0-1 to
   * 0-10.
   */
  interpolate(config) {
    return new AnimatedInterpolation(this, config);
  }
  /**
   * Typically only used internally, but could be used by a custom Animation
   * class.
   *
   * See https://reactnative.dev/docs/animatedvalue#animate
   */
  animate(animation, callback) {
    let handle = null;
    animation.__isInteraction && (handle = InteractionManager.createInteractionHandle());
    const previousAnimation = this._animation;
    this._animation && this._animation.stop(), this._animation = animation, animation.start(this._value, (value) => {
      this._updateValue(
        value,
        true
        /* flush */
      );
    }, (result) => {
      this._animation = null, handle !== null && InteractionManager.clearInteractionHandle(handle), callback && callback(result);
    }, previousAnimation, this);
  }
  /**
   * Typically only used internally.
   */
  stopTracking() {
    this._tracking && this._tracking.__detach(), this._tracking = null;
  }
  /**
   * Typically only used internally.
   */
  track(tracking) {
    this.stopTracking(), this._tracking = tracking, this._tracking && this._tracking.update();
  }
  _updateValue(value, flush) {
    if (value === void 0) throw new Error("AnimatedValue: Attempting to set value to undefined");
    this._value = value, flush && _flush(this), super.__callListeners(this.__getValue());
  }
  __getNativeConfig() {
    return {
      type: "value",
      value: this._value,
      offset: this._offset
    };
  }
}
function attachNativeEvent(viewRef, eventName, argMapping) {
  const eventMappings = [], traverse = (value, path) => {
    if (value instanceof AnimatedValue) value.__makeNative(), eventMappings.push({
      nativeEventPath: path,
      animatedValueTag: value.__getNativeTag()
    });
    else if (typeof value == "object") for (const key in value) traverse(value[key], path.concat(key));
  };
  return invariant(argMapping[0] && argMapping[0].nativeEvent, "Native driven events only support animated values contained inside `nativeEvent`."), traverse(argMapping[0].nativeEvent, []), viewRef != null && eventMappings.forEach((mapping) => {
    NativeAnimatedHelper.API.addAnimatedEventToView(viewRef, eventName, mapping);
  }), {
    detach() {
      viewRef != null && eventMappings.forEach((mapping) => {
        NativeAnimatedHelper.API.removeAnimatedEventFromView(viewRef, eventName, mapping.animatedValueTag);
      });
    }
  };
}
class AnimatedEvent {
  constructor(argMapping, config) {
    __publicField(this, "_argMapping");
    __publicField(this, "_listeners", []);
    __publicField(this, "_attachedEvent");
    __publicField(this, "__isNative");
    this._argMapping = argMapping, config == null && (console.warn("Animated.event now requires a second argument for options"), config = {
      useNativeDriver: false
    }), config.listener && this.__addListener(config.listener), this._callListeners = this._callListeners.bind(this), this._attachedEvent = null, this.__isNative = shouldUseNativeDriver(config);
  }
  __addListener(callback) {
    this._listeners.push(callback);
  }
  __removeListener(callback) {
    this._listeners = this._listeners.filter((listener) => listener !== callback);
  }
  __attach(viewRef, eventName) {
    invariant(this.__isNative, "Only native driven events need to be attached."), this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
  }
  __detach(viewTag, eventName) {
    invariant(this.__isNative, "Only native driven events need to be detached."), this._attachedEvent && this._attachedEvent.detach();
  }
  __getHandler() {
    if (this.__isNative) return this._callListeners;
    return (...args) => {
      const traverse = (recMapping, recEvt, key) => {
        if (recMapping instanceof AnimatedValue) typeof recEvt == "number" && recMapping.setValue(recEvt);
        else if (typeof recMapping == "object") for (const mappingKey in recMapping) traverse(recMapping[mappingKey], recEvt[mappingKey]);
      };
      this._argMapping.forEach((mapping, idx) => {
        traverse(mapping, args[idx]);
      }), this._callListeners(...args);
    };
  }
  _callListeners(...args) {
    this._listeners.forEach((listener) => listener(...args));
  }
}
class AnimatedTransform extends AnimatedWithChildren {
  constructor(transforms) {
    super();
    __publicField(this, "_transforms");
    this._transforms = transforms;
  }
  __makeNative() {
    this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode && value.__makeNative();
      }
    }), super.__makeNative();
  }
  __getValue() {
    return this._transforms.map((transform) => {
      const result = {};
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode ? result[key] = value.__getValue() : result[key] = value;
      }
      return result;
    });
  }
  __getAnimatedValue() {
    return this._transforms.map((transform) => {
      const result = {};
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode ? result[key] = value.__getAnimatedValue() : result[key] = value;
      }
      return result;
    });
  }
  __attach() {
    this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode && value.__addChild(this);
      }
    });
  }
  __detach() {
    this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode && value.__removeChild(this);
      }
    }), super.__detach();
  }
  __getNativeConfig() {
    const transConfigs = [];
    return this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode ? transConfigs.push({
          type: "animated",
          property: key,
          nodeTag: value.__getNativeTag()
        }) : transConfigs.push({
          type: "static",
          property: key,
          value: NativeAnimatedHelper.transformDataType(value)
        });
      }
    }), NativeAnimatedHelper.validateTransform(transConfigs), {
      type: "transform",
      transforms: transConfigs
    };
  }
}
const flattenStyle = StyleSheet.flatten;
function createAnimatedStyle(inputStyle) {
  const style = flattenStyle(inputStyle), animatedStyles = {};
  for (const key in style) {
    const value = style[key];
    key === "transform" && Array.isArray(value) ? animatedStyles[key] = new AnimatedTransform(value) : value instanceof AnimatedNode ? animatedStyles[key] = value : value && !Array.isArray(value) && typeof value == "object" && (animatedStyles[key] = createAnimatedStyle(value));
  }
  return animatedStyles;
}
class AnimatedStyle extends AnimatedWithChildren {
  constructor(style) {
    super();
    __publicField(this, "_inputStyle");
    __publicField(this, "_style");
    this._inputStyle = style, this._style = createAnimatedStyle(style);
  }
  // Recursively get values for nested styles (like iOS's shadowOffset)
  _walkStyleAndGetValues(style) {
    const updatedStyle = {};
    for (const key in style) {
      const value = style[key];
      value instanceof AnimatedNode ? value.__isNative || (updatedStyle[key] = value.__getValue()) : value && !Array.isArray(value) && typeof value == "object" ? updatedStyle[key] = this._walkStyleAndGetValues(value) : updatedStyle[key] = value;
    }
    return updatedStyle;
  }
  __getValue() {
    return [this._inputStyle, this._walkStyleAndGetValues(this._style)];
  }
  // Recursively get animated values for nested styles (like iOS's shadowOffset)
  _walkStyleAndGetAnimatedValues(style) {
    const updatedStyle = {};
    for (const key in style) {
      const value = style[key];
      value instanceof AnimatedNode ? updatedStyle[key] = value.__getAnimatedValue() : value && !Array.isArray(value) && typeof value == "object" && (updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value));
    }
    return updatedStyle;
  }
  __getAnimatedValue() {
    return this._walkStyleAndGetAnimatedValues(this._style);
  }
  __attach() {
    for (const key in this._style) {
      const value = this._style[key];
      value instanceof AnimatedNode && value.__addChild(this);
    }
  }
  __detach() {
    for (const key in this._style) {
      const value = this._style[key];
      value instanceof AnimatedNode && value.__removeChild(this);
    }
    super.__detach();
  }
  __makeNative() {
    for (const key in this._style) {
      const value = this._style[key];
      value instanceof AnimatedNode && value.__makeNative();
    }
    super.__makeNative();
  }
  __getNativeConfig() {
    const styleConfig = {};
    for (const styleKey in this._style) if (this._style[styleKey] instanceof AnimatedNode) {
      const style = this._style[styleKey];
      style.__makeNative(), styleConfig[styleKey] = style.__getNativeTag();
    }
    return NativeAnimatedHelper.validateStyles(styleConfig), {
      type: "style",
      style: styleConfig
    };
  }
}
class AnimatedProps extends AnimatedNode {
  constructor(props, callback) {
    super(), props.style && (props = __spreadProps(__spreadValues({}, props), {
      style: new AnimatedStyle(props.style)
    })), this._props = props, this._callback = callback, this.__attach();
  }
  __getValue() {
    const props = {};
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode ? (!value.__isNative || value instanceof AnimatedStyle) && (props[key] = value.__getValue()) : value instanceof AnimatedEvent ? props[key] = value.__getHandler() : props[key] = value;
    }
    return props;
  }
  __getAnimatedValue() {
    const props = {};
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode && (props[key] = value.__getAnimatedValue());
    }
    return props;
  }
  __attach() {
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode && value.__addChild(this);
    }
  }
  __detach() {
    this.__isNative && this._animatedView && this.__disconnectAnimatedView();
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode && value.__removeChild(this);
    }
    super.__detach();
  }
  update() {
    this._callback();
  }
  __makeNative() {
    if (!this.__isNative) {
      this.__isNative = true;
      for (const key in this._props) {
        const value = this._props[key];
        value instanceof AnimatedNode && value.__makeNative();
      }
      this._animatedView && this.__connectAnimatedView();
    }
  }
  setNativeView(animatedView) {
    this._animatedView !== animatedView && (this._animatedView = animatedView, this.__isNative && this.__connectAnimatedView());
  }
  __connectAnimatedView() {
    invariant(this.__isNative, 'Expected node to be marked as "native"');
    const nativeViewTag = this._animatedView;
    invariant(nativeViewTag != null, "Unable to locate attached view in the native tree"), NativeAnimatedHelper.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
  }
  __disconnectAnimatedView() {
    invariant(this.__isNative, 'Expected node to be marked as "native"');
    const nativeViewTag = this._animatedView;
    invariant(nativeViewTag != null, "Unable to locate attached view in the native tree"), NativeAnimatedHelper.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
  }
  __restoreDefaultValues() {
    this.__isNative && NativeAnimatedHelper.API.restoreDefaultValues(this.__getNativeTag());
  }
  __getNativeConfig() {
    const propsConfig = {};
    for (const propKey in this._props) {
      const value = this._props[propKey];
      value instanceof AnimatedNode && (value.__makeNative(), propsConfig[propKey] = value.__getNativeTag());
    }
    return {
      type: "props",
      props: propsConfig
    };
  }
}
function useRefEffect(effect) {
  const cleanupRef = React.useRef(void 0);
  return React.useCallback((instance) => {
    cleanupRef.current && (cleanupRef.current(), cleanupRef.current = void 0), instance != null && (cleanupRef.current = effect(instance));
  }, [effect]);
}
function useAnimatedProps(props) {
  const [, scheduleUpdate2] = React.useReducer((count) => count + 1, 0), onUpdateRef = React.useRef(null), node = React.useMemo(() => new AnimatedProps(props, () => {
    var _a;
    return (_a = onUpdateRef.current) == null ? void 0 : _a.call(onUpdateRef);
  }), [props]);
  useAnimatedPropsLifecycle(node);
  const refEffect = React.useCallback((instance) => {
    node.setNativeView(instance), onUpdateRef.current = () => {
      scheduleUpdate2();
    };
    const target = getEventTarget(instance), events = [];
    for (const propName in props) {
      const propValue = props[propName];
      propValue instanceof AnimatedEvent && propValue.__isNative && (propValue.__attach(target, propName), events.push([propName, propValue]));
    }
    return () => {
      onUpdateRef.current = null;
      for (const [propName, propValue] of events) propValue.__detach(target, propName);
    };
  }, [props, node]), callbackRef = useRefEffect(refEffect);
  return [reduceAnimatedProps(node), callbackRef];
}
function reduceAnimatedProps(node) {
  return __spreadProps(__spreadValues({}, node.__getValue()), {
    collapsable: false
  });
}
function useAnimatedPropsLifecycle(node) {
  const prevNodeRef = React.useRef(null), isUnmountingRef = React.useRef(false);
  React.useEffect(() => {
  }), useLayoutEffectImpl(() => (isUnmountingRef.current = false, () => {
    isUnmountingRef.current = true;
  }), []), useLayoutEffectImpl(() => {
    if (node.__attach(), prevNodeRef.current != null) {
      const prevNode = prevNodeRef.current;
      prevNode.__restoreDefaultValues(), prevNode.__detach(), prevNodeRef.current = null;
    }
    return () => {
      isUnmountingRef.current ? node.__detach() : prevNodeRef.current = node;
    };
  }, [node]);
}
function getEventTarget(instance) {
  return typeof instance == "object" && typeof (instance == null ? void 0 : instance.getScrollableNode) == "function" ? instance.getScrollableNode() : instance;
}
function useMergeRefs(...refs) {
  return React.useCallback(
    (current) => {
      for (const ref of refs) ref != null && (typeof ref == "function" ? ref(current) : ref.current = current);
    },
    [...refs]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
}
function createAnimatedComponent(Component) {
  return React__namespace.forwardRef((props, forwardedRef) => {
    const [reducedProps, callbackRef] = useAnimatedProps(props), ref = useMergeRefs(callbackRef, forwardedRef), {
      passthroughAnimatedPropExplicitValues,
      style
    } = reducedProps, _a = passthroughAnimatedPropExplicitValues != null ? passthroughAnimatedPropExplicitValues : {}, {
      style: passthroughStyle
    } = _a, passthroughProps = __objRest(_a, [
      "style"
    ]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadProps(__spreadValues(__spreadValues({}, reducedProps), passthroughProps), {
      style: [style, passthroughStyle],
      ref
    }));
  });
}
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}
const deepDiffer = function(one, two, maxDepth = -1) {
  if (maxDepth === 0)
    return true;
  if (one === two || typeof one == "function" && typeof two == "function")
    return false;
  if (typeof one != "object" || one === null)
    return one !== two;
  if (typeof two != "object" || two === null || one.constructor !== two.constructor)
    return true;
  if (Array.isArray(one)) {
    const len = one.length;
    if (two.length !== len)
      return true;
    for (let ii = 0; ii < len; ii++)
      if (deepDiffer(one[ii], two[ii], maxDepth - 1))
        return true;
  } else {
    for (const key in one)
      if (deepDiffer(one[key], two[key], maxDepth - 1))
        return true;
    for (const twoKey in two)
      if (one[twoKey] === void 0 && two[twoKey] !== void 0)
        return true;
  }
  return false;
};
const dimensions$1 = {
  window: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  },
  screen: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  }
}, listeners$2 = {};
let shouldInit$1 = canUseDOM$1;
function update$1() {
  if (!canUseDOM$1)
    return;
  const win = window, docEl = win.document.documentElement;
  dimensions$1.window = {
    fontScale: 1,
    height: docEl.clientHeight,
    scale: win.devicePixelRatio || 1,
    width: docEl.clientWidth
  }, dimensions$1.screen = {
    fontScale: 1,
    height: win.screen.height,
    scale: win.devicePixelRatio || 1,
    width: win.screen.width
  };
}
function handleResize$1() {
  update$1(), Array.isArray(listeners$2.change) && listeners$2.change.forEach((handler) => handler(dimensions$1));
}
let Dimensions$1 = class Dimensions {
  static get(dimension) {
    return shouldInit$1 && (shouldInit$1 = false, update$1()), invariant(dimensions$1[dimension], `No dimension set for key ${dimension}`), dimensions$1[dimension];
  }
  static set(initialDimensions) {
    initialDimensions && (canUseDOM$1 ? invariant(false, "Dimensions cannot be set in the browser") : (initialDimensions.screen != null && (dimensions$1.screen = initialDimensions.screen), initialDimensions.window != null && (dimensions$1.window = initialDimensions.window)));
  }
  static addEventListener(type, handler) {
    return listeners$2[type] = listeners$2[type] || [], listeners$2[type].push(handler), {
      remove: () => {
        this.removeEventListener(type, handler);
      }
    };
  }
  static removeEventListener(type, handler) {
    Array.isArray(listeners$2[type]) && (listeners$2[type] = listeners$2[type].filter((_handler) => _handler !== handler));
  }
};
canUseDOM$1 && window.addEventListener("resize", handleResize$1, false);
const useCreateElement = (component, props, options) => {
  const { element, styles: styles2 } = createElementAndStyles(component, props);
  useDidFinishSSR();
  const styleTags = React.useMemo(
    () => null,
    [
      // never changes
    ]
  );
  return React.useInsertionEffect(() => {
    if (!styles2) return;
    const styleObj = {};
    for (const style of styles2)
      styleObj[style[0]] = style;
  }, [styles2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    element,
    styleTags
  ] });
}, createElement = (component, props, options) => {
  const { element, styles: styles2 } = createElementAndStyles(component, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    element,
    styles2 ? getStyleTags() : null
  ] });
}, createElementAndStyles = (component, props, options) => {
  let accessibilityComponent;
  component && component.constructor === String && (accessibilityComponent = AccessibilityUtil.propsToAccessibilityComponent(props));
  const Component = accessibilityComponent || component, domProps = createDOMProps(Component, props), styles2 = stylesFromProps.get(domProps);
  let element = React.createElement(Component, domProps);
  return {
    element: domProps.dir ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleProvider, { direction: domProps.dir, locale: domProps.lang, children: element }) : element,
    styles: styles2
  };
};
const pickProps$5 = (props) => pick(props, forwardPropsListView), View$3 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const _a = props, {
      hrefAttrs,
      onLayout,
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    } = _a, rest = __objRest(_a, [
      "hrefAttrs",
      "onLayout",
      "onMoveShouldSetResponder",
      "onMoveShouldSetResponderCapture",
      "onResponderEnd",
      "onResponderGrant",
      "onResponderMove",
      "onResponderReject",
      "onResponderRelease",
      "onResponderStart",
      "onResponderTerminate",
      "onResponderTerminationRequest",
      "onScrollShouldSetResponder",
      "onScrollShouldSetResponderCapture",
      "onSelectionChangeShouldSetResponder",
      "onSelectionChangeShouldSetResponderCapture",
      "onStartShouldSetResponder",
      "onStartShouldSetResponderCapture"
    ]);
    const hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), { direction: contextDirection } = useLocaleContext();
    useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    let component = "div";
    const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$5(rest);
    if (supportedProps.dir = componentDirection, supportedProps.style = [styles$h.view, hasTextAncestor && styles$h.inline, props.style], props.href != null && (component = "a", hrefAttrs != null)) {
      const { download, rel, target } = hrefAttrs;
      download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
    }
    const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
    return supportedProps.ref = setRef2, useCreateElement(component, supportedProps);
  }
);
View$3.displayName = "View";
const styles$h = {
  view: {
    alignItems: "stretch",
    boxSizing: "border-box",
    display: "flex",
    flexBasis: "auto",
    flexDirection: "column",
    flexShrink: 0
  },
  inline: {
    display: "inline-flex"
  }
};
function normalizeScrollEvent$1(e2) {
  return {
    nativeEvent: {
      contentOffset: {
        get x() {
          return e2.target.scrollLeft;
        },
        get y() {
          return e2.target.scrollTop;
        }
      },
      contentSize: {
        get height() {
          return e2.target.scrollHeight;
        },
        get width() {
          return e2.target.scrollWidth;
        }
      },
      layoutMeasurement: {
        get height() {
          return e2.target.offsetHeight;
        },
        get width() {
          return e2.target.offsetWidth;
        }
      }
    },
    timeStamp: Date.now()
  };
}
function shouldEmitScrollEvent$1(lastTick, eventThrottle) {
  const timeSinceLastTick = Date.now() - lastTick;
  return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
}
const ScrollViewBase$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    onScroll,
    onTouchMove,
    onWheel,
    scrollEnabled = true,
    scrollEventThrottle = 0,
    showsHorizontalScrollIndicator,
    showsVerticalScrollIndicator,
    style
  } = _a, rest = __objRest(_a, [
    "onScroll",
    "onTouchMove",
    "onWheel",
    "scrollEnabled",
    "scrollEventThrottle",
    "showsHorizontalScrollIndicator",
    "showsVerticalScrollIndicator",
    "style"
  ]), scrollState = React__namespace.useRef({ isScrolling: false, scrollLastTick: 0 }), scrollTimeout = React__namespace.useRef(null), scrollRef = React__namespace.useRef(null);
  function createPreventableScrollHandler(handler) {
    return (e2) => {
      scrollEnabled && handler && handler(e2);
    };
  }
  function handleScroll(e2) {
    e2.stopPropagation(), e2.target === scrollRef.current && (e2.persist(), scrollTimeout.current != null && clearTimeout(scrollTimeout.current), scrollTimeout.current = setTimeout(() => {
      handleScrollEnd(e2);
    }, 100), scrollState.current.isScrolling ? shouldEmitScrollEvent$1(scrollState.current.scrollLastTick, scrollEventThrottle) && handleScrollTick(e2) : handleScrollStart(e2));
  }
  function handleScrollStart(e2) {
    scrollState.current.isScrolling = true, handleScrollTick(e2);
  }
  function handleScrollTick(e2) {
    scrollState.current.scrollLastTick = Date.now(), onScroll && onScroll(normalizeScrollEvent$1(e2));
  }
  function handleScrollEnd(e2) {
    scrollState.current.isScrolling = false, onScroll && onScroll(normalizeScrollEvent$1(e2));
  }
  const hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    View$3,
    __spreadProps(__spreadValues({}, rest), {
      onScroll: handleScroll,
      onTouchMove: createPreventableScrollHandler(onTouchMove),
      onWheel: createPreventableScrollHandler(onWheel),
      ref: useMergeRefs$1(scrollRef, forwardedRef),
      style: [
        style,
        // @ts-ignore
        !scrollEnabled && styles$g.scrollDisabled,
        // @ts-ignore
        hideScrollbar && styles$g.hideScrollbar
      ]
    })
  );
}), styles$g = {
  scrollDisabled: {
    overflowX: "hidden",
    overflowY: "hidden",
    touchAction: "none"
  },
  hideScrollbar: {
    scrollbarWidth: "none"
  }
};
const emptyObject$3 = {}, IS_ANIMATING_TOUCH_START_THRESHOLD_MS$1 = 16;
let ScrollView$1 = class ScrollView extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "_scrollNodeRef");
    __publicField(this, "_innerViewRef");
    __publicField(this, "keyboardWillOpenTo", null);
    __publicField(this, "additionalScrollOffset", 0);
    __publicField(this, "preventNegativeScrollOffset", false);
    __publicField(this, "isTouching", false);
    __publicField(this, "lastMomentumScrollBeginTime", 0);
    __publicField(this, "lastMomentumScrollEndTime", 0);
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    __publicField(this, "observedScrollSinceBecomingResponder", false);
    __publicField(this, "becameResponderWhileAnimating", false);
    __publicField(this, "flashScrollIndicators", () => {
      this.scrollResponderFlashScrollIndicators();
    });
    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollTo", (y, x, animated) => {
      typeof y == "number" ? console.warn(
        "`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead."
      ) : { x, y, animated } = y || emptyObject$3, this.scrollResponderScrollTo({
        x: x || 0,
        y: y || 0,
        animated: animated !== false
      });
    });
    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */
    __publicField(this, "scrollToEnd", (options) => {
      const animated = (options && options.animated) !== false, { horizontal } = this.props, scrollResponderNode = this.getScrollableNode(), x = horizontal ? scrollResponderNode.scrollWidth : 0, y = horizontal ? 0 : scrollResponderNode.scrollHeight;
      this.scrollResponderScrollTo({ x, y, animated });
    });
    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollResponderScrollTo", (x, y, animated) => {
      typeof x == "number" ? console.warn(
        "`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead."
      ) : { x, y, animated } = x || emptyObject$3;
      const node = this.getScrollableNode(), left = x || 0, top = y || 0;
      node != null && (typeof node.scroll == "function" ? node.scroll({ top, left, behavior: animated ? "smooth" : "auto" }) : (node.scrollLeft = left, node.scrollTop = top));
    });
    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */
    __publicField(this, "scrollResponderZoomTo", (rect, animated) => {
      invariant("zoomToRect is not implemented");
    });
    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */
    __publicField(this, "scrollResponderScrollNativeHandleToKeyboard", (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
      this.additionalScrollOffset = additionalOffset || 0, this.preventNegativeScrollOffset = !!preventNegativeScrollOffset, UIManager.measureLayout(
        nodeHandle,
        this.getInnerViewNode(),
        this.scrollResponderTextInputFocusError,
        this.scrollResponderInputMeasureAndScrollToKeyboard
      );
    });
    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */
    __publicField(this, "scrollResponderInputMeasureAndScrollToKeyboard", (left, top, width, height) => {
      let keyboardScreenY = Dimensions$1.get("window").height;
      this.keyboardWillOpenTo && (keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY);
      let scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;
      this.preventNegativeScrollOffset && (scrollOffsetY = Math.max(0, scrollOffsetY)), this.scrollResponderScrollTo({ x: 0, y: scrollOffsetY, animated: true }), this.additionalScrollOffset = 0, this.preventNegativeScrollOffset = false;
    });
    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */
    __publicField(this, "scrollResponderKeyboardWillShow", (e2) => {
      this.keyboardWillOpenTo = e2, this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardWillHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidShow", (e2) => {
      e2 && (this.keyboardWillOpenTo = e2), this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e2);
    });
  }
  /**
   * Returns a reference to the underlying scroll responder, which supports
   * operations like `scrollTo`. All ScrollView-like components should
   * implement this method so that they can be composed while providing access
   * to the underlying scroll responder's methods.
   */
  getScrollResponder() {
    return this;
  }
  getScrollableNode() {
    return this._scrollNodeRef;
  }
  getInnerViewRef() {
    return this._innerViewRef;
  }
  getInnerViewNode() {
    return this._innerViewRef;
  }
  getNativeScrollRef() {
    return this._scrollNodeRef;
  }
  render() {
    const _a = this.props, {
      contentContainerStyle,
      horizontal,
      onContentSizeChange,
      refreshControl,
      stickyHeaderIndices,
      pagingEnabled,
      forwardedRef: forwardedRef,
      keyboardDismissMode,
      onScroll,
      centerContent
    } = _a, other = __objRest(_a, [
      "contentContainerStyle",
      "horizontal",
      "onContentSizeChange",
      "refreshControl",
      "stickyHeaderIndices",
      "pagingEnabled",
      /* eslint-disable */
      "forwardedRef",
      "keyboardDismissMode",
      "onScroll",
      "centerContent"
    ]);
    let contentSizeChangeProps = {};
    onContentSizeChange && (contentSizeChangeProps = {
      onLayout: this._handleContentOnLayout.bind(this)
    });
    const hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices), children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {
      const isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
      return child != null && (isSticky || pagingEnabled) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        View$3,
        {
          style: StyleSheet.compose(
            isSticky && styles$f.stickyHeader,
            pagingEnabled && styles$f.pagingEnabledChild
          ),
          children: child
        }
      ) : child;
    }) : this.props.children, contentContainer = /* @__PURE__ */ jsxRuntimeExports.jsx(
      View$3,
      __spreadProps(__spreadValues({}, contentSizeChangeProps), {
        collapsable: false,
        ref: this._setInnerViewRef.bind(this),
        style: [
          horizontal && styles$f.contentContainerHorizontal,
          centerContent && styles$f.contentContainerCenterContent,
          contentContainerStyle
        ],
        children
      })
    ), baseStyle = horizontal ? styles$f.baseHorizontal : styles$f.baseVertical, pagingEnabledStyle = horizontal ? styles$f.pagingEnabledHorizontal : styles$f.pagingEnabledVertical, props = __spreadProps(__spreadValues({}, other), {
      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
      onTouchStart: this.scrollResponderHandleTouchStart.bind(this),
      onTouchMove: this.scrollResponderHandleTouchMove.bind(this),
      onTouchEnd: this.scrollResponderHandleTouchEnd.bind(this),
      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag.bind(this),
      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag.bind(this),
      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin.bind(this),
      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd.bind(this),
      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder.bind(this),
      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture.bind(this),
      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder.bind(this),
      onScroll: this._handleScroll.bind(this),
      onResponderGrant: this.scrollResponderHandleResponderGrant.bind(this),
      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest.bind(this),
      onResponderRelease: this.scrollResponderHandleResponderRelease.bind(this),
      onResponderReject: this.scrollResponderHandleResponderReject.bind(this),
      onResponderTerminate: this.scrollResponderHandleTerminate.bind(this)
    }), ScrollViewClass = ScrollViewBase$1;
    invariant(ScrollViewClass !== void 0, "ScrollViewClass must not be undefined");
    const scrollView = /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollViewClass, __spreadProps(__spreadValues({}, props), { ref: this._setScrollNodeRef.bind(this), children: contentContainer }));
    return refreshControl ? React.cloneElement(refreshControl, { style: props.style }, scrollView) : scrollView;
  }
  _handleContentOnLayout(e2) {
    var _a, _b;
    const { width, height } = e2.nativeEvent.layout;
    (_b = (_a = this.props).onContentSizeChange) == null ? void 0 : _b.call(_a, width, height);
  }
  _handleScroll(e2) {
    this.props.keyboardDismissMode === "on-drag" && dismissKeyboard(), this.scrollResponderHandleScroll(e2);
  }
  _setInnerViewRef(node) {
    this._innerViewRef = node;
  }
  _setScrollNodeRef(node) {
    this._scrollNodeRef = node, node != null && (node.getScrollResponder = this.getScrollResponder, node.getInnerViewNode = this.getInnerViewNode, node.getInnerViewRef = this.getInnerViewRef, node.getNativeScrollRef = this.getNativeScrollRef, node.getScrollableNode = this.getScrollableNode, node.scrollTo = this.scrollTo, node.scrollToEnd = this.scrollToEnd, node.flashScrollIndicators = this.flashScrollIndicators, node.scrollResponderZoomTo = this.scrollResponderZoomTo, node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard), mergeRefs(this.props.forwardedRef)(node);
  }
  /**
   * Invoke this from an `onScroll` event.
   */
  scrollResponderHandleScrollShouldSetResponder() {
    return this.isTouching;
  }
  /**
   * Merely touch starting is not sufficient for a scroll view to become the
   * responder. Being the "responder" means that the very next touch move/end
   * event will result in an action/movement.
   *
   * Invoke this from an `onStartShouldSetResponder` event.
   *
   * `onStartShouldSetResponder` is used when the next move/end will trigger
   * some UI movement/action, but when you want to yield priority to views
   * nested inside of the view.
   *
   * There may be some cases where scroll views actually should return `true`
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
   * that gives priority to nested views.
   *
   * - If a single tap on the scroll view triggers an action such as
   *   recentering a map style view yet wants to give priority to interaction
   *   views inside (such as dropped pins or labels), then we would return true
   *   from this method when there is a single touch.
   *
   * - Similar to the previous case, if a two finger "tap" should trigger a
   *   zoom, we would check the `touches` count, and if `>= 2`, we would return
   *   true.
   *
   */
  scrollResponderHandleStartShouldSetResponder() {
    return false;
  }
  /**
   * There are times when the scroll view wants to become the responder
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
   * that *doesn't* give priority to nested views (hence the capture phase):
   *
   * - Currently animating.
   * - Tapping anywhere that is not the focused input, while the keyboard is
   *   up (which should dismiss the keyboard).
   *
   * Invoke this from an `onStartShouldSetResponderCapture` event.
   */
  scrollResponderHandleStartShouldSetResponderCapture(e2) {
    return this.scrollResponderIsAnimating();
  }
  /**
   * Invoke this from an `onResponderReject` event.
   *
   * Some other element is not yielding its role as responder. Normally, we'd
   * just disable the `UIScrollView`, but a touch has already began on it, the
   * `UIScrollView` will not accept being disabled after that. The easiest
   * solution for now is to accept the limitation of disallowing this
   * altogether. To improve this, find a way to disable the `UIScrollView` after
   * a touch has already started.
   */
  scrollResponderHandleResponderReject() {
    warning();
  }
  /**
   * We will allow the scroll view to give up its lock iff it acquired the lock
   * during an animation. This is a very useful default that happens to satisfy
   * many common user experiences.
   *
   * - Stop a scroll on the left edge, then turn that into an outer view's
   *   backswipe.
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
   *   view dismiss.
   * - However, without catching the scroll view mid-bounce (while it is
   *   motionless), if you drag far enough for the scroll view to become
   *   responder (and therefore drag the scroll view a bit), any backswipe
   *   navigation of a swipe gesture higher in the view hierarchy, should be
   *   rejected.
   */
  scrollResponderHandleTerminationRequest() {
    return !this.observedScrollSinceBecomingResponder;
  }
  /**
   * Invoke this from an `onTouchEnd` event.
   *
   * @param {SyntheticEvent} e Event.
   */
  scrollResponderHandleTouchEnd(e2) {
    const nativeEvent = e2.nativeEvent;
    this.isTouching = nativeEvent.touches.length !== 0, this.props.onTouchEnd && this.props.onTouchEnd(e2);
  }
  /**
   * Invoke this from an `onResponderRelease` event.
   */
  scrollResponderHandleResponderRelease(e2) {
    this.props.onResponderRelease && this.props.onResponderRelease(e2);
    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
    !this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e2.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating && (this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e2), TextInputState.blurTextInput(currentlyFocusedTextInput));
  }
  scrollResponderHandleScroll(e2) {
    this.observedScrollSinceBecomingResponder = true, this.props.onScroll && this.props.onScroll(e2);
  }
  /**
   * Invoke this from an `onResponderGrant` event.
   */
  scrollResponderHandleResponderGrant(e2) {
    this.observedScrollSinceBecomingResponder = false, this.props.onResponderGrant && this.props.onResponderGrant(e2), this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
  }
  /**
   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
   * animation, and there's not an easy way to distinguish a drag vs. stopping
   * momentum.
   *
   * Invoke this from an `onScrollBeginDrag` event.
   */
  scrollResponderHandleScrollBeginDrag(e2) {
    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e2);
  }
  /**
   * Invoke this from an `onScrollEndDrag` event.
   */
  scrollResponderHandleScrollEndDrag(e2) {
    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollBegin` event.
   */
  scrollResponderHandleMomentumScrollBegin(e2) {
    this.lastMomentumScrollBeginTime = Date.now(), this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollEnd` event.
   */
  scrollResponderHandleMomentumScrollEnd(e2) {
    this.lastMomentumScrollEndTime = Date.now(), this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e2);
  }
  /**
   * Invoke this from an `onTouchStart` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchStart(e2) {
    this.isTouching = true, this.props.onTouchStart && this.props.onTouchStart(e2);
  }
  /**
   * Invoke this from an `onTouchMove` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchMove(e2) {
    this.props.onTouchMove && this.props.onTouchMove(e2);
  }
  scrollResponderHandleTerminate(e2) {
    this.props.onResponderTerminate && this.props.onResponderTerminate(e2);
  }
  /**
   * A helper function for this class that lets us quickly determine if the
   * view is currently animating. This is particularly useful to know when
   * a touch has just started or ended.
   */
  scrollResponderIsAnimating() {
    return Date.now() - this.lastMomentumScrollEndTime < IS_ANIMATING_TOUCH_START_THRESHOLD_MS$1 || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
  }
  /**
   * Displays the scroll indicators momentarily.
   */
  scrollResponderFlashScrollIndicators() {
  }
  scrollResponderTextInputFocusError(e2) {
    console.error("Error measuring text field: ", e2);
  }
};
const commonStyle$1 = {
  flexGrow: 1,
  flexShrink: 1,
  // Enable hardware compositing in modern browsers.
  // Creates a new layer with its own backing surface that can significantly
  // improve scroll performance.
  transform: [{ translateZ: 0 }],
  // iOS native scrolling
  WebkitOverflowScrolling: "touch"
}, styles$f = {
  baseVertical: __spreadProps(__spreadValues({}, commonStyle$1), {
    flexDirection: "column",
    overflowX: "hidden",
    overflowY: "auto"
  }),
  baseHorizontal: __spreadProps(__spreadValues({}, commonStyle$1), {
    flexDirection: "row",
    overflowX: "auto",
    overflowY: "hidden"
  }),
  contentContainerHorizontal: {
    flexDirection: "row"
  },
  contentContainerCenterContent: {
    justifyContent: "center",
    flexGrow: 1
  },
  stickyHeader: {
    position: "sticky",
    top: 0,
    zIndex: 10
  },
  pagingEnabledHorizontal: {
    scrollSnapType: "x mandatory"
  },
  pagingEnabledVertical: {
    scrollSnapType: "y mandatory"
  },
  pagingEnabledChild: {
    scrollSnapAlign: "start"
  }
}, ForwardedScrollView$1 = React.forwardRef((props, forwardedRef) => /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollView$1, __spreadProps(__spreadValues({}, props), { forwardedRef })));
ForwardedScrollView$1.displayName = "ScrollView";
function RefreshControl(props) {
  const _a = props, {
    colors: colors,
    enabled,
    onRefresh,
    progressBackgroundColor,
    progressViewOffset,
    refreshing,
    size,
    tintColor,
    title,
    titleColor
  } = _a, rest = __objRest(_a, [
    /* eslint-disable */
    "colors",
    "enabled",
    "onRefresh",
    "progressBackgroundColor",
    "progressViewOffset",
    "refreshing",
    "size",
    "tintColor",
    "title",
    "titleColor"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$3, __spreadValues({}, rest));
}
class Batchinator {
  constructor(callback, delayMS) {
    __publicField(this, "_callback");
    __publicField(this, "_delay");
    __publicField(this, "_taskHandle");
    this._delay = delayMS, this._callback = callback;
  }
  /*
   * Cleanup any pending tasks.
   *
   * By default, if there is a pending task the callback is run immediately. Set the option abort to
   * true to not call the callback if it was pending.
   */
  dispose(options = { abort: false }) {
    this._taskHandle && (this._taskHandle.cancel(), options.abort || this._callback(), this._taskHandle = null);
  }
  schedule() {
    if (this._taskHandle)
      return;
    const timeoutHandle = setTimeout(() => {
      this._taskHandle = InteractionManager.runAfterInteractions(() => {
        this._taskHandle = null, this._callback();
      });
    }, this._delay);
    this._taskHandle = { cancel: () => clearTimeout(timeoutHandle) };
  }
}
class ChildListCollection {
  constructor() {
    __publicField(this, "_cellKeyToChildren", /* @__PURE__ */ new Map());
    __publicField(this, "_childrenToCellKey", /* @__PURE__ */ new Map());
  }
  add(list, cellKey) {
    var _a;
    invariant(
      !this._childrenToCellKey.has(list),
      "Trying to add already present child list"
    );
    const cellLists = (_a = this._cellKeyToChildren.get(cellKey)) != null ? _a : /* @__PURE__ */ new Set();
    cellLists.add(list), this._cellKeyToChildren.set(cellKey, cellLists), this._childrenToCellKey.set(list, cellKey);
  }
  remove(list) {
    const cellKey = this._childrenToCellKey.get(list);
    invariant(cellKey != null, "Trying to remove non-present child list"), this._childrenToCellKey.delete(list);
    const cellLists = this._cellKeyToChildren.get(cellKey);
    invariant(cellLists, "_cellKeyToChildren should contain cellKey"), cellLists.delete(list), cellLists.size === 0 && this._cellKeyToChildren.delete(cellKey);
  }
  forEach(fn) {
    for (const listSet of this._cellKeyToChildren.values())
      for (const list of listSet)
        fn(list);
  }
  forEachInCell(cellKey, fn) {
    var _a;
    const listSet = (_a = this._cellKeyToChildren.get(cellKey)) != null ? _a : [];
    for (const list of listSet)
      fn(list);
  }
  anyInCell(cellKey, fn) {
    var _a;
    const listSet = (_a = this._cellKeyToChildren.get(cellKey)) != null ? _a : [];
    for (const list of listSet)
      if (fn(list))
        return true;
    return false;
  }
  size() {
    return this._childrenToCellKey.size;
  }
}
class Info {
  constructor() {
    __publicField(this, "any_blank_count", 0);
    __publicField(this, "any_blank_ms", 0);
    __publicField(this, "any_blank_speed_sum", 0);
    __publicField(this, "mostly_blank_count", 0);
    __publicField(this, "mostly_blank_ms", 0);
    __publicField(this, "pixels_blank", 0);
    __publicField(this, "pixels_sampled", 0);
    __publicField(this, "pixels_scrolled", 0);
    __publicField(this, "total_time_spent", 0);
    __publicField(this, "sample_count", 0);
  }
}
let _listeners = [], _minSampleCount = 10, _sampleRate = null;
class FillRateHelper {
  constructor(getFrameMetrics) {
    __publicField(this, "_anyBlankStartTime", null);
    __publicField(this, "_enabled", false);
    __publicField(this, "_getFrameMetrics");
    __publicField(this, "_info", new Info());
    __publicField(this, "_mostlyBlankStartTime", null);
    __publicField(this, "_samplesStartTime", null);
    this._getFrameMetrics = getFrameMetrics, this._enabled = (_sampleRate || 0) > Math.random(), this._resetData();
  }
  static addListener(callback) {
    return _sampleRate === null && console.warn("Call `FillRateHelper.setSampleRate` before `addListener`."), _listeners.push(callback), {
      remove: () => {
        _listeners = _listeners.filter((listener) => callback !== listener);
      }
    };
  }
  static setSampleRate(sampleRate) {
    _sampleRate = sampleRate;
  }
  static setMinSampleCount(minSampleCount) {
    _minSampleCount = minSampleCount;
  }
  activate() {
    this._enabled && this._samplesStartTime == null && (this._samplesStartTime = global.performance.now());
  }
  deactivateAndFlush() {
    if (!this._enabled)
      return;
    const start = this._samplesStartTime;
    if (start == null) {
      return;
    }
    if (this._info.sample_count < _minSampleCount) {
      this._resetData();
      return;
    }
    const total_time_spent = global.performance.now() - start, info = __spreadProps(__spreadValues({}, this._info), {
      total_time_spent
    });
    _listeners.forEach((listener) => listener(info)), this._resetData();
  }
  computeBlankness(props, cellsAroundViewport, scrollMetrics) {
    if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null)
      return 0;
    const { dOffset, offset, velocity, visibleLength } = scrollMetrics;
    this._info.sample_count++, this._info.pixels_sampled += Math.round(visibleLength), this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
    const scrollSpeed = Math.round(Math.abs(velocity) * 1e3), now = global.performance.now();
    this._anyBlankStartTime != null && (this._info.any_blank_ms += now - this._anyBlankStartTime), this._anyBlankStartTime = null, this._mostlyBlankStartTime != null && (this._info.mostly_blank_ms += now - this._mostlyBlankStartTime), this._mostlyBlankStartTime = null;
    let blankTop = 0, first = cellsAroundViewport.first, firstFrame = this._getFrameMetrics(first, props);
    for (; first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout); )
      firstFrame = this._getFrameMetrics(first, props), first++;
    firstFrame && first > 0 && (blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset)));
    let blankBottom = 0, last = cellsAroundViewport.last, lastFrame = this._getFrameMetrics(last, props);
    for (; last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout); )
      lastFrame = this._getFrameMetrics(last, props), last--;
    if (lastFrame && last < props.getItemCount(props.data) - 1) {
      const bottomEdge = lastFrame.offset + lastFrame.length;
      blankBottom = Math.min(
        visibleLength,
        Math.max(0, offset + visibleLength - bottomEdge)
      );
    }
    const pixels_blank = Math.round(blankTop + blankBottom), blankness = pixels_blank / visibleLength;
    return blankness > 0 ? (this._anyBlankStartTime = now, this._info.any_blank_speed_sum += scrollSpeed, this._info.any_blank_count++, this._info.pixels_blank += pixels_blank, blankness > 0.5 && (this._mostlyBlankStartTime = now, this._info.mostly_blank_count++)) : (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) && this.deactivateAndFlush(), blankness;
  }
  enabled() {
    return this._enabled;
  }
  _resetData() {
    this._anyBlankStartTime = null, this._info = new Info(), this._mostlyBlankStartTime = null, this._samplesStartTime = null;
  }
}
class StateSafePureComponent extends React__namespace.PureComponent {
  constructor(props) {
    super(props);
    __publicField(this, "_inAsyncStateUpdate", false);
    this._installSetStateHooks();
  }
  setState(partialState, callback) {
    typeof partialState == "function" ? super.setState((state, props) => {
      this._inAsyncStateUpdate = true;
      let ret;
      try {
        ret = partialState(state, props);
      } catch (err) {
        throw err;
      } finally {
        this._inAsyncStateUpdate = false;
      }
      return ret;
    }, callback) : super.setState(partialState, callback);
  }
  _installSetStateHooks() {
    const that = this;
    let { props, state } = this;
    Object.defineProperty(this, "props", {
      get() {
        return invariant(
          !that._inAsyncStateUpdate,
          '"this.props" should not be accessed during state updates'
        ), props;
      },
      set(newProps) {
        props = newProps;
      }
    }), Object.defineProperty(this, "state", {
      get() {
        return invariant(
          !that._inAsyncStateUpdate,
          '"this.state" should not be acceessed during state updates'
        ), state;
      },
      set(newState) {
        state = newState;
      }
    });
  }
}
class ViewabilityHelper {
  constructor(config = { viewAreaCoveragePercentThreshold: 0 }) {
    __publicField(this, "_config");
    __publicField(this, "_hasInteracted", false);
    __publicField(this, "_timers", /* @__PURE__ */ new Set());
    __publicField(this, "_viewableIndices", []);
    __publicField(this, "_viewableItems", /* @__PURE__ */ new Map());
    this._config = config;
  }
  /**
   * Cleanup, e.g. on unmount. Clears any pending timers.
   */
  dispose() {
    this._timers.forEach(clearTimeout);
  }
  /**
   * Determines which items are viewable based on the current metrics and config.
   */
  computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics, renderRange) {
    const itemCount = props.getItemCount(props.data), { itemVisiblePercentThreshold, viewAreaCoveragePercentThreshold } = this._config, viewAreaMode = viewAreaCoveragePercentThreshold != null, viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
    invariant(
      viewablePercentThreshold != null && itemVisiblePercentThreshold != null != (viewAreaCoveragePercentThreshold != null),
      "Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold"
    );
    const viewableIndices = [];
    if (itemCount === 0)
      return viewableIndices;
    let firstVisible = -1;
    const { first, last } = renderRange || { first: 0, last: itemCount - 1 };
    if (last >= itemCount)
      return console.warn(
        "Invalid render range computing viewability " + JSON.stringify({ renderRange, itemCount })
      ), [];
    for (let idx = first; idx <= last; idx++) {
      const metrics = getFrameMetrics(idx, props);
      if (!metrics)
        continue;
      const top = metrics.offset - scrollOffset, bottom = top + metrics.length;
      if (top < viewportHeight && bottom > 0)
        firstVisible = idx, _isViewable(
          viewAreaMode,
          viewablePercentThreshold,
          top,
          bottom,
          viewportHeight,
          metrics.length
        ) && viewableIndices.push(idx);
      else if (firstVisible >= 0)
        break;
    }
    return viewableIndices;
  }
  /**
   * Figures out which items are viewable and how that has changed from before and calls
   * `onViewableItemsChanged` as appropriate.
   */
  onUpdate(props, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged, renderRange) {
    const itemCount = props.getItemCount(props.data);
    if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0, props))
      return;
    let viewableIndices = [];
    if (itemCount && (viewableIndices = this.computeViewableItems(
      props,
      scrollOffset,
      viewportHeight,
      getFrameMetrics,
      renderRange
    )), !(this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every((v, ii) => v === viewableIndices[ii])))
      if (this._viewableIndices = viewableIndices, this._config.minimumViewTime) {
        const handle = setTimeout(() => {
          this._timers.delete(handle), this._onUpdateSync(
            props,
            viewableIndices,
            onViewableItemsChanged,
            createViewToken
          );
        }, this._config.minimumViewTime);
        this._timers.add(handle);
      } else
        this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
  }
  resetViewableIndices() {
    this._viewableIndices = [];
  }
  recordInteraction() {
    this._hasInteracted = true;
  }
  _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
    viewableIndicesToCheck = viewableIndicesToCheck.filter(
      (ii) => this._viewableIndices.includes(ii)
    );
    const prevItems = this._viewableItems, nextItems = new Map(
      viewableIndicesToCheck.map((ii) => {
        const viewable = createViewToken(ii, true, props);
        return [viewable.key, viewable];
      })
    ), changed = [];
    for (const [key, viewable] of nextItems)
      prevItems.has(key) || changed.push(viewable);
    for (const [key, viewable] of prevItems)
      nextItems.has(key) || changed.push(__spreadProps(__spreadValues({}, viewable), { isViewable: false }));
    changed.length > 0 && (this._viewableItems = nextItems, onViewableItemsChanged({
      viewableItems: Array.from(nextItems.values()),
      changed
    }));
  }
}
function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
  if (_isEntirelyVisible(top, bottom, viewportHeight))
    return true;
  {
    const pixels = _getPixelsVisible(top, bottom, viewportHeight);
    return 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength) >= viewablePercentThreshold;
  }
}
function _getPixelsVisible(top, bottom, viewportHeight) {
  const visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
  return Math.max(0, visibleHeight);
}
function _isEntirelyVisible(top, bottom, viewportHeight) {
  return top >= 0 && bottom <= viewportHeight && bottom > top;
}
const VirtualizedListContext = React__namespace.createContext(null);
function VirtualizedListCellContextProvider({ cellKey, children }) {
  const currContext = React.useContext(VirtualizedListContext), context = React.useMemo(
    () => currContext == null ? null : __spreadProps(__spreadValues({}, currContext), { cellKey }),
    [currContext, cellKey]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualizedListContext.Provider, { value: context, children });
}
class CellRenderer extends React__namespace.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      separatorProps: {
        highlighted: false,
        leadingItem: this.props.item
      }
    });
    // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
    // reused by SectionList and we can keep VirtualizedList simpler.
    // $FlowFixMe[missing-local-annot]
    __publicField(this, "_separators", {
      highlight: () => {
        var _a, _b;
        const { cellKey, prevCellKey } = this.props;
        (_b = (_a = this.props).onUpdateSeparators) == null ? void 0 : _b.call(_a, [cellKey, prevCellKey], {
          highlighted: true
        });
      },
      unhighlight: () => {
        var _a, _b;
        const { cellKey, prevCellKey } = this.props;
        (_b = (_a = this.props).onUpdateSeparators) == null ? void 0 : _b.call(_a, [cellKey, prevCellKey], {
          highlighted: false
        });
      },
      updateProps: (select, newProps) => {
        var _a, _b;
        const { cellKey, prevCellKey } = this.props;
        (_b = (_a = this.props).onUpdateSeparators) == null ? void 0 : _b.call(
          _a,
          [select === "leading" ? prevCellKey : cellKey],
          newProps
        );
      }
    });
    __publicField(this, "_onLayout", (nativeEvent) => {
      var _a, _b;
      (_b = (_a = this.props).onCellLayout) == null ? void 0 : _b.call(_a, nativeEvent, this.props.cellKey, this.props.index);
    });
  }
  static getDerivedStateFromProps(props, prevState) {
    return {
      separatorProps: __spreadProps(__spreadValues({}, prevState.separatorProps), {
        leadingItem: props.item
      })
    };
  }
  updateSeparatorProps(newProps) {
    this.setState((state) => ({
      separatorProps: __spreadValues(__spreadValues({}, state.separatorProps), newProps)
    }));
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).onUnmount) == null ? void 0 : _b.call(_a, this.props.cellKey);
  }
  _renderElement(renderItem, ListItemComponent, item, index2) {
    if (renderItem && ListItemComponent && console.warn(
      "VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take precedence over renderItem."
    ), ListItemComponent)
      return React__namespace.createElement(ListItemComponent, {
        item,
        index: index2,
        separators: this._separators
      });
    if (renderItem)
      return renderItem({
        item,
        index: index2,
        separators: this._separators
      });
    invariant(
      false,
      "VirtualizedList: Either ListItemComponent or renderItem props are required but none were found."
    );
  }
  render() {
    const {
      CellRendererComponent,
      ItemSeparatorComponent,
      ListItemComponent,
      cellKey,
      horizontal,
      item,
      index: index2,
      inversionStyle,
      onCellFocusCapture,
      onCellLayout,
      renderItem
    } = this.props, element = this._renderElement(renderItem, ListItemComponent, item, index2), itemSeparator = React__namespace.isValidElement(ItemSeparatorComponent) ? (
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent
    ) : (
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(ItemSeparatorComponent, __spreadValues({}, this.state.separatorProps))
    ), cellStyle = inversionStyle ? horizontal ? [styles$e.rowReverse, inversionStyle] : [styles$e.columnReverse, inversionStyle] : horizontal ? [styles$e.row, inversionStyle] : inversionStyle, result = CellRendererComponent ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      CellRendererComponent,
      __spreadProps(__spreadValues({
        cellKey,
        index: index2,
        item,
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && { onLayout: this._onLayout }), {
        children: [
          element,
          itemSeparator
        ]
      })
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View$3,
      __spreadProps(__spreadValues({
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && { onLayout: this._onLayout }), {
        children: [
          element,
          itemSeparator
        ]
      })
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualizedListCellContextProvider, { cellKey: this.props.cellKey, children: result });
  }
}
const styles$e = StyleSheet.create({
  row: {
    flexDirection: "row"
  },
  rowReverse: {
    flexDirection: "row-reverse"
  },
  columnReverse: {
    flexDirection: "column-reverse"
  }
});
function horizontalOrDefault(horizontal) {
  return horizontal != null ? horizontal : false;
}
function scrollEventThrottleOrDefault(scrollEventThrottle) {
  return scrollEventThrottle != null ? scrollEventThrottle : 50;
}
class VirtualizedList extends StateSafePureComponent {
  constructor(props) {
    var _a;
    super(props);
    __publicField(this, "_captureRef", (ref) => {
      this._scrollRef = ref;
    });
    __publicField(this, "_onContentSizeChange", (width, height) => {
    });
    __publicField(this, "_onLayout", (event) => {
    });
    __publicField(this, "_onScroll", (event) => {
    });
    this._nestedChildLists = new ChildListCollection(), this._viewabilityTuples = [], this._scrollMetrics = {
      contentLength: 0,
      dOffset: 0,
      dt: 10,
      offset: 0,
      timestamp: 0,
      velocity: 0,
      visibleLength: 0
    }, this._highestMeasuredFrameIndex = 0, this._headerLength = 0, this._footerLength = 0, this._averageCellLength = 0, this._hasWarned = {}, this._fillRateHelper = new FillRateHelper(this._getFrameMetrics), this._updateCellsToRenderBatcher = new Batchinator(
      this._updateCellsToRender,
      (_a = this.props.updateCellsBatchingPeriod) != null ? _a : 50
    ), this.props.viewabilityConfig && this.props.onViewableItemsChanged && this._viewabilityTuples.push({
      viewabilityHelper: new ViewabilityHelper(this.props.viewabilityConfig),
      onViewableItemsChanged: this.props.onViewableItemsChanged
    });
  }
  scrollToEnd(params) {
    const animated = params ? params.animated : true, veryLast = this.props.getItemCount(this.props.data) - 1;
    if (veryLast < 0)
      return;
    const frame = this.__getFrameMetricsApprox(veryLast, this.props), offset = Math.max(
      0,
      frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength
    );
    if (this._scrollRef != null) {
      if (this._scrollRef.scrollTo == null) {
        console.warn(
          "No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo."
        );
        return;
      }
      this._scrollRef.scrollTo(
        horizontalOrDefault(this.props.horizontal) ? { x: offset, animated } : { y: offset, animated }
      );
    }
  }
  scrollToIndex(params) {
    const {
      data,
      horizontal,
      getItemCount,
      getItemLayout,
      onScrollToIndexFailed
    } = this.props, { animated, index: index2, viewOffset, viewPosition } = params;
    if (invariant(
      index2 >= 0,
      `scrollToIndex out of range: requested index ${index2} but minimum is 0`
    ), invariant(
      getItemCount(data) >= 1,
      `scrollToIndex out of range: item length ${getItemCount(
        data
      )} but minimum is 1`
    ), invariant(
      index2 < getItemCount(data),
      `scrollToIndex out of range: requested index ${index2} is out of 0 to ${getItemCount(data) - 1}`
    ), !getItemLayout && index2 > this._highestMeasuredFrameIndex) {
      invariant(
        !!onScrollToIndexFailed,
        "scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, otherwise there is no way to know the location of offscreen indices or handle failures."
      ), onScrollToIndexFailed({
        averageItemLength: this._averageCellLength,
        highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
        index: index2
      });
      return;
    }
    const frame = this.__getFrameMetricsApprox(Math.floor(index2), this.props), offset = Math.max(
      0,
      this._getOffsetApprox(index2, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)
    ) - (viewOffset || 0);
    this._scrollRef != null && this._scrollRef.scrollTo(
      horizontalOrDefault(horizontal) ? { x: offset, animated } : { y: offset, animated }
    );
  }
  scrollToItem(params) {
    const { data, getItem, getItemCount, horizontal, onScrollToIndexFailed } = this.props, { animated, item, viewPosition, viewOffset } = params, index2 = this.props.data.indexOf(item);
    if (index2 !== -1)
      this.scrollToIndex({
        animated,
        index: index2,
        viewOffset,
        viewPosition
      });
    else {
      const itemCount = getItemCount(data);
      for (let i = 0; i < itemCount; i++)
        if (getItem(data, i) === item) {
          this.scrollToIndex({
            animated,
            index: i,
            viewOffset,
            viewPosition
          });
          break;
        }
    }
  }
  scrollToOffset(params) {
    const { animated, offset } = params;
    this._scrollRef != null && this._scrollRef.scrollTo(
      horizontalOrDefault(this.props.horizontal) ? { x: offset, animated } : { y: offset, animated }
    );
  }
  recordInteraction() {
    this._nestedChildLists.forEach((childList) => {
      childList.recordInteraction();
    }), this._viewabilityTuples.forEach((viewabilityTuple) => {
      viewabilityTuple.viewabilityHelper.recordInteraction();
    });
  }
  flashScrollIndicators() {
    this._scrollRef && this._scrollRef.flashScrollIndicators && this._scrollRef.flashScrollIndicators();
  }
  getScrollResponder() {
    if (this._scrollRef && this._scrollRef.getScrollResponder)
      return this._scrollRef.getScrollResponder();
  }
  getScrollableNode() {
    if (this._scrollRef && this._scrollRef.getScrollableNode)
      return this._scrollRef.getScrollableNode();
  }
  getScrollRef() {
    return this._scrollRef;
  }
  setNativeProps(props) {
    this._scrollRef && this._scrollRef.setNativeProps(props);
  }
  render() {
    const _a = this.props, {
      ListEmptyComponent,
      ListFooterComponent,
      ListHeaderComponent,
      data,
      debug,
      disableVirtualization,
      getItem,
      getItemCount,
      getItemLayout,
      horizontal,
      keyExtractor: keyExtractor2,
      numColumns,
      onEndReached,
      onEndReachedThreshold,
      onLayout,
      onRefresh,
      onScroll,
      onScrollBeginDrag,
      onScrollEndDrag,
      onMomentumScrollBegin,
      onMomentumScrollEnd,
      onStartReached,
      onStartReachedThreshold,
      onViewableItemsChanged,
      refreshing,
      removeClippedSubviews,
      renderItem,
      viewabilityConfig,
      viewabilityConfigCallbackPairs
    } = _a, restProps = __objRest(_a, [
      "ListEmptyComponent",
      "ListFooterComponent",
      "ListHeaderComponent",
      "data",
      "debug",
      "disableVirtualization",
      "getItem",
      "getItemCount",
      "getItemLayout",
      "horizontal",
      "keyExtractor",
      "numColumns",
      "onEndReached",
      "onEndReachedThreshold",
      "onLayout",
      "onRefresh",
      "onScroll",
      "onScrollBeginDrag",
      "onScrollEndDrag",
      "onMomentumScrollBegin",
      "onMomentumScrollEnd",
      "onStartReached",
      "onStartReachedThreshold",
      "onViewableItemsChanged",
      "refreshing",
      "removeClippedSubviews",
      "renderItem",
      "viewabilityConfig",
      "viewabilityConfigCallbackPairs"
    ]);
    return getItemCount(data) === 0 ? ListEmptyComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(ListEmptyComponent, {}) : null : /* @__PURE__ */ jsxRuntimeExports.jsx(
      ForwardedScrollView$1,
      __spreadProps(__spreadValues({}, restProps), {
        ref: this._captureRef,
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout,
        onScroll: this._onScroll,
        refreshControl: onRefresh && /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshControl, { refreshing, onRefresh }),
        scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
        removeClippedSubviews,
        children: this._renderChildren()
      })
    );
  }
  _renderChildren() {
    const { data, getItem, getItemCount, renderItem } = this.props, items = [];
    for (let i = 0; i < getItemCount(data); i++) {
      const item = getItem(data, i);
      items.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CellRenderer,
          {
            cellKey: String(i),
            index: i,
            item,
            renderItem
          },
          this.props.keyExtractor ? this.props.keyExtractor(item, i) : i
        )
      );
    }
    return items;
  }
  __getFrameMetricsApprox(index2, props) {
    return {
      length: this._averageCellLength,
      offset: this._averageCellLength * index2
    };
  }
  _getOffsetApprox(index2, props) {
    return this.__getFrameMetricsApprox(index2, props).offset;
  }
}
__publicField(VirtualizedList, "contextType", VirtualizedListContext);
function keyExtractor(item, index2) {
  return typeof item == "object" && (item == null ? void 0 : item.key) != null ? item.key : typeof item == "object" && (item == null ? void 0 : item.id) != null ? item.id : String(index2);
}
function removeClippedSubviewsOrDefault(removeClippedSubviews) {
  return removeClippedSubviews != null ? removeClippedSubviews : Platform.OS === "android";
}
function numColumnsOrDefault(numColumns) {
  return numColumns != null ? numColumns : 1;
}
function isArrayLike(data) {
  return typeof Object(data).length == "number";
}
class FlatList extends React.PureComponent {
  constructor(props) {
    super(props);
    __publicField(this, "props");
    __publicField(this, "_listRef", null);
    __publicField(this, "_virtualizedListPairs", []);
    __publicField(this, "_captureRef", (ref) => {
      this._listRef = ref;
    });
    __publicField(this, "_getItem", (data, index2) => {
      const numColumns = numColumnsOrDefault(this.props.numColumns);
      if (numColumns > 1) {
        const ret = [];
        for (let kk = 0; kk < numColumns; kk++) {
          const itemIndex = index2 * numColumns + kk;
          if (itemIndex < data.length) {
            const item = data[itemIndex];
            ret.push(item);
          }
        }
        return ret;
      } else return data[index2];
    });
    __publicField(this, "_getItemCount", (data) => {
      if (data != null && isArrayLike(data)) {
        const numColumns = numColumnsOrDefault(this.props.numColumns);
        return numColumns > 1 ? Math.ceil(data.length / numColumns) : data.length;
      } else return 0;
    });
    __publicField(this, "_keyExtractor", (items, index2) => {
      var _a;
      const numColumns = numColumnsOrDefault(this.props.numColumns), keyExtractor$1 = (_a = this.props.keyExtractor) != null ? _a : keyExtractor;
      return numColumns > 1 ? (invariant(Array.isArray(items), "FlatList: Expected each item to be an array with multiple columns."), items.map((item, kk) => keyExtractor$1(item, index2 * numColumns + kk)).join(":")) : keyExtractor$1(items, index2);
    });
    __publicField(this, "_renderer", (ListItemComponent, renderItem, columnWrapperStyle, numColumns, extraData) => {
      const cols = numColumnsOrDefault(numColumns), render = (props) => ListItemComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemComponent, __spreadValues({}, props)) : renderItem ? renderItem(props) : null, renderProp = (info) => {
        if (cols > 1) {
          const {
            item,
            index: index2
          } = info;
          return invariant(Array.isArray(item), "Expected array of items with numColumns > 1"), /* @__PURE__ */ jsxRuntimeExports.jsx(View$3, {
            style: [styles$d.row, columnWrapperStyle],
            children: item.map((it, kk) => {
              const element = render({
                item: it,
                index: index2 * cols + kk,
                separators: info.separators
              });
              return element != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
                children: element
              }, kk) : null;
            })
          });
        } else return render(info);
      };
      return ListItemComponent ? {
        ListItemComponent: renderProp
      } : {
        renderItem: renderProp
      };
    });
    __publicField(this, "_memoizedRenderer", memoizeOne(this._renderer));
    this.props = props, this._checkProps(this.props), this.props.viewabilityConfigCallbackPairs ? this._virtualizedListPairs = this.props.viewabilityConfigCallbackPairs.map((pair) => ({
      viewabilityConfig: pair.viewabilityConfig,
      onViewableItemsChanged: this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
    })) : this.props.onViewableItemsChanged && this._virtualizedListPairs.push({
      viewabilityConfig: this.props.viewabilityConfig,
      onViewableItemsChanged: this._createOnViewableItemsChanged(this.props.onViewableItemsChanged)
    });
  }
  componentDidUpdate(prevProps) {
    invariant(prevProps.numColumns === this.props.numColumns, "Changing numColumns on the fly is not supported. Change the key prop on FlatList when changing the number of columns to force a fresh render of the component."), invariant(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, "Changing onViewableItemsChanged on the fly is not supported"), invariant(!deepDiffer(prevProps.viewabilityConfig, this.props.viewabilityConfig), "Changing viewabilityConfig on the fly is not supported"), invariant(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, "Changing viewabilityConfigCallbackPairs on the fly is not supported"), this._checkProps(this.props);
  }
  _checkProps(props) {
    const {
      getItem,
      getItemCount,
      horizontal,
      columnWrapperStyle,
      onViewableItemsChanged,
      viewabilityConfigCallbackPairs
    } = props, numColumns = numColumnsOrDefault(this.props.numColumns);
    invariant(!getItem && !getItemCount, "FlatList does not support custom data formats."), numColumns > 1 ? invariant(!horizontal, "numColumns does not support horizontal.") : invariant(!columnWrapperStyle, "columnWrapperStyle not supported for single column lists"), invariant(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), "FlatList does not support setting both onViewableItemsChanged and viewabilityConfigCallbackPairs.");
  }
  _pushMultiColumnViewable(arr, v) {
    var _a;
    const numColumns = numColumnsOrDefault(this.props.numColumns), keyExtractor$1 = (_a = this.props.keyExtractor) != null ? _a : keyExtractor;
    v.item.forEach((item, ii) => {
      invariant(v.index != null, "Missing index!");
      const index2 = v.index * numColumns + ii;
      arr.push(__spreadProps(__spreadValues({}, v), {
        item,
        key: keyExtractor$1(item, index2),
        index: index2
      }));
    });
  }
  _createOnViewableItemsChanged(onViewableItemsChanged) {
    return (info) => {
      const numColumns = numColumnsOrDefault(this.props.numColumns);
      if (onViewableItemsChanged) if (numColumns > 1) {
        const changed = [], viewableItems = [];
        info.viewableItems.forEach((v) => this._pushMultiColumnViewable(viewableItems, v)), info.changed.forEach((v) => this._pushMultiColumnViewable(changed, v)), onViewableItemsChanged({
          viewableItems,
          changed
        });
      } else onViewableItemsChanged(info);
    };
  }
  render() {
    const _a = this.props, {
      numColumns,
      columnWrapperStyle,
      removeClippedSubviews: _removeClippedSubviews,
      strictMode = false
    } = _a, restProps = __objRest(_a, [
      "numColumns",
      "columnWrapperStyle",
      "removeClippedSubviews",
      "strictMode"
    ]), renderer = strictMode ? this._memoizedRenderer : this._renderer;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualizedList, __spreadValues(__spreadProps(__spreadValues({}, restProps), {
      getItem: this._getItem,
      getItemCount: this._getItemCount,
      keyExtractor: this._keyExtractor,
      ref: this._captureRef,
      viewabilityConfigCallbackPairs: this._virtualizedListPairs,
      removeClippedSubviews: removeClippedSubviewsOrDefault(_removeClippedSubviews)
    }), renderer(this.props.ListItemComponent, this.props.renderItem, columnWrapperStyle, numColumns, this.props.extraData)));
  }
}
const styles$d = {
  row: {
    flexDirection: "row"
  }
};
const FlatListWithEventThrottle = React__namespace.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(FlatList, __spreadProps(__spreadValues({
  scrollEventThrottle: 1e-4
}, props), {
  ref
})));
createAnimatedComponent(FlatListWithEventThrottle);
let PixelRatio$1 = class PixelRatio {
  /**
   * Returns the device pixel density.
   */
  static get() {
    return Dimensions$1.get("window").scale;
  }
  /**
   * No equivalent for Web
   */
  static getFontScale() {
    return Dimensions$1.get("window").fontScale || PixelRatio.get();
  }
  /**
   * Converts a layout size (dp) to pixel size (px).
   * Guaranteed to return an integer number.
   */
  static getPixelSizeForLayoutSize(layoutSize) {
    return Math.round(layoutSize * PixelRatio.get());
  }
  /**
   * Rounds a layout size (dp) to the nearest layout size that corresponds to
   * an integer number of pixels. For example, on a device with a PixelRatio
   * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
   * exactly (8.33 * 3) = 25 pixels.
   */
  static roundToNearestPixel(layoutSize) {
    const ratio = PixelRatio.get();
    return Math.round(layoutSize * ratio) / ratio;
  }
};
const ERRORED$1 = "ERRORED", LOADED$1 = "LOADED", LOADING$1 = "LOADING", IDLE$1 = "IDLE";
let _filterId$1 = 0;
const svgDataUriPattern$1 = /^(data:image\/svg\+xml;utf8,)(.*)/;
function createTintColorSVG$1(tintColor, id2) {
  return tintColor && id2 != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      style: {
        position: "absolute",
        height: 0,
        visibility: "hidden",
        width: 0
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: `tint-${id2}`, suppressHydrationWarning: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { floodColor: `${tintColor}` }, tintColor),
        /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", { in2: "SourceAlpha", operator: "atop" })
      ] }) })
    }
  ) : null;
}
function getFlatStyle$1(style, blurRadius, filterId) {
  const flatStyle = StyleSheet.flatten(style), { filter, resizeMode, shadowOffset, tintColor } = flatStyle, filters = [];
  let _filter = null;
  if (filter && filters.push(filter), blurRadius && filters.push(`blur(${blurRadius}px)`), shadowOffset) {
    const shadowString = createBoxShadowValue(flatStyle);
    shadowString && filters.push(`drop-shadow(${shadowString})`);
  }
  return tintColor && filterId != null && filters.push(`url(#tint-${filterId})`), filters.length > 0 && (_filter = filters.join(" ")), delete flatStyle.blurRadius, delete flatStyle.shadowColor, delete flatStyle.shadowOpacity, delete flatStyle.shadowOffset, delete flatStyle.shadowRadius, delete flatStyle.tintColor, delete flatStyle.overlayColor, delete flatStyle.resizeMode, [flatStyle, resizeMode, _filter, tintColor];
}
function resolveAssetDimensions$1(source) {
  if (typeof source == "number") {
    const { height, width } = getAssetByID(source);
    return { height, width };
  } else if (source != null && !Array.isArray(source) && typeof source == "object") {
    const { height, width } = source;
    return { height, width };
  }
}
function resolveAssetUri$1(source) {
  let uri = null;
  if (typeof source == "number") {
    const asset = getAssetByID(source);
    let scale = asset.scales[0];
    if (asset.scales.length > 1) {
      const preferredScale = PixelRatio$1.get();
      scale = asset.scales.reduce(
        (prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev
      );
    }
    const scaleSuffix = scale !== 1 ? `@${scale}x` : "";
    uri = asset ? `${asset.httpServerLocation}/${asset.name}${scaleSuffix}.${asset.type}` : "";
  } else typeof source == "string" ? uri = source : source && typeof source.uri == "string" && (uri = source.uri);
  if (uri) {
    const match = uri.match(svgDataUriPattern$1);
    if (match) {
      const [, prefix, svg] = match, encodedSvg = encodeURIComponent(svg);
      return `${prefix}${encodedSvg}`;
    }
  }
  return uri;
}
const Image$1 = React__namespace.forwardRef((props, ref) => {
  const _a = props, {
    accessibilityLabel,
    blurRadius,
    defaultSource,
    draggable,
    onError,
    onLayout,
    onLoad,
    onLoadEnd,
    onLoadStart,
    pointerEvents,
    source,
    style
  } = _a, rest = __objRest(_a, [
    "accessibilityLabel",
    "blurRadius",
    "defaultSource",
    "draggable",
    "onError",
    "onLayout",
    "onLoad",
    "onLoadEnd",
    "onLoadStart",
    "pointerEvents",
    "source",
    "style"
  ]);
  const [state, updateState] = React__namespace.useState(() => {
    const uri2 = resolveAssetUri$1(source);
    return uri2 != null && ImageLoader.has(uri2) ? LOADED$1 : IDLE$1;
  }), [layout, updateLayout] = React__namespace.useState({}), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hiddenImageRef = React__namespace.useRef(null), filterRef = React__namespace.useRef(_filterId$1++), requestRef = React__namespace.useRef(null), shouldDisplaySource = state === LOADED$1 || state === LOADING$1 && defaultSource == null, [flatStyle, _resizeMode, filter, tintColor] = getFlatStyle$1(
    {},
    blurRadius,
    filterRef.current
  ), resizeMode = props.resizeMode || _resizeMode || "cover", selectedSource = shouldDisplaySource ? source : defaultSource, displayImageUri = resolveAssetUri$1(selectedSource), imageSizeStyle = resolveAssetDimensions$1(selectedSource), backgroundImage = displayImageUri ? `url("${displayImageUri}")` : null, backgroundSize = getBackgroundSize(), hiddenImage = displayImageUri ? createElement("img", {
    alt: accessibilityLabel || "",
    style: styles$c.accessibilityImage$raw,
    draggable: draggable || false,
    ref: hiddenImageRef,
    src: displayImageUri
  }) : null;
  function getBackgroundSize() {
    if (hiddenImageRef.current != null && (resizeMode === "center" || resizeMode === "repeat")) {
      const { naturalHeight, naturalWidth } = hiddenImageRef.current, { height, width } = layout;
      if (naturalHeight && naturalWidth && height && width) {
        const scaleFactor = Math.min(1, width / naturalWidth, height / naturalHeight), x = Math.ceil(scaleFactor * naturalWidth), y = Math.ceil(scaleFactor * naturalHeight);
        return `${x}px ${y}px`;
      }
    }
  }
  function handleLayout(e2) {
    if (resizeMode === "center" || resizeMode === "repeat" || onLayout) {
      const { layout: layout2 } = e2.nativeEvent;
      onLayout && onLayout(e2), updateLayout(layout2);
    }
  }
  const uri = resolveAssetUri$1(source);
  return React__namespace.useEffect(() => {
    abortPendingRequest(), uri != null && (updateState(LOADING$1), onLoadStart && onLoadStart(), requestRef.current = ImageLoader.load(
      uri,
      function(e2) {
        updateState(LOADED$1), onLoad && onLoad(e2), onLoadEnd && onLoadEnd();
      },
      function() {
        updateState(ERRORED$1), onError && onError({
          nativeEvent: {
            error: `Failed to load resource ${uri} (404)`
          }
        }), onLoadEnd && onLoadEnd();
      }
    ));
    function abortPendingRequest() {
      requestRef.current != null && (ImageLoader.abort(requestRef.current), requestRef.current = null);
    }
    return abortPendingRequest;
  }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]), /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View$3,
    __spreadProps(__spreadValues({}, rest), {
      accessibilityLabel,
      onLayout: handleLayout,
      pointerEvents,
      ref,
      style: [
        style,
        styles$c.root,
        hasTextAncestor && styles$c.inline,
        imageSizeStyle,
        flatStyle
      ],
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          View$3,
          {
            style: [
              ...[].concat(styles$c.image),
              resizeModeStyles$1[resizeMode],
              { backgroundImage, filter },
              backgroundSize != null && { backgroundSize }
            ],
            suppressHydrationWarning: true
          }
        ),
        hiddenImage,
        createTintColorSVG$1(tintColor, filterRef.current)
      ]
    })
  );
});
Image$1.displayName = "Image";
const ImageWithStatics$1 = Image$1;
ImageWithStatics$1.getSize = function(uri, success, failure) {
  ImageLoader.getSize(uri, success, failure);
};
ImageWithStatics$1.prefetch = function(uri) {
  return ImageLoader.prefetch(uri);
};
ImageWithStatics$1.queryCache = function(uris) {
  return ImageLoader.queryCache(uris);
};
const styles$c = StyleSheet.create({
  root: {
    flexBasis: "auto",
    overflow: "hidden",
    zIndex: 0
  },
  inline: {
    display: "inline-flex"
  },
  image: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    backgroundColor: "transparent",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    backgroundSize: "cover",
    height: "100%",
    width: "100%",
    zIndex: -1
  }),
  accessibilityImage$raw: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    height: "100%",
    opacity: 0,
    width: "100%",
    zIndex: -1
  })
}), resizeModeStyles$1 = StyleSheet.create({
  center: {
    backgroundSize: "auto"
  },
  contain: {
    backgroundSize: "contain"
  },
  cover: {
    backgroundSize: "cover"
  },
  none: {
    backgroundPosition: "0",
    backgroundSize: "auto"
  },
  repeat: {
    backgroundPosition: "0",
    backgroundRepeat: "repeat",
    backgroundSize: "auto"
  },
  stretch: {
    backgroundSize: "100% 100%"
  }
});
createAnimatedComponent(ImageWithStatics$1);
const ScrollViewWithEventThrottle = React__namespace.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(ForwardedScrollView$1, __spreadProps(__spreadValues({
  scrollEventThrottle: 1e-4
}, props), {
  ref
})));
createAnimatedComponent(ScrollViewWithEventThrottle);
const defaultProps = {
  data: [],
  key: null,
  renderItem: null,
  ItemSeparatorComponent: null,
  keyExtractor: null
};
class VirtualizedSectionList extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_keyExtractor", (item, index2) => (this.props.keyExtractor || this._defaultKeyExtractor)(item, index2));
    __publicField(this, "_defaultKeyExtractor", (item, index2) => item.key != null ? item.key : String(index2));
    __publicField(this, "_captureRef", (ref) => {
      this._listRef = ref;
    });
    __publicField(this, "_renderItem", (itemCount) => ({ item, index: index2 }) => index2 === 0 || index2 === itemCount - 1 ? null : (this.props.renderItem || this._defaultRenderItem)({ item, index: index2, section: item }));
    __publicField(this, "_defaultRenderItem", ({ item }) => null);
    __publicField(this, "_onViewableItemsChanged", (info) => {
      this.props.onViewableItemsChanged && this.props.onViewableItemsChanged(info);
    });
  }
  scrollToLocation(params) {
    let index2 = params.itemIndex;
    for (let i = 0; i < params.sectionIndex; i++)
      index2 += this.props.getItemCount(this.props.sections[i].data) + 2;
    let viewOffset = params.viewOffset || 0;
    if (this._listRef == null)
      return;
    if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
      const frame = this._listRef.__getFrameMetricsApprox(
        index2 - params.itemIndex,
        this._listRef.props
      );
      viewOffset += frame.length;
    }
    const toIndexParams = __spreadProps(__spreadValues({}, params), {
      viewOffset,
      index: index2
    });
    this._listRef.scrollToIndex(toIndexParams);
  }
  getListRef() {
    return this._listRef;
  }
  render() {
    const _a = this.props, {
      ItemSeparatorComponent,
      SectionSeparatorComponent,
      renderItem: _renderItem,
      renderSectionFooter,
      renderSectionHeader,
      sections: _sections,
      stickySectionHeadersEnabled
    } = _a, passThroughProps = __objRest(_a, [
      "ItemSeparatorComponent",
      "SectionSeparatorComponent",
      "renderItem",
      "renderSectionFooter",
      "renderSectionHeader",
      "sections",
      "stickySectionHeadersEnabled"
    ]), listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0, stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : void 0;
    let itemCount = 0;
    for (const section of this.props.sections)
      stickyHeaderIndices == null ? void 0 : stickyHeaderIndices.push(itemCount + listHeaderOffset), itemCount += 2, itemCount += this.props.getItemCount(section.data);
    const renderItem = this._renderItem(itemCount);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VirtualizedList,
      __spreadProps(__spreadValues({}, passThroughProps), {
        keyExtractor: this._keyExtractor,
        stickyHeaderIndices,
        renderItem,
        data: this.props.sections,
        getItem: (sections, index2) => this._getItem(this.props, sections, index2),
        getItemCount: () => itemCount,
        onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : void 0,
        ref: this._captureRef
      })
    );
  }
  _getItem(props, sections, index2) {
    if (!sections)
      return null;
    let itemIdx = index2 - 1;
    for (let i = 0; i < sections.length; i++) {
      const section = sections[i], sectionData = section.data, itemCount = props.getItemCount(sectionData);
      if (itemIdx === -1 || itemIdx === itemCount)
        return section;
      if (itemIdx < itemCount)
        return props.getItem(sectionData, itemIdx);
      itemIdx -= itemCount + 2;
    }
    return null;
  }
}
VirtualizedSectionList.defaultProps = defaultProps;
class SectionList extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_captureRef", (ref) => {
      this._wrapperListRef = ref;
    });
    __publicField(this, "_getItem", (sections, index2) => {
      if (!sections)
        return null;
      const section = sections[index2];
      return section && section.data ? section.data[0] : null;
    });
    __publicField(this, "_getItemCount", (sections) => sections ? sections.length : 0);
    __publicField(this, "_keyExtractor", (item, index2) => (this.props.keyExtractor || this._defaultKeyExtractor)(item, index2));
    __publicField(this, "_defaultKeyExtractor", (item, index2) => item.key != null ? item.key : String(index2));
    __publicField(this, "_renderItem", ({ item, index: index2, section }) => (this.props.renderItem || this._defaultRenderItem)({ item, index: index2, section }));
    __publicField(this, "_defaultRenderItem", ({ item }) => null);
  }
  scrollToLocation(params) {
    this._wrapperListRef != null && this._wrapperListRef.scrollToLocation(params);
  }
  recordInteraction() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    listRef && listRef.recordInteraction();
  }
  flashScrollIndicators() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    listRef && listRef.flashScrollIndicators();
  }
  getScrollResponder() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    if (listRef)
      return listRef.getScrollResponder();
  }
  getScrollableNode() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    if (listRef)
      return listRef.getScrollableNode();
  }
  setNativeProps(props) {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    listRef && listRef.setNativeProps(props);
  }
  render() {
    const _a = this.props, { sections } = _a, passThroughProps = __objRest(_a, ["sections"]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VirtualizedSectionList,
      __spreadProps(__spreadValues({}, passThroughProps), {
        sections,
        ref: this._captureRef,
        getItem: this._getItem,
        getItemCount: this._getItemCount,
        keyExtractor: this._keyExtractor,
        renderItem: this._renderItem
      })
    );
  }
}
var SectionList_default = SectionList;
const SectionListWithEventThrottle = React__namespace.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(SectionList_default, __spreadProps(__spreadValues({
  scrollEventThrottle: 1e-4
}, props), {
  ref
})));
createAnimatedComponent(SectionListWithEventThrottle);
const pickProps$4 = (props) => pick(props, forwardPropsListText), Text$3 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const _a = props, {
      hrefAttrs,
      numberOfLines,
      onClick,
      onLayout,
      onPress,
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture,
      selectable
    } = _a, rest = __objRest(_a, [
      "hrefAttrs",
      "numberOfLines",
      "onClick",
      "onLayout",
      "onPress",
      "onMoveShouldSetResponder",
      "onMoveShouldSetResponderCapture",
      "onResponderEnd",
      "onResponderGrant",
      "onResponderMove",
      "onResponderReject",
      "onResponderRelease",
      "onResponderStart",
      "onResponderTerminate",
      "onResponderTerminationRequest",
      "onScrollShouldSetResponder",
      "onScrollShouldSetResponderCapture",
      "onSelectionChangeShouldSetResponder",
      "onSelectionChangeShouldSetResponderCapture",
      "onStartShouldSetResponder",
      "onStartShouldSetResponderCapture",
      "selectable"
    ]), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), { direction: contextDirection } = useLocaleContext();
    useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    const handleClick = React__namespace.useCallback(
      (e2) => {
        onClick != null ? onClick(e2) : onPress != null && (e2.stopPropagation(), onPress(e2));
      },
      [onClick, onPress]
    );
    let component = hasTextAncestor ? "span" : "div";
    const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$4(rest);
    if (supportedProps.dir = componentDirection, hasTextAncestor || (supportedProps.dir = componentDirection != null ? componentDirection : "auto"), (onClick || onPress) && (supportedProps.onClick = handleClick), supportedProps.style = [
      numberOfLines != null && numberOfLines > 1 && { WebkitLineClamp: numberOfLines },
      hasTextAncestor === true ? styles$b.textHasAncestor$raw : styles$b.text,
      numberOfLines === 1 && styles$b.textOneLine,
      numberOfLines != null && numberOfLines > 1 && styles$b.textMultiLine,
      props.style,
      selectable === true && styles$b.selectable,
      selectable === false && styles$b.notSelectable,
      onPress && styles$b.pressable
    ], props.href != null && (component = "a", hrefAttrs != null)) {
      const { download, rel, target } = hrefAttrs;
      download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
    }
    const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef2;
    const element = useCreateElement(component, supportedProps);
    return hasTextAncestor ? element : /* @__PURE__ */ jsxRuntimeExports.jsx(TextAncestorContext.Provider, { value: true, children: element });
  }
);
Text$3.displayName = "Text";
const textStyle$1 = {
  backgroundColor: "transparent",
  border: "0 solid black",
  boxSizing: "border-box",
  color: "black",
  display: "inline",
  font: "14px System",
  listStyle: "none",
  margin: 0,
  padding: 0,
  textAlign: "inherit",
  textDecoration: "none",
  whiteSpace: "pre-wrap",
  wordWrap: "break-word"
}, styles$b = {
  text: textStyle$1,
  textHasAncestor$raw: __spreadProps(__spreadValues({}, textStyle$1), {
    color: "inherit",
    font: "inherit",
    whiteSpace: "inherit"
  }),
  textOneLine: {
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  },
  // See #13
  textMultiLine: {
    display: "-webkit-box",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    WebkitBoxOrient: "vertical"
  },
  notSelectable: {
    userSelect: "none"
  },
  selectable: {
    userSelect: "text"
  },
  pressable: {
    cursor: "pointer"
  }
};
createAnimatedComponent(Text$3);
createAnimatedComponent(View$3);
canUseDOM$1 && typeof window.matchMedia == "function" ? window.matchMedia("(prefers-reduced-motion: reduce)") : null;
function getQuery() {
  return canUseDOM$1 && window.matchMedia != null ? window.matchMedia("(prefers-color-scheme: dark)") : null;
}
const query = getQuery(), listenerMapping = /* @__PURE__ */ new WeakMap(), Appearance = {
  getColorScheme() {
    return query && query.matches ? "dark" : "light";
  },
  addChangeListener(listener) {
    let mappedListener = listenerMapping.get(listener);
    mappedListener || (mappedListener = ({
      matches
    }) => {
      listener({
        colorScheme: matches ? "dark" : "light"
      });
    }, listenerMapping.set(listener, mappedListener)), query && query.addListener(mappedListener);
    function remove() {
      const mappedListener2 = listenerMapping.get(listener);
      query && mappedListener2 && query.removeListener(mappedListener2), listenerMapping.delete(listener);
    }
    return {
      remove
    };
  }
};
var reactDom = { exports: {} };
var reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production;
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var React$1 = React;
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i = 2; i < arguments.length; i++)
        url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function noop() {
  }
  var Internals = {
    d: {
      f: noop,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children,
      containerInfo,
      implementation
    };
  }
  var ReactSharedInternals = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as, input) {
    if ("font" === as) return "";
    if ("string" === typeof input)
      return "use-credentials" === input ? input : "";
  }
  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  reactDom_production.createPortal = function(children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
      throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  reactDom_production.flushSync = function(fn) {
    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  reactDom_production.preconnect = function(href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  reactDom_production.prefetchDNS = function(href) {
    "string" === typeof href && Internals.d.D(href);
  };
  reactDom_production.preinit = function(href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as ? Internals.d.S(
        href,
        "string" === typeof options.precedence ? options.precedence : void 0,
        {
          crossOrigin,
          integrity,
          fetchPriority
        }
      ) : "script" === as && Internals.d.X(href, {
        crossOrigin,
        integrity,
        fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  reactDom_production.preinitModule = function(href, options) {
    if ("string" === typeof href)
      if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          );
          Internals.d.M(href, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      } else null == options && Internals.d.M(href);
  };
  reactDom_production.preload = function(href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
      Internals.d.L(href, as, {
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  reactDom_production.preloadModule = function(href, options) {
    if ("string" === typeof href)
      if (options) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        });
      } else Internals.d.m(href);
  };
  reactDom_production.requestFormReset = function(form) {
    Internals.d.r(form);
  };
  reactDom_production.unstable_batchedUpdates = function(fn, a) {
    return fn(a);
  };
  reactDom_production.useFormState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action, initialState, permalink);
  };
  reactDom_production.useFormStatus = function() {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  reactDom_production.version = "19.1.0";
  return reactDom_production;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production();
  }
  return reactDom.exports;
}
requireReactDom();
const pickProps$3 = (props) => pick(props, forwardPropsListView), View$2 = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    hrefAttrs,
    onLayout,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } = _a, rest = __objRest(_a, [
    "hrefAttrs",
    "onLayout",
    "onMoveShouldSetResponder",
    "onMoveShouldSetResponderCapture",
    "onResponderEnd",
    "onResponderGrant",
    "onResponderMove",
    "onResponderReject",
    "onResponderRelease",
    "onResponderStart",
    "onResponderTerminate",
    "onResponderTerminationRequest",
    "onScrollShouldSetResponder",
    "onScrollShouldSetResponderCapture",
    "onSelectionChangeShouldSetResponder",
    "onSelectionChangeShouldSetResponderCapture",
    "onStartShouldSetResponder",
    "onStartShouldSetResponderCapture"
  ]);
  const hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), {
    direction: contextDirection
  } = useLocaleContext();
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  let component = "div";
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$3(rest);
  if (supportedProps.dir = componentDirection, supportedProps.style = [styles$a.view, hasTextAncestor && styles$a.inline, props.style], props.href != null && (component = "a", hrefAttrs != null)) {
    const {
      download,
      rel,
      target
    } = hrefAttrs;
    download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
  }
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
  return supportedProps.ref = setRef2, useCreateElement$1(component, supportedProps);
});
View$2.displayName = "View";
const styles$a = {
  view: {
    alignItems: "stretch",
    boxSizing: "border-box",
    display: "flex",
    flexBasis: "auto",
    flexDirection: "column",
    flexShrink: 0
  },
  inline: {
    display: "inline-flex"
  }
};
const RootTagContext = React__namespace.createContext(null), AppContainer = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    children,
    WrapperComponent
  } = props;
  let innerView = /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, {
    pointerEvents: "box-none",
    style: styles$9.appContainer,
    children
  }, 1);
  return WrapperComponent && (innerView = /* @__PURE__ */ jsxRuntimeExports.jsx(WrapperComponent, {
    children: innerView
  })), /* @__PURE__ */ jsxRuntimeExports.jsx(RootTagContext.Provider, {
    value: props.rootTag,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, {
      pointerEvents: "box-none",
      ref: forwardedRef,
      style: styles$9.appContainer,
      children: innerView
    })
  });
});
AppContainer.displayName = "AppContainer";
const styles$9 = StyleSheet.create({
  appContainer: {
    flex: 1
  }
});
canUseDOM$1 && !document.hasOwnProperty("hidden") && document.hasOwnProperty("webkitHidden");
const dimensions = {
  window: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  },
  screen: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  }
}, listeners$1 = {};
let shouldInit = canUseDOM$1;
function update() {
  if (!canUseDOM$1) return;
  const win = window, docEl = win.document.documentElement;
  dimensions.window = {
    fontScale: 1,
    height: docEl.clientHeight,
    scale: win.devicePixelRatio || 1,
    width: docEl.clientWidth
  }, dimensions.screen = {
    fontScale: 1,
    height: win.screen.height,
    scale: win.devicePixelRatio || 1,
    width: win.screen.width
  };
}
function handleResize() {
  update(), Array.isArray(listeners$1.change) && listeners$1.change.forEach((handler) => handler(dimensions));
}
class Dimensions2 {
  static get(dimension) {
    return shouldInit && (shouldInit = false, update()), invariant(dimensions[dimension], `No dimension set for key ${dimension}`), dimensions[dimension];
  }
  static set(initialDimensions) {
    initialDimensions && (canUseDOM$1 ? invariant(false, "Dimensions cannot be set in the browser") : (initialDimensions.screen != null && (dimensions.screen = initialDimensions.screen), initialDimensions.window != null && (dimensions.window = initialDimensions.window)));
  }
  static addEventListener(type, handler) {
    return listeners$1[type] = listeners$1[type] || [], listeners$1[type].push(handler), {
      remove: () => {
        this.removeEventListener(type, handler);
      }
    };
  }
  static removeEventListener(type, handler) {
    Array.isArray(listeners$1[type]) && (listeners$1[type] = listeners$1[type].filter((_handler) => _handler !== handler));
  }
}
canUseDOM$1 && window.addEventListener("resize", handleResize, false);
class PixelRatio2 {
  /**
   * Returns the device pixel density.
   */
  static get() {
    return Dimensions2.get("window").scale;
  }
  /**
   * No equivalent for Web
   */
  static getFontScale() {
    return Dimensions2.get("window").fontScale || PixelRatio2.get();
  }
  /**
   * Converts a layout size (dp) to pixel size (px).
   * Guaranteed to return an integer number.
   */
  static getPixelSizeForLayoutSize(layoutSize) {
    return Math.round(layoutSize * PixelRatio2.get());
  }
  /**
   * Rounds a layout size (dp) to the nearest layout size that corresponds to
   * an integer number of pixels. For example, on a device with a PixelRatio
   * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
   * exactly (8.33 * 3) = 25 pixels.
   */
  static roundToNearestPixel(layoutSize) {
    const ratio = PixelRatio2.get();
    return Math.round(layoutSize * ratio) / ratio;
  }
}
class UnimplementedView extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "setNativeProps", () => {
    });
  }
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadValues({}, this.props));
  }
}
function TouchableOpacityImpl(props, forwardedRef) {
  const _a = props, {
    activeOpacity,
    delayPressIn,
    delayPressOut,
    delayLongPress,
    disabled,
    focusable,
    onLongPress,
    onPress,
    onPressIn,
    onPressOut,
    rejectResponderTermination,
    style
  } = _a, rest = __objRest(_a, [
    "activeOpacity",
    "delayPressIn",
    "delayPressOut",
    "delayLongPress",
    "disabled",
    "focusable",
    "onLongPress",
    "onPress",
    "onPressIn",
    "onPressOut",
    "rejectResponderTermination",
    "style"
  ]), hostRef = React.useRef(null), setRef2 = useMergeRefs$1(forwardedRef, hostRef), [duration, setDuration] = React.useState("0s"), [opacityOverride, setOpacityOverride] = React.useState(null), setOpacityTo = React.useCallback((value, duration2) => {
    setOpacityOverride(value), setDuration(duration2 ? `${duration2 / 1e3}s` : "0s");
  }, [setOpacityOverride, setDuration]), setOpacityActive = React.useCallback((duration2) => {
    setOpacityTo(activeOpacity != null ? activeOpacity : 0.2, duration2);
  }, [activeOpacity, setOpacityTo]), setOpacityInactive = React.useCallback((duration2) => {
    setOpacityTo(null, duration2);
  }, [setOpacityTo]), pressConfig = React.useMemo(() => ({
    cancelable: !rejectResponderTermination,
    disabled,
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    onLongPress,
    onPress,
    onPressStart(event) {
      const isGrant = event.dispatchConfig != null ? event.dispatchConfig.registrationName === "onResponderGrant" : event.type === "keydown";
      setOpacityActive(isGrant ? 0 : 150), onPressIn == null ? void 0 : onPressIn(event);
    },
    onPressEnd(event) {
      setOpacityInactive(250), onPressOut == null ? void 0 : onPressOut(event);
    }
  }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, setOpacityActive, setOpacityInactive]), pressEventHandlers = usePressEvents(hostRef, pressConfig);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$3, __spreadProps(__spreadValues(__spreadValues({}, rest), pressEventHandlers), {
    accessibilityDisabled: disabled,
    focusable: !disabled && focusable !== false,
    ref: setRef2,
    style: [styles$8.root, !disabled && styles$8.actionable, style, opacityOverride != null && {
      opacity: opacityOverride
    }, {
      transitionDuration: duration
    }]
  }));
}
const styles$8 = StyleSheet.create({
  root: {
    transitionProperty: "opacity",
    transitionDuration: "0.15s",
    userSelect: "none"
  },
  actionable: {
    cursor: "pointer",
    touchAction: "manipulation"
  }
}), TouchableOpacity = React__namespace.memo(React__namespace.forwardRef(TouchableOpacityImpl));
TouchableOpacity.displayName = "TouchableOpacity";
TouchableOpacity.Mixin = {};
const forwardPropsList$1 = {
  accessibilityDisabled: true,
  accessibilityLabel: true,
  accessibilityLiveRegion: true,
  accessibilityRole: true,
  accessibilityState: true,
  accessibilityValue: true,
  children: true,
  disabled: true,
  focusable: true,
  nativeID: true,
  onBlur: true,
  onFocus: true,
  onLayout: true,
  testID: true
}, pickProps$2 = (props) => pick(props, forwardPropsList$1);
function TouchableWithoutFeedbackImpl(props, forwardedRef) {
  const {
    delayPressIn,
    delayPressOut,
    delayLongPress,
    disabled,
    focusable,
    onLongPress,
    onPress,
    onPressIn,
    onPressOut,
    rejectResponderTermination
  } = props, hostRef = React.useRef(null), pressConfig = React.useMemo(() => ({
    cancelable: !rejectResponderTermination,
    disabled,
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    onLongPress,
    onPress,
    onPressStart: onPressIn,
    onPressEnd: onPressOut
  }), [disabled, delayPressIn, delayPressOut, delayLongPress, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination]), pressEventHandlers = usePressEvents(hostRef, pressConfig), element = React__namespace.Children.only(props.children), children = [element.props.children], supportedProps = pickProps$2(props);
  supportedProps.accessibilityDisabled = disabled, supportedProps.focusable = !disabled && focusable !== false, supportedProps.ref = useMergeRefs$1(forwardedRef, hostRef, element.ref);
  const elementProps = Object.assign(supportedProps, pressEventHandlers);
  return React__namespace.cloneElement(element, elementProps, ...children);
}
const TouchableWithoutFeedback = React__namespace.memo(React__namespace.forwardRef(TouchableWithoutFeedbackImpl));
TouchableWithoutFeedback.displayName = "TouchableWithoutFeedback";
const createSvgCircle = (style) => /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
  cx: "16",
  cy: "16",
  fill: "none",
  r: "14",
  strokeWidth: "4",
  style
}), ActivityIndicator = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    animating = true,
    color = "#1976D2",
    hidesWhenStopped = true,
    size = "small",
    style
  } = _a, other = __objRest(_a, [
    "animating",
    "color",
    "hidesWhenStopped",
    "size",
    "style"
  ]), svg = /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
    height: "100%",
    viewBox: "0 0 32 32",
    width: "100%",
    children: [createSvgCircle({
      stroke: color,
      opacity: 0.2
    }), createSvgCircle({
      stroke: color,
      strokeDasharray: 80,
      strokeDashoffset: 60
    })]
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadProps(__spreadValues({}, other), {
    accessibilityRole: "progressbar",
    accessibilityValueMax: 1,
    accessibilityValueMin: 0,
    ref: forwardedRef,
    style: [styles$7.container, style],
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, {
      children: svg,
      style: [typeof size == "number" ? {
        height: size,
        width: size
      } : indicatorSizes[size], styles$7.animation, !animating && styles$7.animationPause, !animating && hidesWhenStopped && styles$7.hidesWhenStopped]
    })
  }));
});
ActivityIndicator.displayName = "ActivityIndicator";
const styles$7 = StyleSheet.create({
  container: {
    alignItems: "center",
    justifyContent: "center"
  },
  hidesWhenStopped: {
    visibility: "hidden"
  },
  animation: {
    animationDuration: "0.75s",
    animationKeyframes: [{
      "0%": {
        transform: [{
          rotate: "0deg"
        }]
      },
      "100%": {
        transform: [{
          rotate: "360deg"
        }]
      }
    }],
    animationTimingFunction: "linear",
    animationIterationCount: "infinite"
  },
  animationPause: {
    animationPlayState: "paused"
  }
}), indicatorSizes = StyleSheet.create({
  small: {
    width: 20,
    height: 20
  },
  large: {
    width: 36,
    height: 36
  }
});
const ERRORED = "ERRORED", LOADED = "LOADED", LOADING = "LOADING", IDLE = "IDLE";
let _filterId = 0;
const svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;
function createTintColorSVG(tintColor, id2) {
  return tintColor && id2 != null ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", {
    style: {
      position: "absolute",
      height: 0,
      visibility: "hidden",
      width: 0
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("defs", {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", {
        id: `tint-${id2}`,
        suppressHydrationWarning: true,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", {
          floodColor: `${tintColor}`
        }, tintColor), /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", {
          in2: "SourceAlpha",
          operator: "atop"
        })]
      })
    })
  }) : null;
}
function getFlatStyle(style, blurRadius, filterId) {
  const flatStyle = StyleSheet.flatten(style), {
    filter,
    resizeMode,
    shadowOffset,
    tintColor
  } = flatStyle, filters = [];
  let _filter = null;
  if (filter && filters.push(filter), blurRadius && filters.push(`blur(${blurRadius}px)`), shadowOffset) {
    const shadowString = createBoxShadowValue(flatStyle);
    shadowString && filters.push(`drop-shadow(${shadowString})`);
  }
  return tintColor && filterId != null && filters.push(`url(#tint-${filterId})`), filters.length > 0 && (_filter = filters.join(" ")), delete flatStyle.blurRadius, delete flatStyle.shadowColor, delete flatStyle.shadowOpacity, delete flatStyle.shadowOffset, delete flatStyle.shadowRadius, delete flatStyle.tintColor, delete flatStyle.overlayColor, delete flatStyle.resizeMode, [flatStyle, resizeMode, _filter, tintColor];
}
function resolveAssetDimensions(source) {
  if (typeof source == "number") {
    const {
      height,
      width
    } = getAssetByID(source);
    return {
      height,
      width
    };
  } else if (source != null && !Array.isArray(source) && typeof source == "object") {
    const {
      height,
      width
    } = source;
    return {
      height,
      width
    };
  }
}
function resolveAssetUri(source) {
  let uri = null;
  if (typeof source == "number") {
    const asset = getAssetByID(source);
    let scale = asset.scales[0];
    if (asset.scales.length > 1) {
      const preferredScale = PixelRatio2.get();
      scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
    }
    const scaleSuffix = scale !== 1 ? `@${scale}x` : "";
    uri = asset ? `${asset.httpServerLocation}/${asset.name}${scaleSuffix}.${asset.type}` : "";
  } else typeof source == "string" ? uri = source : source && typeof source.uri == "string" && (uri = source.uri);
  if (uri) {
    const match = uri.match(svgDataUriPattern);
    if (match) {
      const [, prefix, svg] = match, encodedSvg = encodeURIComponent(svg);
      return `${prefix}${encodedSvg}`;
    }
  }
  return uri;
}
const Image = React__namespace.forwardRef((props, ref) => {
  const _a = props, {
    accessibilityLabel,
    blurRadius,
    defaultSource,
    draggable,
    onError,
    onLayout,
    onLoad,
    onLoadEnd,
    onLoadStart,
    pointerEvents,
    source,
    style
  } = _a, rest = __objRest(_a, [
    "accessibilityLabel",
    "blurRadius",
    "defaultSource",
    "draggable",
    "onError",
    "onLayout",
    "onLoad",
    "onLoadEnd",
    "onLoadStart",
    "pointerEvents",
    "source",
    "style"
  ]);
  const [state, updateState] = React__namespace.useState(() => {
    const uri2 = resolveAssetUri(source);
    return uri2 != null && ImageLoader.has(uri2) ? LOADED : IDLE;
  }), [layout, updateLayout] = React__namespace.useState({}), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hiddenImageRef = React__namespace.useRef(null), filterRef = React__namespace.useRef(_filterId++), requestRef = React__namespace.useRef(null), shouldDisplaySource = state === LOADED || state === LOADING && defaultSource == null, [flatStyle, _resizeMode, filter, tintColor] = getFlatStyle({}, blurRadius, filterRef.current), resizeMode = props.resizeMode || _resizeMode || "cover", selectedSource = shouldDisplaySource ? source : defaultSource, displayImageUri = resolveAssetUri(selectedSource), imageSizeStyle = resolveAssetDimensions(selectedSource), backgroundImage = displayImageUri ? `url("${displayImageUri}")` : null, backgroundSize = getBackgroundSize(), hiddenImage = displayImageUri ? createElement$1("img", {
    alt: accessibilityLabel || "",
    style: styles$6.accessibilityImage$raw,
    draggable: draggable || false,
    ref: hiddenImageRef,
    src: displayImageUri
  }) : null;
  function getBackgroundSize() {
    if (hiddenImageRef.current != null && (resizeMode === "center" || resizeMode === "repeat")) {
      const {
        naturalHeight,
        naturalWidth
      } = hiddenImageRef.current, {
        height,
        width
      } = layout;
      if (naturalHeight && naturalWidth && height && width) {
        const scaleFactor = Math.min(1, width / naturalWidth, height / naturalHeight), x = Math.ceil(scaleFactor * naturalWidth), y = Math.ceil(scaleFactor * naturalHeight);
        return `${x}px ${y}px`;
      }
    }
  }
  function handleLayout(e2) {
    if (resizeMode === "center" || resizeMode === "repeat" || onLayout) {
      const {
        layout: layout2
      } = e2.nativeEvent;
      onLayout && onLayout(e2), updateLayout(layout2);
    }
  }
  const uri = resolveAssetUri(source);
  return React__namespace.useEffect(() => {
    abortPendingRequest(), uri != null && (updateState(LOADING), onLoadStart && onLoadStart(), requestRef.current = ImageLoader.load(uri, function(e2) {
      updateState(LOADED), onLoad && onLoad(e2), onLoadEnd && onLoadEnd();
    }, function() {
      updateState(ERRORED), onError && onError({
        nativeEvent: {
          error: `Failed to load resource ${uri} (404)`
        }
      }), onLoadEnd && onLoadEnd();
    }));
    function abortPendingRequest() {
      requestRef.current != null && (ImageLoader.abort(requestRef.current), requestRef.current = null);
    }
    return abortPendingRequest;
  }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]), /* @__PURE__ */ jsxRuntimeExports.jsxs(View$2, __spreadProps(__spreadValues({}, rest), {
    accessibilityLabel,
    onLayout: handleLayout,
    pointerEvents,
    ref,
    style: [style, styles$6.root, hasTextAncestor && styles$6.inline, imageSizeStyle, flatStyle],
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(View$2, {
      style: [...[].concat(styles$6.image), resizeModeStyles[resizeMode], {
        backgroundImage,
        filter
      }, backgroundSize != null && {
        backgroundSize
      }],
      suppressHydrationWarning: true
    }), hiddenImage, createTintColorSVG(tintColor, filterRef.current)]
  }));
});
Image.displayName = "Image";
const ImageWithStatics = Image;
ImageWithStatics.getSize = function(uri, success, failure) {
  ImageLoader.getSize(uri, success, failure);
};
ImageWithStatics.prefetch = function(uri) {
  return ImageLoader.prefetch(uri);
};
ImageWithStatics.queryCache = function(uris) {
  return ImageLoader.queryCache(uris);
};
const styles$6 = StyleSheet.create({
  root: {
    flexBasis: "auto",
    overflow: "hidden",
    zIndex: 0
  },
  inline: {
    display: "inline-flex"
  },
  image: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    backgroundColor: "transparent",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    backgroundSize: "cover",
    height: "100%",
    width: "100%",
    zIndex: -1
  }),
  accessibilityImage$raw: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    height: "100%",
    opacity: 0,
    width: "100%",
    zIndex: -1
  })
}), resizeModeStyles = StyleSheet.create({
  center: {
    backgroundSize: "auto"
  },
  contain: {
    backgroundSize: "contain"
  },
  cover: {
    backgroundSize: "cover"
  },
  none: {
    backgroundPosition: "0",
    backgroundSize: "auto"
  },
  repeat: {
    backgroundPosition: "0",
    backgroundRepeat: "repeat",
    backgroundSize: "auto"
  },
  stretch: {
    backgroundSize: "100% 100%"
  }
});
const emptyObject$2 = {}, ImageBackground = React.forwardRef((props, forwardedRef) => {
  const _a = props, {
    children,
    style = emptyObject$2,
    imageStyle,
    imageRef
  } = _a, rest = __objRest(_a, [
    "children",
    "style",
    "imageStyle",
    "imageRef"
  ]), {
    height,
    width
  } = StyleSheet.flatten(style);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(View$2, {
    ref: forwardedRef,
    style,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ImageWithStatics, __spreadProps(__spreadValues({}, rest), {
      ref: imageRef,
      style: [{
        // Temporary Workaround:
        // Current (imperfect yet) implementation of <Image> overwrites width and height styles
        // (which is not quite correct), and these styles conflict with explicitly set styles
        // of <ImageBackground> and with our internal layout model here.
        // So, we have to proxy/reapply these styles explicitly for actual <Image> component.
        // This workaround should be removed after implementing proper support of
        // intrinsic content size of the <Image>.
        width,
        height,
        zIndex: -1
      }, StyleSheet.absoluteFill, imageStyle]
    })), children]
  });
});
ImageBackground.displayName = "ImageBackground";
function Pressable(props, forwardedRef) {
  const _a = props, {
    children,
    delayLongPress,
    delayPressIn,
    delayPressOut,
    disabled,
    focusable,
    onBlur,
    onContextMenu,
    onFocus,
    onHoverIn,
    onHoverOut,
    onKeyDown: onKeyDown2,
    onLongPress,
    onPress,
    onPressMove,
    onPressIn,
    onPressOut,
    style,
    testOnly_hovered,
    testOnly_pressed
  } = _a, rest = __objRest(_a, [
    "children",
    "delayLongPress",
    "delayPressIn",
    "delayPressOut",
    "disabled",
    "focusable",
    "onBlur",
    "onContextMenu",
    "onFocus",
    "onHoverIn",
    "onHoverOut",
    "onKeyDown",
    "onLongPress",
    "onPress",
    "onPressMove",
    "onPressIn",
    "onPressOut",
    "style",
    "testOnly_hovered",
    "testOnly_pressed"
  ]), [hovered, setHovered] = useForceableState(testOnly_hovered === true), [focused, setFocused] = useForceableState(false), [pressed, setPressed] = useForceableState(testOnly_pressed === true), hostRef = React.useRef(null), setRef2 = useMergeRefs$1(forwardedRef, hostRef), pressConfig = React.useMemo(() => ({
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    disabled,
    onLongPress,
    onPress,
    onPressChange: setPressed,
    onPressStart: onPressIn,
    onPressMove,
    onPressEnd: onPressOut
  }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressMove, onPressOut, setPressed]), pressEventHandlers = usePressEvents(hostRef, pressConfig), {
    onContextMenu: onContextMenuPress,
    onKeyDown: onKeyDownPress
  } = pressEventHandlers;
  useHover(hostRef, {
    contain: true,
    disabled,
    onHoverChange: setHovered,
    onHoverStart: onHoverIn,
    onHoverEnd: onHoverOut
  });
  const interactionState = {
    hovered,
    focused,
    pressed
  }, blurHandler = React__namespace.useCallback((e2) => {
    disabled || e2.nativeEvent.target === hostRef.current && (setFocused(false), onBlur == null ? void 0 : onBlur(e2));
  }, [disabled, hostRef, setFocused, onBlur]), focusHandler = React__namespace.useCallback((e2) => {
    disabled || e2.nativeEvent.target === hostRef.current && (setFocused(true), onFocus == null ? void 0 : onFocus(e2));
  }, [disabled, hostRef, setFocused, onFocus]), contextMenuHandler = React__namespace.useCallback((e2) => {
    onContextMenuPress == null ? void 0 : onContextMenuPress(e2), onContextMenu == null ? void 0 : onContextMenu(e2);
  }, [onContextMenu, onContextMenuPress]), keyDownHandler = React__namespace.useCallback((e2) => {
    onKeyDownPress == null ? void 0 : onKeyDownPress(e2), onKeyDown2 == null ? void 0 : onKeyDown2(e2);
  }, [onKeyDown2, onKeyDownPress]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadProps(__spreadValues(__spreadValues({}, rest), pressEventHandlers), {
    accessibilityDisabled: disabled,
    focusable: !disabled && focusable !== false,
    onBlur: blurHandler,
    onContextMenu: contextMenuHandler,
    onFocus: focusHandler,
    onKeyDown: keyDownHandler,
    pointerEvents: disabled ? "none" : rest.pointerEvents,
    ref: setRef2,
    style: [!disabled && styles$5.root, typeof style == "function" ? style(interactionState) : style],
    children: typeof children == "function" ? children(interactionState) : children
  }));
}
function useForceableState(forced) {
  const [bool, setBool] = React.useState(false);
  return [bool || forced, setBool];
}
const styles$5 = StyleSheet.create({
  root: {
    cursor: "pointer",
    touchAction: "manipulation"
  }
}), PressableComponent = React.memo(React.forwardRef(Pressable));
PressableComponent.displayName = "Pressable";
const cssFunction = canUseDOM$1 && window.CSS && window.CSS.supports && window.CSS.supports("top: constant(safe-area-inset-top)") ? "constant" : "env", SafeAreaView = React__namespace.forwardRef((props, ref) => {
  const _a = props, {
    style
  } = _a, rest = __objRest(_a, [
    "style"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadProps(__spreadValues({}, rest), {
    ref,
    style: StyleSheet.compose(styles$4.root, style)
  }));
});
SafeAreaView.displayName = "SafeAreaView";
const styles$4 = StyleSheet.create({
  root: {
    paddingTop: `${cssFunction}(safe-area-inset-top)`,
    paddingRight: `${cssFunction}(safe-area-inset-right)`,
    paddingBottom: `${cssFunction}(safe-area-inset-bottom)`,
    paddingLeft: `${cssFunction}(safe-area-inset-left)`
  }
});
function normalizeScrollEvent(e2) {
  return {
    nativeEvent: {
      contentOffset: {
        get x() {
          return e2.target.scrollLeft;
        },
        get y() {
          return e2.target.scrollTop;
        }
      },
      contentSize: {
        get height() {
          return e2.target.scrollHeight;
        },
        get width() {
          return e2.target.scrollWidth;
        }
      },
      layoutMeasurement: {
        get height() {
          return e2.target.offsetHeight;
        },
        get width() {
          return e2.target.offsetWidth;
        }
      }
    },
    timeStamp: Date.now()
  };
}
function shouldEmitScrollEvent(lastTick, eventThrottle) {
  const timeSinceLastTick = Date.now() - lastTick;
  return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
}
const ScrollViewBase = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    onScroll,
    onTouchMove,
    onWheel,
    scrollEnabled = true,
    scrollEventThrottle = 0,
    showsHorizontalScrollIndicator,
    showsVerticalScrollIndicator,
    style
  } = _a, rest = __objRest(_a, [
    "onScroll",
    "onTouchMove",
    "onWheel",
    "scrollEnabled",
    "scrollEventThrottle",
    "showsHorizontalScrollIndicator",
    "showsVerticalScrollIndicator",
    "style"
  ]), scrollState = React__namespace.useRef({
    isScrolling: false,
    scrollLastTick: 0
  }), scrollTimeout = React__namespace.useRef(null), scrollRef = React__namespace.useRef(null);
  function createPreventableScrollHandler(handler) {
    return (e2) => {
      scrollEnabled && handler && handler(e2);
    };
  }
  function handleScroll(e2) {
    e2.stopPropagation(), e2.target === scrollRef.current && (e2.persist(), scrollTimeout.current != null && clearTimeout(scrollTimeout.current), scrollTimeout.current = setTimeout(() => {
      handleScrollEnd(e2);
    }, 100), scrollState.current.isScrolling ? shouldEmitScrollEvent(scrollState.current.scrollLastTick, scrollEventThrottle) && handleScrollTick(e2) : handleScrollStart(e2));
  }
  function handleScrollStart(e2) {
    scrollState.current.isScrolling = true, handleScrollTick(e2);
  }
  function handleScrollTick(e2) {
    scrollState.current.scrollLastTick = Date.now(), onScroll && onScroll(normalizeScrollEvent(e2));
  }
  function handleScrollEnd(e2) {
    scrollState.current.isScrolling = false, onScroll && onScroll(normalizeScrollEvent(e2));
  }
  const hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadProps(__spreadValues({}, rest), {
    onScroll: handleScroll,
    onTouchMove: createPreventableScrollHandler(onTouchMove),
    onWheel: createPreventableScrollHandler(onWheel),
    ref: useMergeRefs$1(scrollRef, forwardedRef),
    style: [
      style,
      // @ts-ignore
      !scrollEnabled && styles$3.scrollDisabled,
      // @ts-ignore
      hideScrollbar && styles$3.hideScrollbar
    ]
  }));
}), styles$3 = {
  scrollDisabled: {
    overflowX: "hidden",
    overflowY: "hidden",
    touchAction: "none"
  },
  hideScrollbar: {
    scrollbarWidth: "none"
  }
};
const emptyObject$1 = {}, IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
class ScrollView2 extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "_scrollNodeRef");
    __publicField(this, "_innerViewRef");
    __publicField(this, "keyboardWillOpenTo", null);
    __publicField(this, "additionalScrollOffset", 0);
    __publicField(this, "preventNegativeScrollOffset", false);
    __publicField(this, "isTouching", false);
    __publicField(this, "lastMomentumScrollBeginTime", 0);
    __publicField(this, "lastMomentumScrollEndTime", 0);
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    __publicField(this, "observedScrollSinceBecomingResponder", false);
    __publicField(this, "becameResponderWhileAnimating", false);
    __publicField(this, "flashScrollIndicators", () => {
      this.scrollResponderFlashScrollIndicators();
    });
    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollTo", (y, x, animated) => {
      typeof y == "number" ? console.warn("`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.") : {
        x,
        y,
        animated
      } = y || emptyObject$1, this.scrollResponderScrollTo({
        x: x || 0,
        y: y || 0,
        animated: animated !== false
      });
    });
    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */
    __publicField(this, "scrollToEnd", (options) => {
      const animated = (options && options.animated) !== false, {
        horizontal
      } = this.props, scrollResponderNode = this.getScrollableNode(), x = horizontal ? scrollResponderNode.scrollWidth : 0, y = horizontal ? 0 : scrollResponderNode.scrollHeight;
      this.scrollResponderScrollTo({
        x,
        y,
        animated
      });
    });
    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollResponderScrollTo", (x, y, animated) => {
      typeof x == "number" ? console.warn("`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.") : {
        x,
        y,
        animated
      } = x || emptyObject$1;
      const node = this.getScrollableNode(), left = x || 0, top = y || 0;
      node != null && (typeof node.scroll == "function" ? node.scroll({
        top,
        left,
        behavior: animated ? "smooth" : "auto"
      }) : (node.scrollLeft = left, node.scrollTop = top));
    });
    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */
    __publicField(this, "scrollResponderZoomTo", (rect, animated) => {
      invariant("zoomToRect is not implemented");
    });
    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */
    __publicField(this, "scrollResponderScrollNativeHandleToKeyboard", (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
      this.additionalScrollOffset = additionalOffset || 0, this.preventNegativeScrollOffset = !!preventNegativeScrollOffset, UIManager.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
    });
    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */
    __publicField(this, "scrollResponderInputMeasureAndScrollToKeyboard", (left, top, width, height) => {
      let keyboardScreenY = Dimensions2.get("window").height;
      this.keyboardWillOpenTo && (keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY);
      let scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;
      this.preventNegativeScrollOffset && (scrollOffsetY = Math.max(0, scrollOffsetY)), this.scrollResponderScrollTo({
        x: 0,
        y: scrollOffsetY,
        animated: true
      }), this.additionalScrollOffset = 0, this.preventNegativeScrollOffset = false;
    });
    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */
    __publicField(this, "scrollResponderKeyboardWillShow", (e2) => {
      this.keyboardWillOpenTo = e2, this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardWillHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidShow", (e2) => {
      e2 && (this.keyboardWillOpenTo = e2), this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e2);
    });
  }
  /**
   * Returns a reference to the underlying scroll responder, which supports
   * operations like `scrollTo`. All ScrollView-like components should
   * implement this method so that they can be composed while providing access
   * to the underlying scroll responder's methods.
   */
  getScrollResponder() {
    return this;
  }
  getScrollableNode() {
    return this._scrollNodeRef;
  }
  getInnerViewRef() {
    return this._innerViewRef;
  }
  getInnerViewNode() {
    return this._innerViewRef;
  }
  getNativeScrollRef() {
    return this._scrollNodeRef;
  }
  render() {
    const _a = this.props, {
      contentContainerStyle,
      horizontal,
      onContentSizeChange,
      refreshControl,
      stickyHeaderIndices,
      pagingEnabled,
      forwardedRef: forwardedRef,
      keyboardDismissMode,
      onScroll,
      centerContent
    } = _a, other = __objRest(_a, [
      "contentContainerStyle",
      "horizontal",
      "onContentSizeChange",
      "refreshControl",
      "stickyHeaderIndices",
      "pagingEnabled",
      /* eslint-disable */
      "forwardedRef",
      "keyboardDismissMode",
      "onScroll",
      "centerContent"
    ]);
    let contentSizeChangeProps = {};
    onContentSizeChange && (contentSizeChangeProps = {
      onLayout: this._handleContentOnLayout.bind(this)
    });
    const hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices), children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {
      const isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
      return child != null && (isSticky || pagingEnabled) ? /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, {
        style: StyleSheet.compose(isSticky && styles$2.stickyHeader, pagingEnabled && styles$2.pagingEnabledChild),
        children: child
      }) : child;
    }) : this.props.children, contentContainer = /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadProps(__spreadValues({}, contentSizeChangeProps), {
      collapsable: false,
      ref: this._setInnerViewRef.bind(this),
      style: [horizontal && styles$2.contentContainerHorizontal, centerContent && styles$2.contentContainerCenterContent, contentContainerStyle],
      children
    })), baseStyle = horizontal ? styles$2.baseHorizontal : styles$2.baseVertical, pagingEnabledStyle = horizontal ? styles$2.pagingEnabledHorizontal : styles$2.pagingEnabledVertical, props = __spreadProps(__spreadValues({}, other), {
      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
      onTouchStart: this.scrollResponderHandleTouchStart.bind(this),
      onTouchMove: this.scrollResponderHandleTouchMove.bind(this),
      onTouchEnd: this.scrollResponderHandleTouchEnd.bind(this),
      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag.bind(this),
      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag.bind(this),
      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin.bind(this),
      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd.bind(this),
      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder.bind(this),
      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture.bind(this),
      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder.bind(this),
      onScroll: this._handleScroll.bind(this),
      onResponderGrant: this.scrollResponderHandleResponderGrant.bind(this),
      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest.bind(this),
      onResponderRelease: this.scrollResponderHandleResponderRelease.bind(this),
      onResponderReject: this.scrollResponderHandleResponderReject.bind(this),
      onResponderTerminate: this.scrollResponderHandleTerminate.bind(this)
    }), ScrollViewClass = ScrollViewBase;
    invariant(ScrollViewClass !== void 0, "ScrollViewClass must not be undefined");
    const scrollView = /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollViewClass, __spreadProps(__spreadValues({}, props), {
      ref: this._setScrollNodeRef.bind(this),
      children: contentContainer
    }));
    return refreshControl ? React.cloneElement(refreshControl, {
      style: props.style
    }, scrollView) : scrollView;
  }
  _handleContentOnLayout(e2) {
    var _a, _b;
    const {
      width,
      height
    } = e2.nativeEvent.layout;
    (_b = (_a = this.props).onContentSizeChange) == null ? void 0 : _b.call(_a, width, height);
  }
  _handleScroll(e2) {
    this.props.keyboardDismissMode === "on-drag" && dismissKeyboard(), this.scrollResponderHandleScroll(e2);
  }
  _setInnerViewRef(node) {
    this._innerViewRef = node;
  }
  _setScrollNodeRef(node) {
    this._scrollNodeRef = node, node != null && (node.getScrollResponder = this.getScrollResponder, node.getInnerViewNode = this.getInnerViewNode, node.getInnerViewRef = this.getInnerViewRef, node.getNativeScrollRef = this.getNativeScrollRef, node.getScrollableNode = this.getScrollableNode, node.scrollTo = this.scrollTo, node.scrollToEnd = this.scrollToEnd, node.flashScrollIndicators = this.flashScrollIndicators, node.scrollResponderZoomTo = this.scrollResponderZoomTo, node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard), mergeRefs(this.props.forwardedRef)(node);
  }
  /**
   * Invoke this from an `onScroll` event.
   */
  scrollResponderHandleScrollShouldSetResponder() {
    return this.isTouching;
  }
  /**
   * Merely touch starting is not sufficient for a scroll view to become the
   * responder. Being the "responder" means that the very next touch move/end
   * event will result in an action/movement.
   *
   * Invoke this from an `onStartShouldSetResponder` event.
   *
   * `onStartShouldSetResponder` is used when the next move/end will trigger
   * some UI movement/action, but when you want to yield priority to views
   * nested inside of the view.
   *
   * There may be some cases where scroll views actually should return `true`
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
   * that gives priority to nested views.
   *
   * - If a single tap on the scroll view triggers an action such as
   *   recentering a map style view yet wants to give priority to interaction
   *   views inside (such as dropped pins or labels), then we would return true
   *   from this method when there is a single touch.
   *
   * - Similar to the previous case, if a two finger "tap" should trigger a
   *   zoom, we would check the `touches` count, and if `>= 2`, we would return
   *   true.
   *
   */
  scrollResponderHandleStartShouldSetResponder() {
    return false;
  }
  /**
   * There are times when the scroll view wants to become the responder
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
   * that *doesn't* give priority to nested views (hence the capture phase):
   *
   * - Currently animating.
   * - Tapping anywhere that is not the focused input, while the keyboard is
   *   up (which should dismiss the keyboard).
   *
   * Invoke this from an `onStartShouldSetResponderCapture` event.
   */
  scrollResponderHandleStartShouldSetResponderCapture(e2) {
    return this.scrollResponderIsAnimating();
  }
  /**
   * Invoke this from an `onResponderReject` event.
   *
   * Some other element is not yielding its role as responder. Normally, we'd
   * just disable the `UIScrollView`, but a touch has already began on it, the
   * `UIScrollView` will not accept being disabled after that. The easiest
   * solution for now is to accept the limitation of disallowing this
   * altogether. To improve this, find a way to disable the `UIScrollView` after
   * a touch has already started.
   */
  scrollResponderHandleResponderReject() {
    warning();
  }
  /**
   * We will allow the scroll view to give up its lock iff it acquired the lock
   * during an animation. This is a very useful default that happens to satisfy
   * many common user experiences.
   *
   * - Stop a scroll on the left edge, then turn that into an outer view's
   *   backswipe.
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
   *   view dismiss.
   * - However, without catching the scroll view mid-bounce (while it is
   *   motionless), if you drag far enough for the scroll view to become
   *   responder (and therefore drag the scroll view a bit), any backswipe
   *   navigation of a swipe gesture higher in the view hierarchy, should be
   *   rejected.
   */
  scrollResponderHandleTerminationRequest() {
    return !this.observedScrollSinceBecomingResponder;
  }
  /**
   * Invoke this from an `onTouchEnd` event.
   *
   * @param {SyntheticEvent} e Event.
   */
  scrollResponderHandleTouchEnd(e2) {
    const nativeEvent = e2.nativeEvent;
    this.isTouching = nativeEvent.touches.length !== 0, this.props.onTouchEnd && this.props.onTouchEnd(e2);
  }
  /**
   * Invoke this from an `onResponderRelease` event.
   */
  scrollResponderHandleResponderRelease(e2) {
    this.props.onResponderRelease && this.props.onResponderRelease(e2);
    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
    !this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e2.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating && (this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e2), TextInputState.blurTextInput(currentlyFocusedTextInput));
  }
  scrollResponderHandleScroll(e2) {
    this.observedScrollSinceBecomingResponder = true, this.props.onScroll && this.props.onScroll(e2);
  }
  /**
   * Invoke this from an `onResponderGrant` event.
   */
  scrollResponderHandleResponderGrant(e2) {
    this.observedScrollSinceBecomingResponder = false, this.props.onResponderGrant && this.props.onResponderGrant(e2), this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
  }
  /**
   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
   * animation, and there's not an easy way to distinguish a drag vs. stopping
   * momentum.
   *
   * Invoke this from an `onScrollBeginDrag` event.
   */
  scrollResponderHandleScrollBeginDrag(e2) {
    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e2);
  }
  /**
   * Invoke this from an `onScrollEndDrag` event.
   */
  scrollResponderHandleScrollEndDrag(e2) {
    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollBegin` event.
   */
  scrollResponderHandleMomentumScrollBegin(e2) {
    this.lastMomentumScrollBeginTime = Date.now(), this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollEnd` event.
   */
  scrollResponderHandleMomentumScrollEnd(e2) {
    this.lastMomentumScrollEndTime = Date.now(), this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e2);
  }
  /**
   * Invoke this from an `onTouchStart` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchStart(e2) {
    this.isTouching = true, this.props.onTouchStart && this.props.onTouchStart(e2);
  }
  /**
   * Invoke this from an `onTouchMove` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchMove(e2) {
    this.props.onTouchMove && this.props.onTouchMove(e2);
  }
  scrollResponderHandleTerminate(e2) {
    this.props.onResponderTerminate && this.props.onResponderTerminate(e2);
  }
  /**
   * A helper function for this class that lets us quickly determine if the
   * view is currently animating. This is particularly useful to know when
   * a touch has just started or ended.
   */
  scrollResponderIsAnimating() {
    return Date.now() - this.lastMomentumScrollEndTime < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
  }
  /**
   * Displays the scroll indicators momentarily.
   */
  scrollResponderFlashScrollIndicators() {
  }
  scrollResponderTextInputFocusError(e2) {
    console.error("Error measuring text field: ", e2);
  }
}
const commonStyle = {
  flexGrow: 1,
  flexShrink: 1,
  // Enable hardware compositing in modern browsers.
  // Creates a new layer with its own backing surface that can significantly
  // improve scroll performance.
  transform: [{
    translateZ: 0
  }],
  // iOS native scrolling
  WebkitOverflowScrolling: "touch"
}, styles$2 = {
  baseVertical: __spreadProps(__spreadValues({}, commonStyle), {
    flexDirection: "column",
    overflowX: "hidden",
    overflowY: "auto"
  }),
  baseHorizontal: __spreadProps(__spreadValues({}, commonStyle), {
    flexDirection: "row",
    overflowX: "auto",
    overflowY: "hidden"
  }),
  contentContainerHorizontal: {
    flexDirection: "row"
  },
  contentContainerCenterContent: {
    justifyContent: "center",
    flexGrow: 1
  },
  stickyHeader: {
    position: "sticky",
    top: 0,
    zIndex: 10
  },
  pagingEnabledHorizontal: {
    scrollSnapType: "x mandatory"
  },
  pagingEnabledVertical: {
    scrollSnapType: "y mandatory"
  },
  pagingEnabledChild: {
    scrollSnapAlign: "start"
  }
}, ForwardedScrollView = React.forwardRef((props, forwardedRef) => /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollView2, __spreadProps(__spreadValues({}, props), {
  forwardedRef
})));
ForwardedScrollView.displayName = "ScrollView";
const pickProps$1 = (props) => pick(props, forwardPropsListText), Text$2 = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    hrefAttrs,
    numberOfLines,
    onClick,
    onLayout,
    onPress,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture,
    selectable
  } = _a, rest = __objRest(_a, [
    "hrefAttrs",
    "numberOfLines",
    "onClick",
    "onLayout",
    "onPress",
    "onMoveShouldSetResponder",
    "onMoveShouldSetResponderCapture",
    "onResponderEnd",
    "onResponderGrant",
    "onResponderMove",
    "onResponderReject",
    "onResponderRelease",
    "onResponderStart",
    "onResponderTerminate",
    "onResponderTerminationRequest",
    "onScrollShouldSetResponder",
    "onScrollShouldSetResponderCapture",
    "onSelectionChangeShouldSetResponder",
    "onSelectionChangeShouldSetResponderCapture",
    "onStartShouldSetResponder",
    "onStartShouldSetResponderCapture",
    "selectable"
  ]), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), {
    direction: contextDirection
  } = useLocaleContext();
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  const handleClick = React__namespace.useCallback((e2) => {
    onClick != null ? onClick(e2) : onPress != null && (e2.stopPropagation(), onPress(e2));
  }, [onClick, onPress]);
  let component = hasTextAncestor ? "span" : "div";
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$1(rest);
  if (supportedProps.dir = componentDirection, hasTextAncestor || (supportedProps.dir = componentDirection != null ? componentDirection : "auto"), (onClick || onPress) && (supportedProps.onClick = handleClick), supportedProps.style = [numberOfLines != null && numberOfLines > 1 && {
    WebkitLineClamp: numberOfLines
  }, hasTextAncestor === true ? styles$1.textHasAncestor$raw : styles$1.text, numberOfLines === 1 && styles$1.textOneLine, numberOfLines != null && numberOfLines > 1 && styles$1.textMultiLine, props.style, selectable === true && styles$1.selectable, selectable === false && styles$1.notSelectable, onPress && styles$1.pressable], props.href != null && (component = "a", hrefAttrs != null)) {
    const {
      download,
      rel,
      target
    } = hrefAttrs;
    download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
  }
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
  supportedProps.ref = setRef2;
  const element = useCreateElement$1(component, supportedProps);
  return hasTextAncestor ? element : /* @__PURE__ */ jsxRuntimeExports.jsx(TextAncestorContext.Provider, {
    value: true,
    children: element
  });
});
Text$2.displayName = "Text";
const textStyle = {
  backgroundColor: "transparent",
  border: "0 solid black",
  boxSizing: "border-box",
  color: "black",
  display: "inline",
  font: "14px System",
  listStyle: "none",
  margin: 0,
  padding: 0,
  textAlign: "inherit",
  textDecoration: "none",
  whiteSpace: "pre-wrap",
  wordWrap: "break-word"
}, styles$1 = {
  text: textStyle,
  textHasAncestor$raw: __spreadProps(__spreadValues({}, textStyle), {
    color: "inherit",
    font: "inherit",
    whiteSpace: "inherit"
  }),
  textOneLine: {
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  },
  // See #13
  textMultiLine: {
    display: "-webkit-box",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    WebkitBoxOrient: "vertical"
  },
  notSelectable: {
    userSelect: "none"
  },
  selectable: {
    userSelect: "text"
  },
  pressable: {
    cursor: "pointer"
  }
};
const isSelectionStale = (node, selection) => {
  const {
    selectionEnd,
    selectionStart
  } = node, {
    start,
    end
  } = selection;
  return start !== selectionStart || end !== selectionEnd;
}, setSelection = (node, selection) => {
  if (isSelectionStale(node, selection)) {
    const {
      start,
      end
    } = selection;
    try {
      node.setSelectionRange(start, end || start);
    } catch (e2) {
    }
  }
}, forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
  autoCapitalize: true,
  className: true,
  autoComplete: true,
  autoCorrect: true,
  autoFocus: true,
  defaultValue: true,
  disabled: true,
  lang: true,
  maxLength: true,
  onChange: true,
  onScroll: true,
  placeholder: true,
  pointerEvents: true,
  readOnly: true,
  rows: true,
  spellCheck: true,
  value: true,
  type: true
}), pickProps = (props) => pick(props, forwardPropsList), useIsomorphicLayoutEffect$1 = typeof window > "u" ? React__namespace.useEffect : React__namespace.useLayoutEffect;
function isEventComposing(nativeEvent) {
  return nativeEvent.isComposing || nativeEvent.keyCode === 229;
}
let focusTimeout = null;
const TextInput = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    autoCapitalize = "sentences",
    autoComplete,
    autoCompleteType,
    autoCorrect = true,
    blurOnSubmit,
    clearTextOnFocus,
    dir,
    editable,
    enterKeyHint,
    inputMode = "text",
    keyboardType,
    multiline = false,
    numberOfLines,
    onBlur,
    onChange,
    onChangeText,
    onContentSizeChange,
    onFocus,
    onKeyPress,
    onLayout,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChange,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture,
    onSubmitEditing,
    placeholderTextColor,
    readOnly = false,
    returnKeyType,
    rows = 1,
    secureTextEntry = false,
    selection,
    selectTextOnFocus,
    showSoftInputOnFocus,
    caretHidden,
    spellCheck
  } = props;
  let type, _inputMode;
  if (inputMode != null) _inputMode = inputMode, inputMode === "email" ? type = "email" : inputMode === "tel" ? type = "tel" : inputMode === "search" ? type = "search" : inputMode === "url" ? type = "url" : type = "text";
  else if (keyboardType != null) switch (keyboardType) {
    case "email-address":
      type = "email";
      break;
    case "number-pad":
    case "numeric":
      _inputMode = "numeric";
      break;
    case "decimal-pad":
      _inputMode = "decimal";
      break;
    case "phone-pad":
      type = "tel";
      break;
    case "search":
    case "web-search":
      type = "search";
      break;
    case "url":
      type = "url";
      break;
    default:
      type = "text";
  }
  secureTextEntry && (type = "password");
  const dimensions2 = React__namespace.useRef({
    height: null,
    width: null
  }), hostRef = React__namespace.useRef(null), handleContentSizeChange = React__namespace.useCallback((hostNode) => {
    if (multiline && onContentSizeChange && hostNode != null) {
      const newHeight = hostNode.scrollHeight, newWidth = hostNode.scrollWidth;
      (newHeight !== dimensions2.current.height || newWidth !== dimensions2.current.width) && (dimensions2.current.height = newHeight, dimensions2.current.width = newWidth, onContentSizeChange({
        nativeEvent: {
          contentSize: {
            height: dimensions2.current.height,
            width: dimensions2.current.width
          }
        }
      }));
    }
  }, [multiline, onContentSizeChange]), imperativeRef = React__namespace.useMemo(() => (hostNode) => {
    hostNode != null && (hostNode.clear = () => {
      hostNode != null && (hostNode.value = "");
    }, hostNode.isFocused = () => hostNode != null && TextInputState.currentlyFocusedField() === hostNode, handleContentSizeChange(hostNode));
  }, [handleContentSizeChange]);
  function handleBlur(e2) {
    TextInputState._currentlyFocusedNode = null, onBlur && (e2.nativeEvent.text = e2.target.value, onBlur(e2));
  }
  function handleChange(e2) {
    const hostNode = e2.target, text = hostNode.value;
    e2.nativeEvent.text = text, handleContentSizeChange(hostNode), onChange && onChange(e2), onChangeText && onChangeText(text);
  }
  function handleFocus(e2) {
    const hostNode = e2.target;
    onFocus && (e2.nativeEvent.text = hostNode.value, onFocus(e2)), hostNode != null && (TextInputState._currentlyFocusedNode = hostNode, clearTextOnFocus && (hostNode.value = ""), selectTextOnFocus && (focusTimeout != null && clearTimeout(focusTimeout), focusTimeout = setTimeout(() => {
      hostNode == null ? void 0 : hostNode.select();
    }, 0)));
  }
  function handleKeyDown(e2) {
    const hostNode = e2.target;
    e2.stopPropagation();
    const shouldBlurOnSubmit = blurOnSubmit != null ? blurOnSubmit : !multiline, nativeEvent = e2.nativeEvent, isComposing = isEventComposing(nativeEvent);
    onKeyPress && onKeyPress(e2), e2.key === "Enter" && !e2.shiftKey && // Do not call submit if composition is occuring.
    !isComposing && !e2.isDefaultPrevented() && ((blurOnSubmit || !multiline) && onSubmitEditing && (e2.preventDefault(), nativeEvent.text = e2.target.value, onSubmitEditing(e2)), shouldBlurOnSubmit && hostNode != null && setTimeout(() => hostNode.blur(), 0));
  }
  function handleSelectionChange(e2) {
    if (onSelectionChange) try {
      const node = e2.target, {
        selectionStart,
        selectionEnd
      } = node;
      e2.nativeEvent.selection = {
        start: selectionStart,
        end: selectionEnd
      }, e2.nativeEvent.text = e2.target.value, onSelectionChange(e2);
    } catch (e3) {
    }
  }
  useIsomorphicLayoutEffect$1(() => {
    const node = hostRef.current;
    node != null && selection != null && setSelection(node, selection), document.activeElement === node && (TextInputState._currentlyFocusedNode = node);
  }, [hostRef, selection]);
  const component = multiline ? "textarea" : "input";
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  const {
    direction: contextDirection
  } = useLocaleContext(), supportedProps = pickProps(props);
  supportedProps.autoCapitalize = autoCapitalize, supportedProps.autoComplete = autoComplete || autoCompleteType || "on", supportedProps.autoCorrect = autoCorrect ? "on" : "off", supportedProps.dir = dir !== void 0 ? dir : "auto", supportedProps.enterKeyHint = enterKeyHint || returnKeyType, supportedProps.inputMode = _inputMode, supportedProps.onBlur = handleBlur, supportedProps.onChange = handleChange, supportedProps.onFocus = handleFocus, supportedProps.onKeyDown = handleKeyDown, supportedProps.onSelect = handleSelectionChange, supportedProps.readOnly = readOnly === true || editable === false, supportedProps.rows = multiline ? rows != null ? rows : numberOfLines : 1, supportedProps.spellCheck = spellCheck != null ? spellCheck : autoCorrect, supportedProps.style = [{
    "--placeholderTextColor": placeholderTextColor
  }, styles.textinput$raw, styles.placeholder, props.style, caretHidden && styles.caretHidden], supportedProps.type = multiline ? void 0 : type, supportedProps.virtualkeyboardpolicy = showSoftInputOnFocus === false ? "manual" : "auto";
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
  supportedProps.ref = setRef2;
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null;
  props.dir || langDirection || contextDirection;
  return useCreateElement$1(component, supportedProps);
});
TextInput.displayName = "TextInput";
TextInput.State = TextInputState;
const styles = StyleSheet.create({
  textinput$raw: {
    MozAppearance: "textfield",
    WebkitAppearance: "none",
    appearance: "none"
  },
  placeholder: {
    placeholderTextColor: "var(--placeholderTextColor)"
  },
  caretHidden: {
    caretColor: "transparent"
  }
});
React.createContext(null);
var IS_REACT_19 = typeof React.use < "u", isWeb = false, isWindowDefined = false, isServer = false, isClient = false, useIsomorphicLayoutEffect = React.useLayoutEffect, isChrome = false, isWebTouchable = false, isTouchable = true, isAndroid = process.env.TEST_NATIVE_PLATFORM === "android", isIos = process.env.TEST_NATIVE_PLATFORM === "ios", platforms = {
  ios: "ios",
  android: "android"
}, currentPlatform = platforms[Platform.OS] || "native";
var THEME_NAME_SEPARATOR = "_", THEME_CLASSNAME_PREFIX = "t_", FONT_DATA_ATTRIBUTE_NAME = "data-tamagui-font", stackDefaultStyles = {}, webViewFlexCompatStyles = {
  display: "flex",
  alignItems: "stretch",
  flexDirection: "column",
  flexBasis: "auto",
  boxSizing: "border-box",
  position: process.env.TAMAGUI_POSITION_STATIC === "1" ? "static" : "relative",
  minHeight: 0,
  minWidth: 0,
  flexShrink: 0
}, MISSING_THEME_MESSAGE = "Missing theme.";
var conf$1, getConfigFromGlobalOrLocal = function() {
  return conf$1 || (globalThis.__tamaguiConfig ? globalThis.__tamaguiConfig : null);
}, getSetting = function(key) {
  var config = getConfigFromGlobalOrLocal();
  var _config_settings_key;
  return (_config_settings_key = config.settings[key]) !== null && _config_settings_key !== void 0 ? _config_settings_key : (
    // @ts-expect-error
    config[key]
  );
}, setConfig = function(next) {
  conf$1 = next, globalThis.__tamaguiConfig = next;
}, setConfigFont = function(name, font, fontParsed) {
  var config = getConfigFromGlobalOrLocal();
  config.fonts[name] = font, config.fontsParsed[`$${name}`] = fontParsed;
}, getConfig = function() {
  var config = getConfigFromGlobalOrLocal();
  if (!config) throw new Error("Err0");
  return config;
}, getConfigMaybe = function() {
  return getConfigFromGlobalOrLocal();
}, tokensMerged;
function setTokens(_) {
  tokensMerged = _;
}
var getTokens = function() {
  var {
    prefixed
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (
    /**
    * Force either with $ or without $ prefix
    */
    {}
  ), config = getConfigFromGlobalOrLocal();
  var {
    tokens,
    tokensParsed
  } = config;
  return prefixed === false ? tokens : prefixed === true ? tokensParsed : tokensMerged;
}, getTokenObject = function(value, group) {
  var _tokensMerged_group, _tokensMerged_, config = getConfigFromGlobalOrLocal(), _config_specificTokens_value;
  return (_config_specificTokens_value = config.specificTokens[value]) !== null && _config_specificTokens_value !== void 0 ? _config_specificTokens_value : group ? (_tokensMerged_group = tokensMerged[group]) === null || _tokensMerged_group === void 0 ? void 0 : _tokensMerged_group[value] : (_tokensMerged_ = tokensMerged[Object.keys(tokensMerged).find(function(cat) {
    return tokensMerged[cat][value];
  }) || ""]) === null || _tokensMerged_ === void 0 ? void 0 : _tokensMerged_[value];
}, getToken = function(value, group) {
  var useVariable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : isWeb, token = getTokenObject(value, group);
  return useVariable ? token == null ? void 0 : token.variable : token == null ? void 0 : token.val;
}, getTokenValue = function(value, group) {
  if (!(value === "unset" || value === "auto")) return getToken(value, group, false);
}, getThemes = function() {
  return getConfigFromGlobalOrLocal().themes;
}, configListeners = /* @__PURE__ */ new Set(), onConfiguredOnce = function(cb) {
  var config = getConfigFromGlobalOrLocal();
  config ? cb(config) : configListeners.add(cb);
}, updateConfig = function(key, value) {
  var config = getConfigFromGlobalOrLocal();
  Object.assign(config[key], value);
}, getFont = function(name) {
  var _Object_entries_find, conf2 = getConfig(), _conf_fontsParsed_name;
  return (_conf_fontsParsed_name = conf2.fontsParsed[name]) !== null && _conf_fontsParsed_name !== void 0 ? _conf_fontsParsed_name : (_Object_entries_find = Object.entries(conf2.fontsParsed).find(function(param) {
    var [k] = param, _conf_fontsParsed_k_family, _conf_fontsParsed_k;
    return ((_conf_fontsParsed_k = conf2.fontsParsed[k]) === null || _conf_fontsParsed_k === void 0 || (_conf_fontsParsed_k_family = _conf_fontsParsed_k.family) === null || _conf_fontsParsed_k_family === void 0 ? void 0 : _conf_fontsParsed_k_family.val) === name;
  })) === null || _Object_entries_find === void 0 ? void 0 : _Object_entries_find[1];
};
function setupDev(conf2) {
}
var cache$4 = /* @__PURE__ */ new Map(), cacheSize = 0, simpleHash = function(strIn) {
  var hashMin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  if (cache$4.has(strIn)) return cache$4.get(strIn);
  var str = strIn;
  str[0] === "v" && str.startsWith("var(") && (str = str.slice(6, str.length - 1));
  for (var hash = 0, valids = "", added = 0, len = str.length, i = 0; i < len; i++) {
    if (hashMin !== "strict" && added <= hashMin) {
      var char = str.charCodeAt(i);
      if (char === 46) {
        valids += "--";
        continue;
      }
      if (isValidCSSCharCode(char)) {
        added++, valids += str[i];
        continue;
      }
    }
    hash = hashChar(hash, str[i]);
  }
  var res = valids + (hash ? Math.abs(hash) : "");
  return cacheSize > 1e4 && (cache$4.clear(), cacheSize = 0), cache$4.set(strIn, res), cacheSize++, res;
}, hashChar = function(hash, c) {
  return Math.imul(31, hash) + c.charCodeAt(0) | 0;
};
function isValidCSSCharCode(code) {
  return (
    // A-Z
    code >= 65 && code <= 90 || // a-z
    code >= 97 && code <= 122 || // _
    code === 95 || // -
    code === 45 || // 0-9
    code >= 48 && code <= 57
  );
}
function clamp(value, param) {
  var [min, max] = param;
  return Math.min(max, Math.max(min, value));
}
function _type_of$7(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function composeEventHandlers(og, next) {
  var {
    checkDefaultPrevented = true
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return !og || !next ? next || og || void 0 : function(event) {
    if (og == null ? void 0 : og(event), !event || !(checkDefaultPrevented && (typeof event > "u" ? "undefined" : _type_of$7(event)) === "object" && "defaultPrevented" in event) || // @ts-ignore
    "defaultPrevented" in event && !event.defaultPrevented) return next == null ? void 0 : next(event);
  };
}
var StyleObjectProperty = 0, StyleObjectValue = 1, StyleObjectIdentifier = 2, StyleObjectPseudo = 3, StyleObjectRules = 4;
var ALL_PLATFORMS = ["web", "android", "ios"];
function shouldRenderNativePlatform(nativeProp) {
  if (!nativeProp) return null;
  var userRequestedPlatforms = resolvePlatformNames(nativeProp), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = ALL_PLATFORMS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var platform = _step.value;
      if (platform === currentPlatform && userRequestedPlatforms.has(platform)) return platform;
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return null;
}
function resolvePlatformNames(nativeProp) {
  var platforms2 = nativeProp === true ? (
    // all native platforms
    ALL_PLATFORMS
  ) : nativeProp === false ? (
    // no native platform
    []
  ) : Array.isArray(nativeProp) ? nativeProp : [nativeProp], set = new Set(platforms2);
  return set.has("mobile") && (set.add("android"), set.add("ios"), set.delete("mobile")), set;
}
var textColors = {
  color: true,
  textDecorationColor: true,
  textShadowColor: true
}, tokenCategories = {
  radius: {
    borderRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    // logical
    borderStartStartRadius: true,
    borderStartEndRadius: true,
    borderEndStartRadius: true,
    borderEndEndRadius: true
  },
  size: {
    width: true,
    height: true,
    minWidth: true,
    minHeight: true,
    maxWidth: true,
    maxHeight: true,
    blockSize: true,
    minBlockSize: true,
    maxBlockSize: true,
    inlineSize: true,
    minInlineSize: true,
    maxInlineSize: true
  },
  zIndex: {
    zIndex: true
  },
  color: __spreadValues({
    backgroundColor: true,
    borderColor: true,
    borderBlockStartColor: true,
    borderBlockEndColor: true,
    borderBlockColor: true,
    borderBottomColor: true,
    borderInlineColor: true,
    borderInlineStartColor: true,
    borderInlineEndColor: true,
    borderTopColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderEndColor: true,
    borderStartColor: true,
    shadowColor: true
  }, textColors)
}, stylePropsUnitless = {
  WebkitLineClamp: true,
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  gridTemplateColumns: true,
  gridTemplateAreas: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  shadowOpacity: true
}, stylePropsTransform = {
  x: true,
  y: true,
  scale: true,
  perspective: true,
  scaleX: true,
  scaleY: true,
  skewX: true,
  skewY: true,
  matrix: true,
  rotate: true,
  rotateY: true,
  rotateX: true,
  rotateZ: true
}, stylePropsView = __spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
  backfaceVisibility: true,
  borderBottomEndRadius: true,
  borderBottomStartRadius: true,
  borderBottomWidth: true,
  borderLeftWidth: true,
  borderRightWidth: true,
  borderBlockWidth: true,
  borderBlockEndWidth: true,
  borderBlockStartWidth: true,
  borderInlineWidth: true,
  borderInlineEndWidth: true,
  borderInlineStartWidth: true,
  borderStyle: true,
  borderBlockStyle: true,
  borderBlockEndStyle: true,
  borderBlockStartStyle: true,
  borderInlineStyle: true,
  borderInlineEndStyle: true,
  borderInlineStartStyle: true,
  borderTopEndRadius: true,
  borderTopStartRadius: true,
  borderTopWidth: true,
  borderWidth: true,
  transform: true,
  transformOrigin: true,
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  borderEndWidth: true,
  borderStartWidth: true,
  bottom: true,
  display: true,
  end: true,
  flexBasis: true,
  flexDirection: true,
  flexWrap: true,
  gap: true,
  columnGap: true,
  rowGap: true,
  justifyContent: true,
  left: true,
  margin: true,
  marginBlock: true,
  marginBlockEnd: true,
  marginBlockStart: true,
  marginInline: true,
  marginInlineStart: true,
  marginInlineEnd: true,
  marginBottom: true,
  marginEnd: true,
  marginHorizontal: true,
  marginLeft: true,
  marginRight: true,
  marginStart: true,
  marginTop: true,
  marginVertical: true,
  overflow: true,
  padding: true,
  paddingBottom: true,
  paddingInline: true,
  paddingBlock: true,
  paddingBlockStart: true,
  paddingInlineEnd: true,
  paddingInlineStart: true,
  paddingEnd: true,
  paddingHorizontal: true,
  paddingLeft: true,
  paddingRight: true,
  paddingStart: true,
  paddingTop: true,
  paddingVertical: true,
  position: true,
  right: true,
  start: true,
  top: true,
  inset: true,
  insetBlock: true,
  insetBlockEnd: true,
  insetBlockStart: true,
  insetInline: true,
  insetInlineEnd: true,
  insetInlineStart: true,
  direction: true,
  shadowOffset: true,
  shadowRadius: true
}, tokenCategories.color), tokenCategories.radius), tokenCategories.size), tokenCategories.radius), stylePropsTransform), stylePropsUnitless), {
  boxShadow: true,
  filter: true
}), !process.env.REACT_NATIVE_PRE_77 && {
  boxSizing: true,
  mixBlendMode: true,
  outlineColor: true,
  outlineSpread: true,
  outlineStyle: true,
  outlineWidth: true
}), isAndroid ? {
  elevationAndroid: true
} : {}), stylePropsFont = {
  fontFamily: true,
  fontSize: true,
  fontStyle: true,
  fontWeight: true,
  fontVariant: true,
  letterSpacing: true,
  lineHeight: true,
  textTransform: true
}, stylePropsTextOnly = __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, stylePropsFont), {
  textAlign: true,
  textDecorationLine: true,
  textDecorationStyle: true
}), textColors), {
  textShadowOffset: true,
  textShadowRadius: true,
  userSelect: true,
  selectable: true,
  verticalAlign: true
}), stylePropsText = __spreadValues(__spreadValues({}, stylePropsView), stylePropsTextOnly), stylePropsAll = stylePropsText, validPseudoKeys = {
  enterStyle: true,
  exitStyle: true,
  hoverStyle: true,
  pressStyle: true,
  focusStyle: true,
  disabledStyle: true,
  focusWithinStyle: true
}, validStyles = stylePropsView;
function _type_of$6(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var Decorated = Symbol(), withStaticProperties = function(component, staticProps) {
  var next = (function() {
    if (component[Decorated]) {
      var _ = /* @__PURE__ */ React.forwardRef(function(props, ref) {
        return /* @__PURE__ */ React.createElement(component, __spreadProps(__spreadValues({}, props), {
          ref
        }));
      });
      for (var key in component) {
        var v = component[key];
        _[key] = v && (typeof v > "u" ? "undefined" : _type_of$6(v)) === "object" ? __spreadValues({}, v) : v;
      }
    }
    return component;
  })();
  return Object.assign(next, staticProps), next[Decorated] = true, next;
};
function _type_of$5(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function constructCSSVariableName(name) {
  return `var(--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${name})`;
}
var createVariable = function(props) {
  var skipHash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!skipHash && isVariable(props)) return props;
  var {
    key,
    name,
    val
  } = props;
  return {
    isVar: true,
    key,
    name: skipHash ? name : simpleHash(name, 40),
    val,
    variable: ""
  };
};
function variableToString(vrble) {
  return isVariable(vrble) ? `${vrble.val}` : `${vrble || ""}`;
}
function isVariable(v) {
  return v && (typeof v > "u" ? "undefined" : _type_of$5(v)) === "object" && "isVar" in v;
}
function getVariable(nameOrVariable) {
  var group = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "size", _tokens_group;
  if (nameOrVariable == null ? void 0 : nameOrVariable.dynamic) return nameOrVariable;
  if (setDidGetVariableValue(true), isVariable(nameOrVariable)) return variableToString(nameOrVariable);
  var tokens = getConfig().tokensParsed, _tokens_group_nameOrVariable;
  return variableToString((_tokens_group_nameOrVariable = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[nameOrVariable]) !== null && _tokens_group_nameOrVariable !== void 0 ? _tokens_group_nameOrVariable : nameOrVariable);
}
var accessed = false, setDidGetVariableValue = function(val) {
  return accessed = val;
}, didGetVariableValue = function() {
  return accessed;
};
function getVariableValue(v, group) {
  if (isVariable(v)) return setDidGetVariableValue(true), v.val;
  if (group) {
    var _tokens_group, tokens = getConfig().tokensParsed, token = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[v];
    if (token) return setDidGetVariableValue(true), token.val;
  }
  return v;
}
function getVariableName(v) {
  return isVariable(v) ? v.name : v;
}
function getVariableVariable(v) {
  return isVariable(v) ? v.variable : v;
}
var createCSSVariable = function(nameProp) {
  var includeVar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var name = simpleHash(nameProp, 60);
  return includeVar ? constructCSSVariableName(name) : name;
};
function px(value) {
  return {
    val: value,
    needsPx: true
  };
}
function getOppositeScheme(scheme) {
  return scheme === "dark" ? "light" : "dark";
}
function getDynamicVal(param) {
  var {
    scheme,
    val,
    oppositeVal
  } = param, oppositeScheme = getOppositeScheme(scheme);
  return {
    dynamic: {
      [scheme]: val,
      [oppositeScheme]: oppositeVal
    }
  };
}
function extractValueFromDynamic(val, scheme) {
  return (val == null ? void 0 : val.dynamic) ? val.dynamic[scheme] : val;
}
var ThemeStateContext = React.createContext(""), allListeners = /* @__PURE__ */ new Map(), listenersByParent = {}, HasRenderedOnce = /* @__PURE__ */ new WeakMap(), HadTheme = /* @__PURE__ */ new WeakMap(), PendingUpdate = /* @__PURE__ */ new Map(), states = /* @__PURE__ */ new Map(), localStates = /* @__PURE__ */ new Map(), shouldForce = false, forceUpdateThemes = function() {
  shouldForce = true, allListeners.forEach(function(cb) {
    return cb();
  });
}, getThemeState = function(id2) {
  return states.get(id2);
}, themes = null, rootThemeState = null, getRootThemeState = function() {
  return rootThemeState;
}, useThemeState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = arguments.length > 2 ? arguments[2] : void 0, {
    disable
  } = props, parentId = React.useContext(ThemeStateContext);
  if (!parentId && !isRoot) throw new Error(MISSING_THEME_MESSAGE);
  if (disable) return states.get(parentId) || {
    id: "",
    name: "light",
    theme: getConfig().themes.light,
    inverses: 0
  };
  var id2 = React.useId(), subscribe2 = React.useCallback(function(cb) {
    var _listenersByParent, _parentId;
    return (_listenersByParent = listenersByParent)[_parentId = parentId] || (_listenersByParent[_parentId] = /* @__PURE__ */ new Set()), listenersByParent[parentId].add(id2), allListeners.set(id2, function() {
      PendingUpdate.set(id2, shouldForce ? "force" : true), cb();
    }), function() {
      allListeners.delete(id2), listenersByParent[parentId].delete(id2), localStates.delete(id2), states.delete(id2), PendingUpdate.delete(id2);
    };
  }, [id2, parentId]), propsKey = getPropsKey(props), getSnapshot = function() {
    var _keys_current, _props_needsUpdate, local = localStates.get(id2), needsUpdate = props.passThrough ? false : isRoot || props.name === "light" || props.name === "dark" || props.name === null ? true : HasRenderedOnce.get(keys) ? !(keys == null || (_keys_current = keys.current) === null || _keys_current === void 0) && _keys_current.size ? true : (_props_needsUpdate = props.needsUpdate) === null || _props_needsUpdate === void 0 ? void 0 : _props_needsUpdate.call(props) : true, [rerender, next] = getNextState(local, props, propsKey, isRoot, id2, parentId, needsUpdate, PendingUpdate.get(id2));
    return PendingUpdate.delete(id2), (!local || rerender) && (local = __spreadValues({}, next), localStates.set(id2, local)), Object.assign(local, next), local.id = id2, states.set(id2, next), local;
  };
  var state = React.useSyncExternalStore(subscribe2, getSnapshot, getSnapshot);
  return useIsomorphicLayoutEffect(function() {
    if (!HasRenderedOnce.get(keys)) {
      HasRenderedOnce.set(keys, true);
      return;
    }
    if (!propsKey) {
      HadTheme.get(keys) && scheduleUpdate(id2), HadTheme.set(keys, false);
      return;
    }
    scheduleUpdate(id2), HadTheme.set(keys, true);
  }, [keys, propsKey]), state;
}, getNextState = function(lastState, props, propsKey) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, id2 = arguments.length > 4 ? arguments[4] : void 0, parentId = arguments.length > 5 ? arguments[5] : void 0, needsUpdate = arguments.length > 6 ? arguments[6] : void 0, pendingUpdate = arguments.length > 7 ? arguments[7] : void 0, {
    debug
  } = props, parentState = states.get(parentId);
  if (props.passThrough) return [false, lastState || parentState || {
    name: ""
  }];
  themes || (themes = getConfig().themes);
  var name = !propsKey && (!lastState || !(lastState == null ? void 0 : lastState.isNew)) ? null : getNewThemeName(parentState == null ? void 0 : parentState.name, props, pendingUpdate === "force" ? true : !!needsUpdate), isSameAsParent = parentState && (!name || name === parentState.name), shouldRerender = !!(needsUpdate && (pendingUpdate || (lastState == null ? void 0 : lastState.name) !== (parentState == null ? void 0 : parentState.name)));
  if (isSameAsParent) return [shouldRerender, __spreadProps(__spreadValues({}, parentState), {
    isNew: false
  })];
  if (!name) {
    var next = lastState != null ? lastState : parentState;
    if (!next) throw new Error(MISSING_THEME_MESSAGE);
    if (shouldRerender) {
      var updated = __spreadValues({}, parentState || lastState);
      return [true, updated];
    }
    return [false, next];
  }
  var scheme = getScheme(name), _parentState_inverses, parentInverses = (_parentState_inverses = parentState == null ? void 0 : parentState.inverses) !== null && _parentState_inverses !== void 0 ? _parentState_inverses : 0, isInverse = parentState && scheme !== parentState.scheme, inverses = parentInverses + (isInverse ? 1 : 0), nextState = {
    id: id2,
    name,
    theme: themes[name],
    scheme,
    parentId,
    parentName: parentState == null ? void 0 : parentState.name,
    inverses,
    isInverse,
    isNew: true
  };
  if (isRoot && (rootThemeState = nextState), pendingUpdate !== "force" && lastState && lastState.name === name) return [false, nextState];
  var shouldAvoidRerender = pendingUpdate !== "force" && lastState && !needsUpdate && nextState.name === lastState.name;
  return shouldAvoidRerender ? [false, nextState] : [true, nextState];
};
function scheduleUpdate(id2) {
  for (var queue2 = [id2], visited = /* @__PURE__ */ new Set(); queue2.length; ) {
    var parent = queue2.shift(), children = listenersByParent[parent];
    if (children) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var childId = _step.value;
          visited.has(childId) || (visited.add(childId), queue2.push(childId));
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
  }
  visited.forEach(function(childId2) {
    var cb = allListeners.get(childId2);
    cb == null ? void 0 : cb();
  });
}
var validSchemes = {
  light: "light",
  dark: "dark"
};
function getScheme(name) {
  return validSchemes[name.split("_")[0]];
}
function getNewThemeName() {
  var parentName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", {
    name,
    reset,
    componentName,
    inverse,
    debug
  } = arguments.length > 1 ? arguments[1] : void 0, forceUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (name && reset) throw new Error("004");
  var {
    themes: themes2
  } = getConfig();
  if (reset) {
    var isSchemeOnly = parentName === "light" || parentName === "dark";
    if (isSchemeOnly) return parentName === "light" ? "dark" : "light";
    var lastPartIndex = parentName.lastIndexOf("_"), name1 = lastPartIndex <= 0 ? parentName : parentName.slice(lastPartIndex), scheme = parentName.slice(0, lastPartIndex), result = themes2[name1] ? name1 : scheme;
    return result;
  }
  var parentParts = parentName.split("_"), lastName = parentParts[parentParts.length - 1];
  lastName && lastName[0].toLowerCase() !== lastName[0] && parentParts.pop();
  var subNames = [name && componentName ? `${name}_${componentName}` : void 0, name, componentName].filter(Boolean), found = null;
  if (name) {
    var nameHasScheme = getScheme(name);
    if (nameHasScheme) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = subNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var subName = _step.value;
          if (subName in themes2) {
            found = subName;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
    if (!found && !nameHasScheme) {
      var parentScheme = getScheme(parentName);
      if (parentScheme) {
        var parentBase = parentParts.join("_"), withScheme = [componentName ? `${parentBase}_${name}_${componentName}` : void 0, `${parentBase}_${name}`, componentName ? `${parentScheme}_${name}_${componentName}` : void 0, `${parentScheme}_${name}`].filter(Boolean), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
        try {
          for (var _iterator1 = withScheme[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var potential = _step1.value;
            if (potential in themes2) {
              found = potential;
              break;
            }
          }
        } catch (err) {
          _didIteratorError1 = true, _iteratorError1 = err;
        } finally {
          try {
            !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError1) throw _iteratorError1;
          }
        }
      }
    }
  }
  if (!found) if (!name && componentName) {
    var potential1 = `${parentParts.join("_")}_${componentName}`;
    potential1 in themes2 && (found = potential1);
  } else for (var max = parentParts.length, i = 0; i <= max; i++) {
    var base = (i === 0 ? parentParts : parentParts.slice(0, -i)).join("_"), _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
    try {
      for (var _iterator2 = subNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var subName1 = _step2.value, potential2 = base ? `${base}_${subName1}` : subName1;
        if (potential2 in themes2) {
          found = potential2;
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
      } finally {
        if (_didIteratorError2) throw _iteratorError2;
      }
    }
    if (found) break;
  }
  if (inverse) {
    found || (found = parentName);
    var scheme1 = found.split("_")[0];
    found = found.replace(new RegExp(`^${scheme1}`), scheme1 === "light" ? "dark" : "light");
  }
  return !forceUpdate && found === parentName && // if its a scheme only sub-theme, we always consider it "new" because it likely inverses
  // and we want to avoid reparenting
  !validSchemes[found] ? null : found;
}
var getPropsKey = function(param) {
  var {
    name,
    reset,
    inverse,
    forceClassName,
    componentName
  } = param;
  return `${name || ""}${inverse || ""}${reset || ""}${forceClassName || ""}${componentName || ""}`;
}, hasThemeUpdatingProps = function(props) {
  return "inverse" in props || "name" in props || "reset" in props || "forceClassName" in props;
};
function doesRootSchemeMatchSystem() {
  var _getRootThemeState;
  return ((_getRootThemeState = getRootThemeState()) === null || _getRootThemeState === void 0 ? void 0 : _getRootThemeState.scheme) === Appearance.getColorScheme();
}
var cache$3 = /* @__PURE__ */ new Map(), curKeys, curProps, curState, emptyObject = {};
function getThemeProxied(_props, _state, _keys) {
  if (!(_state == null ? void 0 : _state.theme)) return emptyObject;
  if (curKeys = _keys, curProps = _props, curState = _state, cache$3.has(curState.theme)) {
    var proxied = cache$3.get(curState.theme);
    return proxied;
  }
  var config = getConfig();
  function track(key) {
    curKeys && (curKeys.current || (curKeys.current = /* @__PURE__ */ new Set()), curKeys.current.add(key), false);
  }
  var proxied1 = Object.fromEntries(Object.entries(_state.theme).flatMap(function(param) {
    var [key, value] = param, proxied2 = __spreadProps(__spreadValues({}, value), {
      get val() {
        return globalThis.tamaguiAvoidTracking || track(key), value.val;
      },
      get(platform) {
        if (curState) {
          var outVal = getVariable(value), {
            name,
            scheme,
            inverses
          } = curState, shouldOptimize = scheme && platform !== "web" && isIos && !curProps.deopt && getSetting("fastSchemeChange") && inverses === 0 && doesRootSchemeMatchSystem();
          if (shouldOptimize) {
            var _config_themes_name, _config_themes_oppositeName, oppositeScheme = scheme === "dark" ? "light" : "dark", oppositeName = name.replace(scheme, oppositeScheme), color = getVariable((_config_themes_name = config.themes[name]) === null || _config_themes_name === void 0 ? void 0 : _config_themes_name[key]), oppositeColor = getVariable((_config_themes_oppositeName = config.themes[oppositeName]) === null || _config_themes_oppositeName === void 0 ? void 0 : _config_themes_oppositeName[key]), dynamicVal = getDynamicVal({
              scheme,
              val: color,
              oppositeVal: oppositeColor
            });
            return dynamicVal;
          }
          return track(key), outVal;
        }
      }
    });
    return [[key, proxied2], [`$${key}`, proxied2]];
  }));
  return cache$3.set(_state.theme, proxied1), proxied1;
}
var useTheme = function() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, [theme] = useThemeWithState(props), res = theme;
  return res;
}, useThemeWithState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = React.useRef(null), themeState = useThemeState(props, isRoot, keys);
  var themeProxied = props.passThrough ? {} : getThemeProxied(props, themeState, keys);
  return [themeProxied, themeState];
};
var _withStableStyle = function(Component, styleProvider) {
  return /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _a = props, {
      _expressions = []
    } = _a, rest = __objRest(_a, [
      "_expressions"
    ]), theme = useTheme();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadValues({
      ref,
      style: styleProvider(theme, _expressions)
    }, rest));
  });
};
function setRef(ref, value) {
  typeof ref == "function" ? ref(value) : ref && (ref.current = value);
}
function composeRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return function(node) {
    return refs.forEach(function(ref) {
      return setRef(ref, node);
    });
  };
}
function useComposedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return React__namespace.useCallback(composeRefs(...refs), refs);
}
var defaultComponentState = {
  hover: false,
  press: false,
  pressIn: false,
  focus: false,
  focusVisible: false,
  focusWithin: false,
  unmounted: true,
  disabled: false
}, defaultComponentStateMounted = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: false
}), defaultComponentStateShouldEnter = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: "should-enter"
});
var matchMediaImpl = matchMediaFallback, matchMedia$1 = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
  return matchMediaImpl(...args);
};
function matchMediaFallback(query2) {
  return !process.env.IS_STATIC && false, {
    match: function(a, b2) {
      return false;
    },
    addListener: function() {
    },
    removeListener: function() {
    },
    matches: false
  };
}
function setupMatchMedia(_) {
  matchMediaImpl = _, globalThis.matchMedia = _;
}
exports.mediaState = // development only safeguard
{};
var mediaQueryConfig = {}, getMedia = function() {
  return exports.mediaState;
}, mediaKeys = /* @__PURE__ */ new Set(), mediaKeyRegex = /\$(platform|theme|group)-/, getMediaKey = function(key) {
  if (key[0] !== "$") return false;
  if (mediaKeys.has(key)) return true;
  var match = key.match(mediaKeyRegex);
  return match ? match[1] : false;
}, initState, mediaKeysOrdered, getMediaKeyImportance = function(key) {
  var conf2 = getConfig();
  return conf2.settings.mediaPropOrder ? defaultMediaImportance : mediaKeysOrdered.indexOf(key) + 100;
}, dispose = /* @__PURE__ */ new Set(), mediaVersion = 0, configureMedia = function(config) {
  var {
    media
  } = config, mediaQueryDefaultActive = getSetting("mediaQueryDefaultActive");
  if (media) {
    mediaVersion++;
    for (var key in media) exports.mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false, mediaKeys.add(`$${key}`);
    Object.assign(mediaQueryConfig, media), initState = __spreadValues({}, exports.mediaState), mediaKeysOrdered = Object.keys(media), setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach(function(cb) {
    return cb();
  }), dispose.clear();
}
var setupVersion = -1;
function setupMediaListeners() {
  var _loop2 = function(key2) {
    var str = mediaObjectToString(mediaQueryConfig[key2]), getMatch = function() {
      return matchMedia$1(str);
    }, match = getMatch();
    if (!match) throw new Error(" No match");
    match.addListener(update2), dispose.add(function() {
      match.removeListener(update2);
    });
    function update2() {
      var next = !!getMatch().matches;
      next !== exports.mediaState[key2] && (exports.mediaState = __spreadProps(__spreadValues({}, exports.mediaState), {
        [key2]: next
      }), updateMediaListeners());
    }
    update2();
  };
  if (!process.env.IS_STATIC && setupVersion !== mediaVersion) {
    setupVersion = mediaVersion, unlisten();
    for (var key in mediaQueryConfig) _loop2(key);
  }
}
var listeners = /* @__PURE__ */ new Set();
function updateMediaListeners() {
  listeners.forEach(function(cb) {
    return cb(exports.mediaState);
  });
}
var States = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, enabled, keys) {
  var cur = States.get(ref);
  (!cur || cur.enabled !== enabled || keys) && States.set(ref, __spreadProps(__spreadValues({}, cur), {
    enabled,
    keys
  }));
}
function subscribe(subscriber) {
  return listeners.add(subscriber), function() {
    listeners.delete(subscriber);
  };
}
function useMedia(componentContext, debug) {
  var componentState = componentContext ? States.get(componentContext) : null, internalRef = React.useRef(null);
  internalRef.current || (internalRef.current = {
    keys: /* @__PURE__ */ new Set(),
    lastState: exports.mediaState
  }), internalRef.current.pendingState && (internalRef.current.lastState = internalRef.current.pendingState, internalRef.current.pendingState = void 0);
  var {
    keys
  } = internalRef.current;
  keys.size && keys.clear();
  var state = React.useSyncExternalStore(subscribe, function() {
    var curKeys2 = (componentState == null ? void 0 : componentState.keys) || keys, {
      lastState,
      pendingState
    } = internalRef.current;
    if (!curKeys2.size) return lastState;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = curKeys2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;
        if (exports.mediaState[key] !== (pendingState || lastState)[key]) return false, (componentContext == null ? void 0 : componentContext.mediaEmit) ? (componentContext.mediaEmit(exports.mediaState), internalRef.current.pendingState = exports.mediaState, lastState) : (internalRef.current.lastState = exports.mediaState, exports.mediaState);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    return lastState;
  }, getServerSnapshot);
  return new Proxy(state, {
    get(_, key) {
      return !disableMediaTouch && typeof key == "string" && keys.add(key), Reflect.get(state, key);
    }
  });
}
var getServerSnapshot = function() {
  return initState;
}, disableMediaTouch = false;
function _disableMediaTouch(val) {
  disableMediaTouch = val;
}
function getMediaState(mediaGroups, layout) {
  disableMediaTouch = true;
  var res;
  try {
    res = Object.fromEntries([...mediaGroups].map(function(mediaKey) {
      return [mediaKey, mediaKeyMatch(mediaKey, layout)];
    }));
  } finally {
    disableMediaTouch = false;
  }
  return res;
}
var getMediaImportanceIfMoreImportant = function(mediaKey, key, styleState, isSizeMedia) {
  var importance = isSizeMedia && !getSetting("mediaPropOrder") ? getMediaKeyImportance(mediaKey) : defaultMediaImportance, usedKeys = styleState.usedKeys;
  return !usedKeys[key] || importance > usedKeys[key] ? importance : null;
};
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, function(m) {
    return `-${m.toLowerCase()}`;
  }).toLowerCase();
}
var cache$2 = /* @__PURE__ */ new WeakMap();
function mediaObjectToString(query2, key) {
  if (typeof query2 == "string") return query2;
  if (cache$2.has(query2)) return cache$2.get(query2);
  var res = Object.entries(query2).map(function(param) {
    var [feature, value] = param;
    return feature = camelToHyphen(feature), typeof value == "string" ? `(${feature}: ${value})` : (typeof value == "number" && /[height|width]$/.test(feature) && (value = `${value}px`), `(${feature}: ${value})`);
  }).join(" and ");
  return cache$2.set(query2, res), res;
}
function mediaKeyMatch(key, dimensions2) {
  var mediaQueries = mediaQueryConfig[key], result = Object.keys(mediaQueries).every(function(query2) {
    var expectedVal = +mediaQueries[query2], isMax = query2.startsWith("max"), isWidth = query2.endsWith("Width"), givenVal = dimensions2[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
  return result;
}
function getGroupPropParts(groupProp) {
  var mediaQueries = getMedia(), [_, name, part3, part4] = groupProp.split("-"), pseudo, media = part3 in mediaQueries ? part3 : void 0;
  return media ? pseudo = part4 : pseudo = part3, {
    name,
    pseudo,
    media
  };
}
var MEDIA_SEP = "_", prefixes = null, selectors = null, groupPseudoToPseudoCSSMap = {
  press: "active",
  focusVisible: "focus-visible",
  focusWithin: "focus-within"
}, specificities = new Array(5).fill(0).map(function(_, i) {
  return new Array(i).fill(":root").join("");
});
function getThemeOrGroupSelector(name, styleInner, isGroup, groupParts) {
  var isTheme = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false, precedenceImportancePrefix = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "", selectorStart = styleInner.lastIndexOf(":root") + 5, selectorEnd = styleInner.lastIndexOf("{"), selector = styleInner.slice(selectorStart, selectorEnd), precedenceSpace = getSetting("themeClassNameOnRoot") && isTheme ? "" : " ", pseudoSelectorName = groupParts.pseudo ? groupPseudoToPseudoCSSMap[groupParts.pseudo] || groupParts.pseudo : void 0, pseudoSelector = pseudoSelectorName ? `:${pseudoSelectorName}` : "", presedencePrefix = `:root${precedenceImportancePrefix}${precedenceSpace}`, mediaSelector = `.t_${isGroup ? "group_" : ""}${name}${pseudoSelector}`;
  return [selector, `${presedencePrefix}${mediaSelector} ${selector.replaceAll(":root", "")}`];
}
var createMediaStyle = function(styleObject, mediaKeyIn, mediaQueries, type, negate, priority) {
  var [propertyIn, , identifier, pseudoIn, rules] = styleObject, property = propertyIn, enableMediaPropOrder = getSetting("mediaPropOrder"), isTheme = type === "theme", isPlatform = type === "platform", isGroup = type === "group", isNonWindowMedia = isTheme || isPlatform || isGroup, negKey = negate ? "0" : "", ogPrefix = identifier.slice(0, identifier.indexOf("-") + 1), id2 = `${ogPrefix}${MEDIA_SEP}${mediaKeyIn.replace("-", "")}${negKey}${MEDIA_SEP}`, styleRule = "", groupPriority = "", groupMediaKey, containerName, nextIdentifier = identifier.replace(ogPrefix, id2), styleInner = rules.map(function(rule) {
    return rule.replace(identifier, nextIdentifier);
  }).join(";"), isHover = false;
  if (isNonWindowMedia) {
    var specificity = (priority || 0) + (isGroup || isPlatform ? 1 : 0);
    if (isTheme || isGroup) {
      var groupParts = getGroupPropParts(isTheme ? "theme-" + mediaKeyIn : mediaKeyIn), {
        name,
        media,
        pseudo
      } = groupParts;
      groupMediaKey = media, isGroup && (containerName = name), (pseudo === "press" || pseudoIn === "active") && (specificity += 2), pseudo === "hover" && (isHover = true);
      var [selector, nextSelector] = getThemeOrGroupSelector(name, styleInner, isGroup, groupParts, isTheme, specificities[specificity]);
      styleRule = styleInner.replace(selector, nextSelector);
    } else styleRule = `${specificities[specificity]}${styleInner}`;
  }
  if (!isNonWindowMedia || groupMediaKey) {
    if (!selectors) {
      var mediaKeys2 = Object.keys(mediaQueries);
      selectors = Object.fromEntries(mediaKeys2.map(function(key) {
        return [key, mediaObjectToString(mediaQueries[key])];
      })), enableMediaPropOrder || (prefixes = Object.fromEntries(mediaKeys2.map(function(k, index2) {
        return [k, new Array(index2 + 1).fill(":root").join("")];
      })));
    }
    var mediaKey = groupMediaKey || mediaKeyIn, mediaSelector = selectors[mediaKey], screenStr = negate ? "not all and " : "", mediaQuery = `${screenStr}${mediaSelector}`, precedenceImportancePrefix = groupMediaKey ? groupPriority : enableMediaPropOrder && priority ? (
      // this new array should be cached
      specificities[priority]
    ) : (
      // @ts-ignore
      prefixes[mediaKey]
    ), prefix = groupMediaKey ? `@container ${containerName}` : "@media";
    groupMediaKey && (styleInner = styleRule), styleInner.includes(prefix) ? styleRule = styleInner.replace("{", ` and ${mediaQuery} {`).replace("and screen and", "and") : styleRule = `${prefix} ${mediaQuery}{${precedenceImportancePrefix}${styleInner}}`, groupMediaKey && (styleRule = `@supports (contain: ${getSetting("webContainerType") || "inline-size"}) {${styleRule}}`);
  }
  return isHover && (styleRule = `@media (hover:hover){${styleRule}}`), [property, void 0, nextIdentifier, void 0, [styleRule]];
};
var defaultOffset = {
  height: 0,
  width: 0
};
var normalizeColor = function(color, opacity) {
  if (color) {
    if (color[0] === "$") return color;
    if (color.startsWith("var(")) {
      if (typeof opacity == "number" && opacity < 1) return `color-mix(in srgb, ${color} ${opacity * 100}%, transparent)`;
    } else {
      var rgba3 = getRgba(color);
      if (rgba3) {
        var colors = `${rgba3.r},${rgba3.g},${rgba3.b}`, _ref;
        return opacity === 1 ? `rgb(${colors})` : `rgba(${colors},${(_ref = opacity != null ? opacity : rgba3.a) !== null && _ref !== void 0 ? _ref : 1})`;
      }
    }
    return color;
  }
}, getRgba = function(color) {
  var colorNum = normalizeCSSColor(color);
  if (colorNum != null) return rgba(colorNum);
};
function normalizeShadow(param) {
  var {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius
  } = param, _getRgba, {
    height,
    width
  } = shadowOffset || defaultOffset;
  return {
    shadowOffset: {
      width: width || 0,
      height: height || 0
    },
    shadowRadius: shadowRadius || 0,
    shadowColor: normalizeColor(shadowColor, 1),
    shadowOpacity: shadowOpacity != null ? shadowOpacity : shadowColor ? (_getRgba = getRgba(shadowColor)) === null || _getRgba === void 0 ? void 0 : _getRgba.a : 1
  };
}
function fixStyles(style) {
  "elevationAndroid" in style && (style.elevation = style.elevationAndroid, delete style.elevationAndroid), (style.shadowRadius != null || style.shadowColor || style.shadowOpacity != null || style.shadowOffset) && Object.assign(style, normalizeShadow(style));
  for (var key in borderDefaults) if (key in style) {
    var _style, _borderDefaults_key;
    (_style = style)[_borderDefaults_key = borderDefaults[key]] || (_style[_borderDefaults_key] = "solid");
  }
}
var nativeStyle = "borderStyle", borderDefaults = {
  borderWidth: "borderStyle",
  borderBottomWidth: nativeStyle,
  borderTopWidth: nativeStyle,
  borderLeftWidth: nativeStyle,
  borderRightWidth: nativeStyle
};
var empty = function() {
  console.warn("no-op native");
}, getCSSStylesAtomic = empty, getStyleAtomic = empty, styleToCSS = empty;
function scanAllSheets() {
}
process.env.TAMAGUI_BAIL_AFTER_SCANNING_X_CSS_RULES;
function setNonce(_) {
}
function insertStyleRules(rulesToInsert) {
}
process.env.TAMAGUI_INSERT_SELECTOR_TRIES ? +process.env.TAMAGUI_INSERT_SELECTOR_TRIES : 1;
function isActivePlatform(key) {
  if (!key.startsWith("$platform")) return true;
  var platform = key.slice(10);
  return (
    // web, ios, android
    platform === currentPlatform || // web, native
    platform === "native"
  );
}
function isActiveTheme(key, activeThemeName) {
  if (key.startsWith("$theme-")) return key.slice(7).startsWith(activeThemeName);
}
__spreadValues({}, stylePropsAll);
function normalizeValueWithProperty(value) {
  return value;
}
var _loop$1 = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  expansionsNoPrefix[parent] = expansionsNoPrefix[parent].map(function(k) {
    return `${prefix}${k}`;
  });
}, resizeModeMap = {
  fill: "stretch",
  none: "center",
  "scale-down": "contain",
  contain: "contain",
  cover: "cover"
}, verticalAlignMap = {
  top: "top",
  middle: "center",
  bottom: "bottom",
  auto: "auto"
}, webToNativeDynamicExpansion = {
  objectFit: function(val) {
    var resizeMode = resizeModeMap[val] || "cover";
    return [["resizeMode", resizeMode]];
  },
  verticalAlign: function(val) {
    return [["textAlignVertical", verticalAlignMap[val] || "auto"]];
  }
}, vert$1 = ["Top", "Bottom"], es = ["End", "Start"], t = ["Top"], b = ["Bottom"], s = ["Start"], e = ["End"], h = ["Height"], w = ["Width"], expansionsNoPrefix = {
  borderBlockColor: ["TopColor", "BottomColor"],
  borderInlineColor: ["EndColor", "StartColor"],
  borderBlockWidth: ["TopWidth", "BottomWidth"],
  borderInlineWidth: ["EndWidth", "StartWidth"],
  borderBlockStyle: ["TopStyle", "BottomStyle"],
  borderInlineStyle: ["EndStyle", "StartStyle"],
  marginBlock: vert$1,
  marginInline: es,
  paddingBlock: vert$1,
  paddingInline: es,
  borderBlockStartColor: ["TopColor"],
  borderBlockEndColor: ["BottomColor"],
  borderInlineStartColor: ["StartColor"],
  borderInlineEndColor: ["EndColor"],
  borderBlockStartWidth: ["TopWidth"],
  borderBlockEndWidth: ["BottomWidth"],
  borderInlineStartWidth: ["StartWidth"],
  borderInlineEndWidth: ["EndWidth"],
  borderBlockStartStyle: ["TopStyle"],
  borderBlockEndStyle: ["BottomStyle"],
  borderInlineStartStyle: ["StartStyle"],
  borderInlineEndStyle: ["EndStyle"],
  marginBlockStart: t,
  marginBlockEnd: b,
  marginInlineStart: s,
  marginInlineEnd: e,
  paddingBlockStart: t,
  paddingBlockEnd: b,
  paddingInlineStart: s,
  paddingInlineEnd: e,
  minBlockSize: h,
  maxBlockSize: h,
  minInlineSize: w,
  maxInlineSize: w
};
for (var parent$1 in expansionsNoPrefix) _loop$1(parent$1);
var expansions = {
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  blockSize: ["height"],
  inlineSize: ["width"]
}, webToNativeExpansion = Object.assign(expansionsNoPrefix, expansions);
var _loop = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  EXPANSIONS[parent] = EXPANSIONS[parent].map(function(k) {
    return `${prefix}${k}`;
  });
};
function expandStyle(key, value) {
  if (isAndroid && key === "elevationAndroid") return [["elevation", value]];
  if (key in EXPANSIONS) return EXPANSIONS[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeExpansion) return webToNativeExpansion[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeDynamicExpansion) return webToNativeDynamicExpansion[key](value);
}
var all = ["Top", "Right", "Bottom", "Left"], horiz = ["Right", "Left"], vert = ["Top", "Bottom"], xy = ["X", "Y"], EXPANSIONS = __spreadValues({
  borderColor: ["TopColor", "RightColor", "BottomColor", "LeftColor"],
  borderRadius: ["TopLeftRadius", "TopRightRadius", "BottomRightRadius", "BottomLeftRadius"],
  borderWidth: ["TopWidth", "RightWidth", "BottomWidth", "LeftWidth"],
  margin: all,
  marginHorizontal: horiz,
  marginVertical: vert,
  overscrollBehavior: xy,
  padding: all,
  paddingHorizontal: horiz,
  paddingVertical: vert
}, isWeb);
for (var parent in EXPANSIONS) _loop(parent);
var cache$1 = /* @__PURE__ */ new WeakMap(), getVariantExtras = function(styleState) {
  if (cache$1.has(styleState)) return cache$1.get(styleState);
  var {
    props,
    conf: conf2,
    context,
    theme,
    styleProps: styleProps2
  } = styleState, fonts = conf2.fontsParsed;
  (context == null ? void 0 : context.language) && (fonts = getFontsForLanguage(conf2.fontsParsed, context.language));
  var next = {
    fonts,
    tokens: conf2.tokensParsed,
    theme,
    context: styleProps2 == null ? void 0 : styleProps2.styledContext,
    get fontFamily() {
      return getVariableValue(styleState.fontFamily || styleState.props.fontFamily) || props.fontFamily || getVariableValue(getSetting("defaultFont"));
    },
    get font() {
      return fonts[this.fontFamily] || (!props.fontFamily || props.fontFamily[0] === "$" ? fonts[getSetting("defaultFont") || ""] : void 0);
    },
    props
  };
  return cache$1.set(styleState, next), next;
}, fontLanguageCache = /* @__PURE__ */ new WeakMap();
function getFontsForLanguage(fonts, language) {
  if (fontLanguageCache.has(language)) return fontLanguageCache.get(language);
  var next = __spreadValues(__spreadValues({}, fonts), Object.fromEntries(Object.entries(language).map(function(param) {
    var [name, lang] = param;
    if (lang === "default") return [];
    var langKey = `$${name}_${lang}`;
    return [`$${name}`, fonts[langKey]];
  })));
  return fontLanguageCache.set(language, next), next;
}
function _type_of$4(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var isObj = function(x) {
  return x && !Array.isArray(x) && (typeof x > "u" ? "undefined" : _type_of$4(x)) === "object";
};
function normalizeStyle$1(style) {
  var disableNormalize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, res = {};
  for (var key in style) {
    var prop = style[key];
    if (prop != null) {
      if (key in pseudoDescriptors || // this should capture all parent-based styles like media, group, etc
      key[0] === "$" && isObj(prop)) {
        res[key] = normalizeStyle$1(prop, disableNormalize);
        continue;
      }
      var value = disableNormalize ? prop : normalizeValueWithProperty(prop), out = expandStyle(key, value);
      out ? Object.assign(res, Object.fromEntries(out)) : res[key] = value;
    }
  }
  return fixStyles(res), res;
}
var webPropsToSkip = {
  whiteSpace: 1,
  wordWrap: 1,
  textOverflow: 1,
  textDecorationDistance: 1,
  cursor: 1,
  contain: 1,
  boxSizing: 1,
  touchAction: 1,
  outlineStyle: 1,
  outlineOffset: 1,
  outlineWidth: 1,
  outlineColor: 1,
  backdropFilter: 1,
  backgroundImage: 1,
  mixBlendMode: 1,
  scrollbarWidth: 1,
  backgroundOrigin: 1,
  backgroundPosition: 1,
  backgroundRepeat: 1,
  backgroundSize: 1,
  backgroundClip: 1,
  backgroundBlendMode: 1,
  backgroundAttachment: 1,
  background: 1,
  clipPath: 1,
  caretColor: 1,
  transformStyle: 1,
  mask: 1,
  maskImage: 1,
  textEmphasis: 1,
  borderImage: 1,
  float: 1,
  content: 1,
  overflowBlock: 1,
  overflowInline: 1,
  maskBorder: 1,
  maskBorderMode: 1,
  maskBorderOutset: 1,
  maskBorderRepeat: 1,
  maskBorderSlice: 1,
  maskBorderSource: 1,
  maskBorderWidth: 1,
  maskClip: 1,
  maskComposite: 1,
  maskMode: 1,
  maskOrigin: 1,
  maskPosition: 1,
  maskRepeat: 1,
  maskSize: 1,
  maskType: 1
};
var skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1,
  themeInverse: 1,
  animatePresence: 1
};
Object.assign(skipProps, webPropsToSkip);
function _type_of$3(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var propMapper = function(key, value, styleState, disabled, map) {
  if (disabled) return map(key, value);
  if (lastFontFamilyToken = null, !(!isAndroid && key === "elevationAndroid")) {
    var {
      conf: conf2,
      styleProps: styleProps2,
      staticConfig
    } = styleState;
    if (value === "unset") {
      var _conf_unset, unsetVal = (_conf_unset = conf2.unset) === null || _conf_unset === void 0 ? void 0 : _conf_unset[key];
      if (unsetVal != null) value = unsetVal;
      else return;
    }
    var {
      variants
    } = staticConfig;
    if (!styleProps2.noExpand && variants && key in variants) {
      var variantValue = resolveVariants(key, value, styleProps2, styleState, "");
      if (variantValue) {
        variantValue.forEach(function(param) {
          var [_$key, _$value] = param;
          return map(_$key, _$value);
        });
        return;
      }
    }
    styleProps2.disableExpandShorthands || key in conf2.shorthands && (key = conf2.shorthands[key]);
    var originalValue = value;
    if (value != null && (value[0] === "$" ? value = getTokenForKey(key, value, styleProps2, styleState) : isVariable(value) && (value = resolveVariableValue(key, value, styleProps2.resolveValues))), value != null) {
      key === "fontFamily" && lastFontFamilyToken && (styleState.fontFamily = lastFontFamilyToken);
      var expanded = styleProps2.noExpand ? null : expandStyle(key, value);
      if (expanded) for (var max = expanded.length, i = 0; i < max; i++) {
        var [nkey, nvalue] = expanded[i];
        map(nkey, nvalue, originalValue);
      }
      else map(key, value, originalValue);
    }
  }
}, resolveVariants = function(key, value, styleProps2, styleState, parentVariantKey) {
  var {
    staticConfig,
    conf: conf2,
    debug
  } = styleState, {
    variants
  } = staticConfig;
  if (variants) {
    var variantValue = getVariantDefinition(variants[key], value, conf2);
    if (!variantValue) {
      if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1" && typeof value != "boolean") {
        var name = staticConfig.componentName || "[UnnamedComponent]";
        console.warn(`No variant found: ${name} has variant "${key}", but no matching value "${value}"`);
      }
      return;
    }
    if (typeof variantValue == "function") {
      var fn = variantValue, extras = getVariantExtras(styleState);
      variantValue = fn(value, extras);
    }
    var fontFamilyResult;
    if (isObj(variantValue)) {
      var fontFamilyUpdate = variantValue.fontFamily || variantValue[conf2.inverseShorthands.fontFamily];
      fontFamilyUpdate && (fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf2), styleState.fontFamily = fontFamilyResult, false), variantValue = resolveTokensAndVariants(key, variantValue, styleProps2, styleState, parentVariantKey);
    }
    if (variantValue) {
      var expanded = normalizeStyle$1(variantValue, !!styleProps2.noNormalize);
      var next = Object.entries(expanded);
      return fontFamilyResult && fontFamilyResult[0] === "$" && (lastFontFamilyToken = getVariableValue(fontFamilyResult)), next;
    }
  }
};
function getFontFamilyFromNameOrVariable(input, conf2) {
  if (isVariable(input)) {
    var val = variableToFontNameCache.get(input);
    if (val) return val;
    for (var key in conf2.fontsParsed) {
      var familyVariable = conf2.fontsParsed[key].family;
      if (isVariable(familyVariable) && (variableToFontNameCache.set(familyVariable, key), familyVariable === input)) return key;
    }
  } else if (typeof input == "string" && input[0] === "$") return input;
}
var variableToFontNameCache = /* @__PURE__ */ new WeakMap(), resolveTokensAndVariants = function(key, value, styleProps2, styleState, parentVariantKey) {
  var {
    conf: conf2,
    staticConfig,
    debug,
    theme
  } = styleState, {
    variants
  } = staticConfig, res = {};
  for (var _key in value) {
    var subKey = conf2.shorthands[_key] || _key, val = value[_key];
    if (!(!styleProps2.noSkip && subKey in skipProps)) {
      if (staticConfig) {
        var _staticConfig_context, _staticConfig_parentStaticConfig_context, _staticConfig_parentStaticConfig, contextProps = ((_staticConfig_context = staticConfig.context) === null || _staticConfig_context === void 0 ? void 0 : _staticConfig_context.props) || ((_staticConfig_parentStaticConfig = staticConfig.parentStaticConfig) === null || _staticConfig_parentStaticConfig === void 0 || (_staticConfig_parentStaticConfig_context = _staticConfig_parentStaticConfig.context) === null || _staticConfig_parentStaticConfig_context === void 0 ? void 0 : _staticConfig_parentStaticConfig_context.props);
        if (contextProps && subKey in contextProps) {
          var _styleState, _styleState1;
          (_styleState = styleState).overriddenContextProps || (_styleState.overriddenContextProps = {}), styleState.overriddenContextProps[subKey] = val, (_styleState1 = styleState).originalContextPropValues || (_styleState1.originalContextPropValues = {}), styleState.originalContextPropValues[subKey] = val;
        }
      }
      if (styleProps2.noExpand) res[subKey] = val;
      else if (variants && subKey in variants) {
        if (parentVariantKey && parentVariantKey === key) res[subKey] = // SYNC WITH *1
        val[0] === "$" ? getTokenForKey(subKey, val, styleProps2, styleState) : val;
        else {
          var variantOut = resolveVariants(subKey, val, styleProps2, styleState, key);
          if (variantOut) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
            try {
              for (var _iterator = variantOut[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var [_$key, val1] = _step.value;
                if (val1 != null) if (_$key in pseudoDescriptors) {
                  var _res, _key1, _;
                  (_ = (_res = res)[_key1 = _$key]) !== null && _ !== void 0 || (_res[_key1] = {}), Object.assign(res[_$key], val1);
                } else res[_$key] = val1;
              }
            } catch (err) {
              _didIteratorError = true, _iteratorError = err;
            } finally {
              try {
                !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError) throw _iteratorError;
              }
            }
          }
        }
        continue;
      }
      if (isVariable(val)) {
        res[subKey] = resolveVariableValue(subKey, val, styleProps2.resolveValues);
        continue;
      }
      if (typeof val == "string") {
        var fVal = (
          // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps2, styleState) : val
        );
        res[subKey] = fVal;
        continue;
      }
      if (isObj(val)) {
        var _res1, _subKey, subObject = resolveTokensAndVariants(subKey, val, styleProps2, styleState, key);
        var _1;
        (_1 = (_res1 = res)[_subKey = subKey]) !== null && _1 !== void 0 || (_res1[_subKey] = {}), Object.assign(res[subKey], subObject);
      } else res[subKey] = val;
    }
  }
  return res;
}, tokenCats = ["size", "color", "radius", "space", "zIndex"].map(function(name) {
  return {
    name,
    spreadName: `...${name}`
  };
});
function getVariantDefinition(variant, value, conf2) {
  if (variant) {
    if (typeof variant == "function") return variant;
    var exact = variant[value];
    if (exact) return exact;
    if (value != null) {
      var {
        tokensParsed
      } = conf2, _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = tokenCats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var {
            name,
            spreadName
          } = _step.value;
          if (spreadName in variant && name in tokensParsed && value in tokensParsed[name]) return variant[spreadName];
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
      var fontSizeVariant = variant["...fontSize"];
      if (fontSizeVariant && conf2.fontSizeTokens.has(value)) return fontSizeVariant;
    }
    return variant[`:${typeof value > "u" ? "undefined" : _type_of$3(value)}`] || variant["..."];
  }
}
var fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
}, lastFontFamilyToken = null, getTokenForKey = function(key, value, styleProps2, styleState) {
  var _staticConfig_accept, resolveAs = styleProps2.resolveValues || "none";
  if (resolveAs === "none") return value;
  var {
    theme,
    conf: conf2 = getConfig(),
    context,
    fontFamily,
    staticConfig
  } = styleState, themeValue = theme ? theme[value] || theme[value.slice(1)] : void 0, tokensParsed = conf2.tokensParsed, valOrVar, hasSet = false, customTokenAccept = staticConfig == null || (_staticConfig_accept = staticConfig.accept) === null || _staticConfig_accept === void 0 ? void 0 : _staticConfig_accept[key];
  if (customTokenAccept) {
    var val = themeValue != null ? themeValue : tokensParsed[customTokenAccept][value];
    val != null && (resolveAs = "value", valOrVar = val, hasSet = true);
  }
  if (themeValue) {
    if (resolveAs === "except-theme") return value;
    valOrVar = themeValue, hasSet = true;
  } else {
    if (value in conf2.specificTokens) hasSet = true, valOrVar = conf2.specificTokens[value];
    else {
      switch (key) {
        case "fontFamily": {
          var _fontsParsed_value, fontsParsed = (context == null ? void 0 : context.language) ? getFontsForLanguage(conf2.fontsParsed, context.language) : conf2.fontsParsed;
          valOrVar = ((_fontsParsed_value = fontsParsed[value]) === null || _fontsParsed_value === void 0 ? void 0 : _fontsParsed_value.family) || value, lastFontFamilyToken = value, hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          var fam = fontFamily || conf2.defaultFontToken;
          if (fam) {
            var _font_, fontsParsed1 = (context == null ? void 0 : context.language) ? getFontsForLanguage(conf2.fontsParsed, context.language) : conf2.fontsParsed, font = fontsParsed1[fam] || fontsParsed1[conf2.defaultFontToken];
            valOrVar = (font == null || (_font_ = font[fontShorthand[key] || key]) === null || _font_ === void 0 ? void 0 : _font_[value]) || value, hasSet = true;
          }
          break;
        }
      }
      for (var cat in tokenCategories) if (key in tokenCategories[cat]) {
        var _tokensParsed_cat, res = (_tokensParsed_cat = tokensParsed[cat]) === null || _tokensParsed_cat === void 0 ? void 0 : _tokensParsed_cat[value];
        res != null ? (valOrVar = res, hasSet = true) : false;
      }
    }
    if (!hasSet) {
      var spaceVar = tokensParsed.space[value];
      spaceVar != null && (valOrVar = spaceVar, hasSet = true);
    }
  }
  if (hasSet) {
    var out = resolveVariableValue(key, valOrVar, resolveAs);
    return out;
  }
};
function resolveVariableValue(key, valOrVar, resolveValues) {
  if (resolveValues === "none") return valOrVar;
  if (isVariable(valOrVar)) {
    if (resolveValues === "value") return valOrVar.val;
    var get = valOrVar == null ? void 0 : valOrVar.get;
    if (key !== "shadowColor" && typeof get == "function") {
      var resolveDynamicFor = resolveValues === "web" ? "web" : void 0;
      return get(resolveDynamicFor);
    }
    return valOrVar.val;
  }
  return valOrVar;
}
var sortString = function(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
};
function transformsToString(transforms) {
  return transforms.map(
    // { scale: 2 } => 'scale(2)'
    // { translateX: 20 } => 'translateX(20px)'
    // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
    // { perspective: 1000 } => perspective(1000px)
    function(transform) {
      var type = Object.keys(transform)[0], value = transform[type];
      return type === "matrix" || type === "matrix3d" ? `${type}(${value.join(",")})` : `${type}(${normalizeValueWithProperty(value)})`;
    }
  ).join(" ");
}
function _type_of$2(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var conf, styleOriginalValues = /* @__PURE__ */ new WeakMap(), PROP_SPLIT = "-";
function normalizeGroupKey(key, groupContext) {
  var parts = key.split("-"), plen = parts.length;
  if (
    // check if its actually a simple group selector to avoid breaking selectors
    plen === 2 || plen === 3 && pseudoPriorities[parts[parts.length - 1]]
  ) {
    var name = parts[1];
    if (groupContext && !groupContext[name]) return key.replace("$group-", "$group-true-");
  }
  return key;
}
function isValidStyleKey(key, validStyles2, accept) {
  return key in validStyles2 ? true : accept && key in accept;
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps2, parentSplitStyles, componentContext, groupContext, elementType, startedUnhydrated, debug) {
  var _loop2 = function(keyOg2) {
    var keyInit = keyOg2, valInit = props[keyInit];
    if (keyInit === "children") return viewProps[keyInit] = valInit, "continue";
    if (accept) {
      var accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && (typeof valInit > "u" ? "undefined" : _type_of$2(valInit)) === "object") return viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps2.noClass), "continue";
    }
    if (disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className") return "continue";
    if (keyInit in skipProps && !noSkip && !isHOC) {
      return "continue";
    }
    var isValidStyleKeyInit = isValidStyleKey(keyInit, validStyles$1, accept);
    if (!isValidStyleKeyInit) {
      if (!isAndroid && keyInit === "elevationAndroid") return "continue";
      if (keyInit === "userSelect") keyInit = "selectable", valInit = valInit !== "none";
      else if (keyInit.startsWith("data-")) return "continue";
    }
    if (keyInit === "dataSet") {
      for (var keyInit1 in valInit) viewProps[`data-${hyphenate(keyInit1)}`] = valInit[keyInit1];
      return "continue";
    }
    var isVariant = !isValidStyleKeyInit && variants && keyInit in variants, isStyleLikeKey = isValidStyleKeyInit || isVariant, isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo ? getMediaKey(keyInit) : false, isMediaOrPseudo = !!(isMedia || isPseudo);
    isMediaOrPseudo && isMedia === "group" && (keyInit = normalizeGroupKey(keyInit, groupContext));
    var isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web")) return "continue";
    var shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentVariants == null ? void 0 : parentVariants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant)) return "continue";
    if (!noSkip && keyInit in skipProps) return "continue";
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
    var disablePropMap = isMediaOrPseudo || !isStyleLikeKey;
    if (propMapper(keyInit, valInit, styleState, disablePropMap, function(key4, val2, originalVal) {
      var _parentStaticConfig_variants, isStyledContextProp = styledContext && key4 in styledContext;
      if (!isHOC && disablePropMap && !isStyledContextProp && !isMediaOrPseudo) {
        viewProps[key4] = val2;
        return;
      }
      if (val2 != null) {
        if (key4 === "pointerEvents") {
          viewProps[key4] = val2;
          return;
        }
        if (!isHOC && isValidStyleKey(key4, validStyles$1, accept) || isAndroid && key4 === "elevation") {
          mergeStyle(styleState, key4, val2, 1, false, originalVal);
          return;
        }
        if (isPseudo = key4 in validPseudoKeys, isMedia = isPseudo ? false : getMediaKey(key4), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants && key4 in variants, isMedia === "group" && (key4 = normalizeGroupKey(key4, groupContext)), (inlineProps == null ? void 0 : inlineProps.has(key4)) || process.env.IS_STATIC === "is_static" && (inlineWhenUnflattened == null ? void 0 : inlineWhenUnflattened.has(key4))) {
          var _props_key;
          viewProps[key4] = (_props_key = props[key4]) !== null && _props_key !== void 0 ? _props_key : val2;
        }
        var shouldPassThrough2 = styleProps2.noExpand && isPseudo || isHOC && (isMediaOrPseudo || (parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit]));
        if (shouldPassThrough2) {
          passDownProp(viewProps, key4, val2, isMediaOrPseudo);
          return;
        }
        if (isPseudo) {
          if (!val2) return;
          var pseudoStyleObject = getSubStyle(styleState, key4, val2, styleProps2.noClass && process.env.IS_STATIC !== "is_static");
          {
            var _pseudos, _key;
            if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key4] || (_pseudos[_key] = {}), process.env.IS_STATIC === "is_static") {
              Object.assign(pseudos[key4], pseudoStyleObject);
              return;
            }
          }
          var descriptor = pseudoDescriptors[key4], isEnter = key4 === "enterStyle", isExit = key4 === "exitStyle";
          if (!descriptor) return;
          {
            var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = componentState[descriptorKey] === false;
            isExit && (isDisabled2 = !styleProps2.isExiting), isEnter && componentState.unmounted === false && (isDisabled2 = true);
            var importance = descriptor.priority, pseudoOriginalValues = styleOriginalValues.get(pseudoStyleObject);
            for (var pkey in pseudoStyleObject) {
              var _$val = pseudoStyleObject[pkey];
              if (isDisabled2) applyDefaultStyle(pkey, styleState);
              else {
                var curImportance = styleState.usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                if (shouldMerge) {
                  if (process.env.IS_STATIC === "is_static") {
                    var _pseudos1, _key1;
                    pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key4] || (_pseudos1[_key1] = {}), pseudos[key4][pkey] = _$val;
                  }
                  mergeStyle(styleState, pkey, _$val, importance, false, pseudoOriginalValues == null ? void 0 : pseudoOriginalValues[pkey]);
                }
              }
            }
            if (!isDisabled2) for (var _$key in val2) {
              var k = shorthands[_$key] || _$key;
              styleState.usedKeys[k] = Math.max(importance, styleState.usedKeys[k] || 0);
            }
          }
          return;
        }
        if (isMedia) {
          if (!val2) return;
          val2.space;
          var mediaKeyShort = key4.slice(isMedia == "theme" ? 7 : 1);
          if (hasMedia || (hasMedia = true), (!hasMedia || typeof hasMedia == "boolean") && (hasMedia = /* @__PURE__ */ new Set()), hasMedia.add(mediaKeyShort), isMedia === "platform" && !isActivePlatform(key4)) return;
          var priority = mediaStylesSeen;
          if (mediaStylesSeen += 1, shouldDoClasses) ;
          else {
            let mergeMediaStyle2 = function(key5, val3, originalVal2) {
              var _styleState4;
              (_styleState4 = styleState).style || (_styleState4.style = {});
              var didMerge = mergeMediaByImportance(styleState, mediaKeyShort, key5, val3, mediaState[mediaKeyShort], importanceBump, debug, originalVal2);
              didMerge && key5 === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
            };
            var isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
            if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
              if (!mediaState[mediaKeyShort]) {
                return;
              }
            }
            var mediaStyle1 = getSubStyle(styleState, key4, val2, true), importanceBump = 0;
            if (isThemeMedia) {
              if (dynamicThemeAccess = true, isIos && getSetting("fastSchemeChange")) {
                var _styleState3;
                (_styleState3 = styleState).style || (_styleState3.style = {});
                var scheme = mediaKeyShort, oppositeScheme = getOppositeScheme(mediaKeyShort), themeOriginalValues = styleOriginalValues.get(mediaStyle1);
                for (var subKey1 in mediaStyle1) {
                  var _$val1 = extractValueFromDynamic(mediaStyle1[subKey1], scheme), oppositeVal = extractValueFromDynamic(styleState.style[subKey1], oppositeScheme);
                  mediaStyle1[subKey1] = getDynamicVal({
                    scheme,
                    val: _$val1,
                    oppositeVal
                  }), mergeStyle(styleState, subKey1, mediaStyle1[subKey1], priority, false, themeOriginalValues == null ? void 0 : themeOriginalValues[subKey1]);
                }
              } else if (!(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort))) return;
            } else if (isGroupMedia) {
              var _groupContext_groupName, _componentState_group, groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupState = groupContext == null || (_groupContext_groupName = groupContext[groupName]) === null || _groupContext_groupName === void 0 ? void 0 : _groupContext_groupName.state, groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media;
              if (!groupState) {
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set());
                return;
              }
              var componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
              if (groupMediaKey) {
                mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
                var mediaState1 = componentGroupState == null ? void 0 : componentGroupState.media, isActive = mediaState1 == null ? void 0 : mediaState1[groupMediaKey];
                if (!mediaState1 && groupState.layout && (isActive = mediaKeyMatch(groupMediaKey, groupState.layout)), !isActive) {
                  for (var pkey1 in mediaStyle1) applyDefaultStyle(pkey1, styleState);
                  return;
                }
                importanceBump = 2;
              }
              if (groupPseudoKey) {
                var _this;
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
                var componentGroupPseudoState = (_this = componentGroupState || (groupContext == null ? void 0 : groupContext[groupName].state)) === null || _this === void 0 ? void 0 : _this.pseudo, isActive1 = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey], priority1 = pseudoPriorities[groupPseudoKey];
                if (!isActive1) {
                  for (var pkey2 in mediaStyle1) applyDefaultStyle(pkey2, styleState);
                  return;
                }
                importanceBump = priority1;
              }
            }
            var mediaOriginalValues = styleOriginalValues.get(mediaStyle1);
            for (var subKey2 in mediaStyle1) {
              if (subKey2 === "space") {
                space = valInit.space;
                continue;
              }
              if (subKey2[0] === "$") {
                if (!isActivePlatform(subKey2) || !isActiveTheme(subKey2, themeName)) continue;
                var subOriginalValues = styleOriginalValues.get(mediaStyle1[subKey2]);
                for (var subSubKey in mediaStyle1[subKey2]) mergeMediaStyle2(subSubKey, mediaStyle1[subKey2][subSubKey], subOriginalValues == null ? void 0 : subOriginalValues[subSubKey]);
              } else mergeMediaStyle2(subKey2, mediaStyle1[subKey2], mediaOriginalValues == null ? void 0 : mediaOriginalValues[subKey2]);
            }
          }
          return;
        }
        if (!isVariant) {
          if (isStyledContextProp) return;
          viewProps[key4] = val2;
        }
      }
    }), false) ;
  };
  conf = conf || getConfig();
  (componentContext == null ? void 0 : componentContext.animationDriver) || conf.animations;
  if (props.passThrough) return null;
  var {
    shorthands
  } = conf, {
    isHOC,
    isText,
    isInput,
    variants,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState = styleProps2.mediaState || exports.mediaState, shouldDoClasses = acceptsClassName && isWeb, rulesToInsert = void 0, classNames = {}, pseudos = null, space = props.space, hasMedia = false, dynamicThemeAccess, pseudoGroups, mediaGroups;
  props.className || "";
  var mediaStylesSeen = 0, validStyles$1 = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  var styleState = {
    classNames,
    conf,
    props,
    styleProps: styleProps2,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys: {},
    viewProps,
    context: componentContext,
    debug
  };
  if (process.env.IS_STATIC === "is_static") {
    var {
      fallbackProps
    } = styleProps2;
    fallbackProps && (styleState.props = new Proxy(props, {
      get(_, key4, val2) {
        return Reflect.has(props, key4) ? Reflect.get(props, key4) : Reflect.get(fallbackProps, key4);
      }
    }));
  }
  var {
    asChild
  } = props, {
    accept
  } = staticConfig, {
    noSkip,
    disableExpandShorthands,
    noExpand,
    styledContext
  } = styleProps2, {
    webContainerType
  } = conf.settings, parentVariants = parentStaticConfig == null ? void 0 : parentStaticConfig.variants;
  for (var keyOg in props) _loop2(keyOg);
  var avoidNormalize = styleProps2.noNormalize === false;
  if (!avoidNormalize) {
    if (styleState.style && (fixStyles(styleState.style), !styleProps2.noExpand && !styleProps2.noMergeStyle && isWeb), styleState.flatTransforms) {
      var _styleState;
      (_styleState = styleState).style || (_styleState.style = {}), mergeFlatTransforms(styleState.style, styleState.flatTransforms);
    }
    if (parentSplitStyles) {
      for (var key1 in parentSplitStyles.style) {
        var _styleState1;
        key1 in classNames || styleState.style && key1 in styleState.style || ((_styleState1 = styleState).style || (_styleState1.style = {}), styleState.style[key1] = parentSplitStyles.style[key1]);
      }
    }
  }
  var styleProp = props.style;
  if (!styleProps2.noMergeStyle && styleProp) if (isHOC) viewProps.style = normalizeStyle(styleProp);
  else for (var isArray2 = Array.isArray(styleProp), len = isArray2 ? styleProp.length : 1, i = 0; i < len; i++) {
    var style = isArray2 ? styleProp[i] : styleProp;
    if (style) if (style.$$css) Object.assign(styleState.classNames, style);
    else {
      var _styleState2;
      (_styleState2 = styleState).style || (_styleState2.style = {}), Object.assign(styleState.style, normalizeStyle(style));
    }
  }
  if (viewProps.tabIndex === 0) {
    var _viewProps1, _accessible1;
    (_accessible1 = (_viewProps1 = viewProps).accessible) !== null && _accessible1 !== void 0 || (_viewProps1.accessible = true);
  }
  var style1 = styleState.style;
  if (style1 == null ? void 0 : style1.fontFamily) {
    var _getFont, faceInfo = (_getFont = getFont(style1.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style1.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style1.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style1.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style1.fontWeight, delete style1.fontStyle);
    }
  }
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups,
    overriddenContextProps: styleState.overriddenContextProps
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!styleProps2.noMergeStyle && !asChildExceptStyleLike) {
    var style2 = styleState.style;
    style2 && (viewProps.style = style2);
  }
  return result;
};
function mergeFlatTransforms(target, flatTransforms) {
  Object.entries(flatTransforms).sort(function(param, param1) {
    var [a] = param, [b2] = param1;
    return sortString(a, b2);
  }).forEach(function(param) {
    var [key, val] = param;
    mergeTransform(target, key, val, true);
  });
}
function mergeStyle(styleState, key, val, importance) {
  var originalVal = arguments.length > 5 ? arguments[5] : void 0, _staticConfig_context, _staticConfig_parentStaticConfig_context, _staticConfig_parentStaticConfig, {
    viewProps,
    styleProps: styleProps2,
    staticConfig,
    usedKeys
  } = styleState, existingImportance = usedKeys[key] || 0;
  if (!(existingImportance > importance)) {
    var contextProps = ((_staticConfig_context = staticConfig.context) === null || _staticConfig_context === void 0 ? void 0 : _staticConfig_context.props) || ((_staticConfig_parentStaticConfig = staticConfig.parentStaticConfig) === null || _staticConfig_parentStaticConfig === void 0 || (_staticConfig_parentStaticConfig_context = _staticConfig_parentStaticConfig.context) === null || _staticConfig_parentStaticConfig_context === void 0 ? void 0 : _staticConfig_parentStaticConfig_context.props);
    if (contextProps && key in contextProps) {
      var _styleState_originalContextPropValues, _styleState;
      (_styleState = styleState).overriddenContextProps || (_styleState.overriddenContextProps = {});
      var originalFromState = (_styleState_originalContextPropValues = styleState.originalContextPropValues) === null || _styleState_originalContextPropValues === void 0 ? void 0 : _styleState_originalContextPropValues[key], _ref;
      styleState.overriddenContextProps[key] = (_ref = originalVal != null ? originalVal : originalFromState) !== null && _ref !== void 0 ? _ref : val;
    }
    if (key in stylePropsTransform) {
      var _styleState1;
      (_styleState1 = styleState).flatTransforms || (_styleState1.flatTransforms = {}), usedKeys[key] = importance, styleState.flatTransforms[key] = val;
    } else {
      var shouldNormalize = isWeb, out = shouldNormalize ? normalizeValueWithProperty(val) : val;
      if (
        // accept is for props not styles
        staticConfig.accept && key in staticConfig.accept
      ) viewProps[key] = out;
      else {
        var _styleState2;
        (_styleState2 = styleState).style || (_styleState2.style = {}), usedKeys[key] = importance, styleState.style[key] = // if you dont do this you'll be passing props.transform arrays directly here and then mutating them
        // if theres any flatTransforms later, causing issues (mutating props is bad, in strict mode styles get borked)
        key === "transform" && Array.isArray(out) ? [...out] : out;
      }
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var _loop2 = function(key1) {
    var val = styleIn[key1];
    key1 = conf2.shorthands[key1] || key1;
    var shouldSkip = !staticConfig.isHOC && key1 in skipProps && !styleProps2.noSkip;
    if (shouldSkip) return key = key1, "continue";
    propMapper(key1, val, styleState, false, function(skey, sval, originalVal) {
      originalVal !== void 0 && (originalValues || (originalValues = {}), originalValues[skey] = originalVal), skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps2.noNormalize ? sval : normalizeValueWithProperty(sval);
    }), key = key1;
  }, {
    staticConfig,
    conf: conf2,
    styleProps: styleProps2
  } = styleState, styleOut = {}, originalValues;
  for (var key in styleIn) _loop2(key);
  if (!avoidMergeTransform) {
    if (Array.isArray(styleOut.transform)) {
      var _styleState_style, parentTransform = (_styleState_style = styleState.style) === null || _styleState_style === void 0 ? void 0 : _styleState_style.transform;
      parentTransform && (styleOut.transform = [...parentTransform, ...styleOut.transform]);
    }
    styleState.flatTransforms && mergeFlatTransforms(styleOut, styleState.flatTransforms);
  }
  return styleProps2.noNormalize || fixStyles(styleOut), originalValues && styleOriginalValues.set(styleOut, originalValues), styleOut;
}, useSplitStyles = function(a, b2, c, d, e2, f, g, h2, i, j, k, l) {
  var res = getSplitStyles(a, b2, c, d, e2, f, g, h2, i, j, k, l);
  return res;
};
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(tokenCategories.color).map(function(param) {
  var [k, v] = param;
  return [k, defaultColor];
}))), {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}), lowercaseHyphenate = function(match) {
  return `-${match.toLowerCase()}`;
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (shouldMergeObject) {
    var next = __spreadValues(__spreadValues({}, viewProps[key]), val);
    delete viewProps[key], viewProps[key] = next;
  } else viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, isSizeMedia, importanceBump, debugProp, originalVal) {
  styleState.usedKeys;
  var importance = getMediaImportanceIfMoreImportant(mediaKey, key, styleState, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), importance === null) return false;
  if (key in pseudoDescriptors) {
    var descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = styleState.componentState[descriptorKey] === false;
    if (isDisabled2) return false;
    var pseudoOriginalValues = styleOriginalValues.get(value);
    for (var subKey in value) mergeStyle(styleState, subKey, value[subKey], importance, false, pseudoOriginalValues == null ? void 0 : pseudoOriginalValues[subKey]);
  } else mergeStyle(styleState, key, value, importance, false, originalVal);
  return true;
}
function normalizeStyle(style) {
  var out = {};
  for (var key in style) {
    var val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty(val);
  }
  return fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  var defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues, 1);
}
function setElementProps(element) {
  element && !element.getBoundingClientRect && (element.getBoundingClientRect = function() {
    if (element.unstable_getBoundingClientRect != null) return element.unstable_getBoundingClientRect();
  });
}
var subscribeToContextGroup = function(props) {
  var {
    pseudoGroups,
    mediaGroups,
    groupContext
  } = props;
  if (pseudoGroups || mediaGroups) {
    var disposables = /* @__PURE__ */ new Set();
    if (pseudoGroups) for (var _i = 0, _iter = [...pseudoGroups]; _i < _iter.length; _i++) {
      var name = _iter[_i];
      disposables.add(createGroupListener(name, props));
    }
    if (mediaGroups) for (var _i1 = 0, _iter1 = [...mediaGroups]; _i1 < _iter1.length; _i1++) {
      var name1 = _iter1[_i1];
      disposables.add(createGroupListener(name1, props));
    }
    return function() {
      disposables.forEach(function(d) {
        return d();
      });
    };
  }
}, createGroupListener = function(name, param) {
  var {
    setStateShallow,
    pseudoGroups,
    mediaGroups,
    groupContext
  } = param, parent = groupContext == null ? void 0 : groupContext[name];
  if (!parent) return function() {
  };
  var dispose2 = parent.subscribe(function(param2) {
    var {
      layout,
      pseudo
    } = param2;
    setStateShallow(function(prev) {
      var _prev_group, didChange = false, group = ((_prev_group = prev.group) === null || _prev_group === void 0 ? void 0 : _prev_group[name]) || {
        pseudo: {},
        media: {}
      };
      if (pseudo && (pseudoGroups == null ? void 0 : pseudoGroups.has(name))) {
        var _group;
        (_group = group).pseudo || (_group.pseudo = {});
        var next = mergeIfNotShallowEqual(group.pseudo, pseudo);
        next !== group.pseudo && (Object.assign(group.pseudo, pseudo), didChange = true);
      } else if (layout && mediaGroups) {
        var _group1;
        (_group1 = group).media || (_group1.media = {});
        var mediaState = getMediaState(mediaGroups, layout), next1 = mergeIfNotShallowEqual(group.media, mediaState);
        next1 !== group.media && (Object.assign(group.media, next1), didChange = true);
      }
      return didChange ? {
        group: __spreadProps(__spreadValues({}, prev.group), {
          [name]: group
        })
      } : prev;
    });
  });
  return function() {
    dispose2(), setStateShallow({
      group: {}
    });
  };
};
var Theme = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  if (props.disable) return props.children;
  var {
    passThrough
  } = props, isRoot = !!props._isRoot, [_, themeState] = useThemeWithState(props, isRoot), disableDirectChildTheme = props["disable-child-theme"], finalChildren = disableDirectChildTheme ? React.Children.map(props.children, function(child) {
    return passThrough ? child : /* @__PURE__ */ React.cloneElement(child, {
      "data-disable-theme": true
    });
  }) : props.children;
  if (ref) try {
    React.Children.only(finalChildren), finalChildren = /* @__PURE__ */ React.cloneElement(finalChildren, {
      ref
    });
  } catch (e2) {
  }
  var stateRef = React.useRef({
    hasEverThemed: false
  });
  return getThemedChildren(themeState, finalChildren, props, isRoot, stateRef, passThrough);
});
Theme.avoidForwardRef = true;
function getThemedChildren(themeState, children, props) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, stateRef = arguments.length > 4 ? arguments[4] : void 0, passThrough = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, {
    shallow,
    forceClassName
  } = props, state = stateRef.current, hasEverThemed = state.hasEverThemed, shouldRenderChildrenWithTheme = hasEverThemed || themeState.isNew || isRoot || hasThemeUpdatingProps(props);
  if (!shouldRenderChildrenWithTheme) return children;
  children = /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeStateContext.Provider, {
    value: themeState.id,
    children
  });
  var {
    isInverse,
    name
  } = themeState, requiresExtraWrapper = isInverse || forceClassName;
  if (state.hasEverThemed || (state.hasEverThemed = true), (requiresExtraWrapper || // if the theme is exactly dark or light, its likely to change between dark/light
  // and that would require wrapping which would re-parent, so to avoid re-parenting do this
  themeState.name === "dark" || themeState.name === "light") && (state.hasEverThemed = "wrapped"), shallow && themeState.parentId) {
    var parentState = getThemeState(themeState.isNew ? themeState.id : themeState.parentId);
    if (!parentState) throw new Error("010");
    children = React.Children.toArray(children).map(function(child) {
      return /* @__PURE__ */ React.isValidElement(child) ? passThrough ? child : /* @__PURE__ */ React.cloneElement(child, void 0, /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
        name: parentState.name,
        children: child.props.children
      })) : child;
    });
  }
  if (forceClassName === false) return children;
  return children;
}
function themeable(Component, staticConfig) {
  var optimize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, withThemeComponent = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _a = props, {
      themeInverse,
      theme,
      componentName,
      themeReset
    } = _a, rest = __objRest(_a, [
      "themeInverse",
      "theme",
      "componentName",
      "themeReset"
    ]), overriddenContextProps, context = staticConfig == null ? void 0 : staticConfig.context;
    if (context) for (var key in context.props) {
      var val = props[key];
      val !== void 0 && (overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = val);
    }
    var element = (
      // @ts-expect-error its ok
      /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadProps(__spreadValues({
        ref
      }, rest), {
        "data-disable-theme": true
      }))
    ), filteredProps = null, compName = componentName || (staticConfig == null ? void 0 : staticConfig.componentName);
    if (compName && (filteredProps || (filteredProps = {}), filteredProps.componentName = compName), "debug" in props && (filteredProps || (filteredProps = {}), filteredProps.debug = props.debug), "theme" in props && (filteredProps || (filteredProps = {}), filteredProps.name = props.theme), "themeInverse" in props && (filteredProps || (filteredProps = {}), filteredProps.inverse = props.themeInverse), "themeReset" in props && (filteredProps || (filteredProps = {}), filteredProps.reset = themeReset), optimize && !filteredProps) return element;
    var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, __spreadProps(__spreadValues({
      "disable-child-theme": true
    }, filteredProps), {
      children: element
    }));
    if (context) {
      var Provider = context.Provider, contextValue = React.useContext(context);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues(__spreadValues({}, contextValue), overriddenContextProps), {
        children: contents
      }));
    }
    return contents;
  }), withTheme = withThemeComponent;
  return withTheme.displayName = `Themed(${(Component == null ? void 0 : Component.displayName) || (Component == null ? void 0 : Component.name) || "Anonymous"})`, withTheme;
}
function getStyleTags(styles2) {
}
var ClientOnlyContext = /* @__PURE__ */ React.createContext(false), ClientOnly = function(param) {
  var {
    children,
    enabled
  } = param, existingValue = React.useContext(ClientOnlyContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnlyContext.Provider, {
    value: enabled != null ? enabled : existingValue,
    children
  });
};
var useIsClientOnly = function() {
  return React__namespace.useContext(ClientOnlyContext);
};
function useDidFinishSSR() {
  React__namespace.useContext(ClientOnlyContext);
  return true;
}
function useClientValue(value) {
  useDidFinishSSR();
  return typeof value == "function" ? value() : value;
}
function _type_of$1(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var useComponentState = function(props, animationDriver, staticConfig, config) {
  var _animationDriver_usePresence, isHydrated = useDidFinishSSR(), needsHydration = !useIsClientOnly(), useAnimations = (animationDriver == null ? void 0 : animationDriver.isStub) ? void 0 : animationDriver == null ? void 0 : animationDriver.useAnimations, {
    isHOC
  } = staticConfig, stateRef = React.useRef(
    // performance: avoid creating object every render
    void 0
  );
  stateRef.current || (stateRef.current = {
    startedUnhydrated: needsHydration && !isHydrated
  });
  var hasAnimationProp = !!(!isHOC && "animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSS = animationDriver == null ? void 0 : animationDriver.supportsCSS, curStateRef = stateRef.current;
  !needsHydration && hasAnimationProp && (curStateRef.hasAnimated = true);
  var willBeAnimatedClient = (function() {
    var next = !!(hasAnimationProp && !isHOC && useAnimations);
    return !!(next || curStateRef.hasAnimated);
  })(), willBeAnimated = willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = true);
  var {
    disableClassName
  } = props, presence = !isHOC && willBeAnimated && props.animatePresence !== false && (animationDriver == null || (_animationDriver_usePresence = animationDriver.usePresence) === null || _animationDriver_usePresence === void 0 ? void 0 : _animationDriver_usePresence.call(animationDriver)) || null, presenceState = presence == null ? void 0 : presence[2], isExiting = (presenceState == null ? void 0 : presenceState.isPresent) === false, isEntering = (presenceState == null ? void 0 : presenceState.isPresent) === true && presenceState.initial !== false, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated, canImmediatelyEnter = hasEnterStyle || isEntering, shouldEnter = !isHOC && (hasEnterStyle || isEntering || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName), initialState = shouldEnter ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    canImmediatelyEnter ? defaultComponentStateShouldEnter : defaultComponentState
  ) : defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  var states2 = React.useState(initialState), state = props.forceStyle ? __spreadProps(__spreadValues({}, states2[0]), {
    [props.forceStyle]: true
  }) : states2[0], setState = states2[1], isAnimated = willBeAnimated;
  disabled !== state.disabled && (disabled && Object.assign(state, defaultComponentStateMounted), state.disabled = disabled, setState(function(_) {
    return __spreadValues({}, state);
  }));
  var groupName = props.group, setStateShallow = useCreateShallowSetState(setState, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    var {
      enterVariant,
      exitVariant,
      enterExitVariant,
      custom
    } = presenceState;
    isObj(custom) && Object.assign(props, custom);
    var exv = exitVariant != null ? exitVariant : enterExitVariant, env = enterVariant != null ? enterVariant : enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? props[env] = true : isExiting && exv && (props[exv] = exitVariant !== enterExitVariant);
  }
  var noClass = !isWeb;
  return {
    startedUnhydrated: curStateRef.startedUnhydrated,
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSS,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some(function(k) {
    var val = style[k];
    return val && (typeof val > "u" ? "undefined" : _type_of$1(val)) === "object" && "_animation" in val;
  });
}
var isDisabled = function(props) {
  var _props_accessibilityState;
  return props.disabled || props.passThrough || ((_props_accessibilityState = props.accessibilityState) === null || _props_accessibilityState === void 0 ? void 0 : _props_accessibilityState.disabled) || props["aria-disabled"] || props.accessibilityDisabled || false;
};
var hooks = {};
function setupHooks(next) {
  Object.assign(hooks, next);
}
var is19 = React.version.startsWith("19."), Slot = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    children
  } = _a, slotProps = __objRest(_a, [
    "children"
  ]);
  if (/* @__PURE__ */ React.isValidElement(children)) {
    var mergedProps = mergeSlotProps(children, slotProps);
    return /* @__PURE__ */ React.cloneElement(children, children.type.avoidForwardRef ? mergedProps : __spreadProps(__spreadValues({}, mergedProps), {
      ref: composeRefs(forwardedRef, is19 ? children.props.ref : children.ref)
    }));
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
})), Slottable = function(param) {
  var {
    children
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
};
Slottable.displayName = "Slottable";
var pressMap = {};
function mergeSlotProps(child, slotProps) {
  var childProps = child.props, overrideProps = __spreadValues({}, childProps), isHTMLChild = typeof child.type == "string";
  if (isHTMLChild) for (var key in pressMap) key in slotProps && (slotProps[pressMap[key]] = slotProps[key], delete slotProps[key]);
  for (var propName in childProps) {
    var slotPropValue = slotProps[propName], childPropValue = childProps[propName];
    isHTMLChild && propName in pressMap && (propName = pressMap[propName], delete overrideProps[propName]);
    var isHandler = handleRegex.test(propName);
    isHandler ? overrideProps[propName] = composeEventHandlers(childPropValue, slotPropValue) : propName === "style" ? overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue) : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, slotProps), overrideProps);
}
var handleRegex = /^on[A-Z]/;
var componentSetStates = /* @__PURE__ */ new Set(), avoidReRenderKeys = /* @__PURE__ */ new Set(["hover", "press", "pressIn", "group", "focus", "focusWithin", "media", "group"]);
var BaseText, BaseView, hasSetupBaseViews = false, lastInteractionWasKeyboard = {
  value: false
};
function createComponent(staticConfig) {
  var {
    componentName
  } = staticConfig, config = null, defaultProps2 = staticConfig.defaultProps;
  onConfiguredOnce(function(conf2) {
    if (config = conf2, componentName) {
      var _conf_defaultProps, defaultForComponent = (_conf_defaultProps = conf2.defaultProps) === null || _conf_defaultProps === void 0 ? void 0 : _conf_defaultProps[componentName];
      defaultForComponent && (defaultProps2 = __spreadValues(__spreadValues({}, defaultForComponent), defaultProps2));
    }
  });
  var {
    Component,
    isText,
    isZStack,
    isHOC
  } = staticConfig;
  var component = /* @__PURE__ */ React.forwardRef(function(propsIn, forwardedRef) {
    var _hooks_usePropsTransform, _hooks_useEvents, _config_animations;
    if (!hasSetupBaseViews) {
      var _hooks_getBaseViews;
      hasSetupBaseViews = true;
      var baseViews2 = (_hooks_getBaseViews = hooks.getBaseViews) === null || _hooks_getBaseViews === void 0 ? void 0 : _hooks_getBaseViews.call(hooks);
      baseViews2 && (BaseText = baseViews2.Text, BaseView = baseViews2.View);
    }
    var {
      context,
      isReactNative
    } = staticConfig, debugProp = propsIn.debug, styledContextValue = context ? React.useContext(context) : void 0, overriddenContextProps = null;
    var props = propsIn;
    if (styledContextValue || defaultProps2) {
      var [nextProps, overrides] = mergeComponentProps(defaultProps2, styledContextValue, propsIn);
      nextProps && (props = nextProps), overriddenContextProps = overrides;
    }
    var componentName2 = props.componentName || staticConfig.componentName;
    var componentContext = React.useContext(ComponentContext), groupContextParent = React.useContext(GroupContext), animationDriver = componentContext.animationDriver, useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, componentState = useComponentState(props, (animationDriver == null ? void 0 : animationDriver.isStub) ? null : animationDriver, staticConfig), {
      disabled,
      groupName,
      hasAnimationProp,
      hasEnterStyle,
      isAnimated,
      isExiting,
      isHydrated,
      presence,
      presenceState,
      setState,
      noClass,
      state,
      stateRef,
      supportsCSS,
      willBeAnimated,
      willBeAnimatedClient,
      startedUnhydrated
    } = componentState;
    hasAnimationProp && (animationDriver == null ? void 0 : animationDriver.avoidReRenders) && useIsomorphicLayoutEffect(function() {
      var pendingState = stateRef.current.nextState;
      pendingState && (stateRef.current.nextState = void 0, componentState.setStateShallow(pendingState));
    });
    var allGroupContexts = React.useMemo(function() {
      var _stateRef_current_group_listeners, _stateRef_current_group;
      if (!groupName || props.passThrough) return groupContextParent;
      var listeners2 = /* @__PURE__ */ new Set();
      return (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || (_stateRef_current_group_listeners = _stateRef_current_group.listeners) === null || _stateRef_current_group_listeners === void 0 || _stateRef_current_group_listeners.clear(), stateRef.current.group = {
        listeners: listeners2,
        emit(state2) {
          listeners2.forEach(function(l) {
            return l(state2);
          });
        },
        subscribe(cb) {
          return listeners2.add(cb), listeners2.size === 1 && setStateShallow({
            hasDynGroupChildren: true
          }), function() {
            listeners2.delete(cb), listeners2.size === 0 && setStateShallow({
              hasDynGroupChildren: false
            });
          };
        }
      }, __spreadProps(__spreadValues({}, groupContextParent), {
        [groupName]: {
          state: {
            pseudo: defaultComponentStateMounted
          },
          subscribe: function(listener) {
            var _stateRef_current_group2, dispose2 = (_stateRef_current_group2 = stateRef.current.group) === null || _stateRef_current_group2 === void 0 ? void 0 : _stateRef_current_group2.subscribe(listener);
            return function() {
              dispose2 == null ? void 0 : dispose2();
            };
          }
        }
      });
    }, [stateRef, groupName, groupContextParent]), setStateShallow = componentState.setStateShallow;
    var isTaggable = !Component || typeof Component == "string", tagProp = props.tag, element = Component, BaseTextComponent = BaseText || element || "span", BaseViewComponent = BaseView || element || "div", elementType = isText ? BaseTextComponent : BaseViewComponent;
    animationDriver && isAnimated && // this should really be behind another prop as it's not really related to
    // "needsWebStyles" basically with motion we just animate a plain div, but
    // we still have animated.View/Text for Sheet which wants to control
    // things declaratively
    !animationDriver.needsWebStyles && (elementType = animationDriver[isText ? "Text" : "View"] || elementType);
    var disableTheme = isHOC;
    props.themeShallow && (stateRef.current.themeShallow = true);
    var themeStateProps = {
      componentName: componentName2,
      disable: disableTheme,
      shallow: stateRef.current.themeShallow,
      debug: debugProp
    };
    if ("themeInverse" in props && (themeStateProps.inverse = props.themeInverse), "theme" in props && (themeStateProps.name = props.theme), typeof stateRef.current.isListeningToTheme == "boolean" && (themeStateProps.needsUpdate = function() {
      return !!stateRef.current.isListeningToTheme;
    }), themeStateProps.deopt = willBeAnimated, false) ;
    var [theme, themeState] = useThemeWithState(themeStateProps);
    elementType = Component || elementType;
    var mediaState = useMedia(componentContext);
    setDidGetVariableValue(false);
    var resolveValues = (
      // if HOC + mounted + has animation prop, resolve as value so it passes non-variable to child
      isAnimated && !supportsCSS || isHOC && state.unmounted == false && hasAnimationProp ? "value" : "auto"
    ), styleProps2 = {
      mediaState,
      noClass,
      resolveValues,
      isExiting,
      isAnimated,
      willBeAnimated,
      styledContext: styledContextValue
    }, themeName = (themeState == null ? void 0 : themeState.name) || "";
    var splitStyles = useSplitStyles(props, staticConfig, theme, themeName, state, styleProps2, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), isPassthrough = !splitStyles, contextForOverride = staticConfig.context;
    if (splitStyles == null ? void 0 : splitStyles.overriddenContextProps) {
      var _staticConfig_parentStaticConfig, contextForProps = staticConfig.context || ((_staticConfig_parentStaticConfig = staticConfig.parentStaticConfig) === null || _staticConfig_parentStaticConfig === void 0 ? void 0 : _staticConfig_parentStaticConfig.context);
      if (contextForProps) {
        for (var key in splitStyles.overriddenContextProps) overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = splitStyles.overriddenContextProps[key];
        staticConfig.context || (contextForOverride = contextForProps);
      }
    }
    var groupContext = groupName && (allGroupContexts == null ? void 0 : allGroupContexts[groupName]) || null;
    if (!isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal") {
      var groupState = groupContext == null ? void 0 : groupContext.state;
      if (groupState && groupState.layout === void 0) {
        var _splitStyles_style, _splitStyles_style1;
        (!((_splitStyles_style = splitStyles.style) === null || _splitStyles_style === void 0) && _splitStyles_style.width || !((_splitStyles_style1 = splitStyles.style) === null || _splitStyles_style1 === void 0) && _splitStyles_style1.height) && (groupState.layout = {
          width: fromPx(splitStyles.style.width),
          height: fromPx(splitStyles.style.height)
        });
      }
    }
    if (!isPassthrough && (hasAnimationProp || groupName) && (animationDriver == null ? void 0 : animationDriver.avoidReRenders)) {
      let updateGroupListeners2 = function() {
        var updatedState = stateRef.current.nextState;
        if (groupContext) {
          var _a2 = updatedState, {
            group,
            hasDynGroupChildren,
            unmounted,
            animation
          } = _a2, childrenGroupState = __objRest(_a2, [
            "group",
            "hasDynGroupChildren",
            "unmounted",
            "animation"
          ]);
          notifyGroupSubscribers(groupContext, stateRef.current.group || null, childrenGroupState);
        }
      };
      var _componentContext, ogSetStateShallow = setStateShallow;
      stateRef.current.updateStyleListener = function() {
        var updatedState = stateRef.current.nextState || state, mediaState2 = stateRef.current.nextMedia, nextStyles = getSplitStyles(props, staticConfig, theme, themeName, updatedState, mediaState2 ? __spreadProps(__spreadValues({}, styleProps2), {
          mediaState: mediaState2
        }) : styleProps2, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), useStyleListener = stateRef.current.useStyleListener;
        useStyleListener == null ? void 0 : useStyleListener((nextStyles == null ? void 0 : nextStyles.style) || {});
      }, (_componentContext = componentContext).mediaEmit || (_componentContext.mediaEmit = function(next) {
        var _stateRef_current_updateStyleListener, _stateRef_current;
        stateRef.current.nextMedia = next, (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
      }), stateRef.current.setStateShallow = function(nextOrGetNext) {
        var prev = stateRef.current.nextState || state, next = typeof nextOrGetNext == "function" ? nextOrGetNext(prev) : nextOrGetNext;
        if (!(next === prev || isEqualShallow(prev, next))) {
          var canAvoidReRender = Object.keys(next).every(function(key3) {
            return avoidReRenderKeys.has(key3);
          }), updatedState = __spreadValues(__spreadValues({}, prev), next);
          if (stateRef.current.nextState = updatedState, canAvoidReRender) {
            var _stateRef_current_updateStyleListener, _stateRef_current;
            updateGroupListeners2(), (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
          } else ogSetStateShallow(next);
        }
      }, setStateShallow = function(state2) {
        var _stateRef_current_setStateShallow, _stateRef_current;
        (_stateRef_current_setStateShallow = (_stateRef_current = stateRef.current).setStateShallow) === null || _stateRef_current_setStateShallow === void 0 || _stateRef_current_setStateShallow.call(_stateRef_current, state2);
      };
    }
    if (splitStyles) {
      if (props.group && props.untilMeasured === "hide" && !stateRef.current.hasMeasured) {
        var _splitStyles;
        (_splitStyles = splitStyles).style || (_splitStyles.style = {}), splitStyles.style.opacity = 0;
      }
      splitStyles.dynamicThemeAccess != null && (stateRef.current.isListeningToTheme = splitStyles.dynamicThemeAccess);
    }
    var hasRuntimeMediaKeys = (splitStyles == null ? void 0 : splitStyles.hasMedia) && splitStyles.hasMedia !== true, shouldListenForMedia = didGetVariableValue() || hasRuntimeMediaKeys || noClass && (splitStyles == null ? void 0 : splitStyles.hasMedia) === true, mediaListeningKeys = hasRuntimeMediaKeys ? splitStyles.hasMedia : null;
    setMediaShouldUpdate(componentContext, shouldListenForMedia, mediaListeningKeys);
    var {
      viewProps: viewPropsIn,
      pseudos,
      style: splitStylesStyle,
      classNames,
      space,
      pseudoGroups,
      mediaGroups
    } = splitStyles || {}, propsWithAnimation = props, _a = viewPropsIn || {}, {
      asChild,
      children,
      themeShallow,
      spaceDirection: _spaceDirection,
      onPress,
      onLongPress,
      onPressIn,
      onPressOut,
      onHoverIn,
      onHoverOut,
      onMouseUp,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      separator,
      passThrough: passThrough,
      forceStyle: _forceStyle,
      onClick: onClick,
      theme: _themeProp
    } = _a, nonTamaguiProps = __objRest(_a, [
      "asChild",
      "children",
      "themeShallow",
      "spaceDirection",
      "onPress",
      "onLongPress",
      "onPressIn",
      "onPressOut",
      "onHoverIn",
      "onHoverOut",
      "onMouseUp",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onFocus",
      "onBlur",
      "separator",
      // ignore from here on out
      "passThrough",
      "forceStyle",
      // @ts-ignore  for next/link compat etc
      "onClick",
      "theme"
    ]), viewProps = nonTamaguiProps;
    !isTaggable && props.forceStyle && (viewProps.forceStyle = props.forceStyle), isHOC && (typeof _themeProp < "u" && (viewProps.theme = _themeProp), typeof passThrough < "u" && (viewProps.passThrough = passThrough)), tagProp && elementType.acceptTagProp && (viewProps.tag = tagProp);
    var animationStyles, shouldUseAnimation = (
      // if it supports css vars we run it on server too to get matching initial style
      (supportsCSS ? willBeAnimatedClient : willBeAnimated) && useAnimations && !isHOC
    ), animatedRef;
    if (shouldUseAnimation) {
      var useStyleEmitter = (animationDriver == null ? void 0 : animationDriver.avoidReRenders) ? function(listener) {
        stateRef.current.useStyleListener = listener;
      } : void 0, animations = useAnimations({
        props: propsWithAnimation,
        // if hydrating, send empty style
        style: splitStylesStyle || {},
        // @ts-ignore
        styleState: splitStyles,
        useStyleEmitter,
        presence,
        componentState: state,
        styleProps: styleProps2,
        theme,
        pseudos: pseudos || null,
        staticConfig,
        stateRef
      });
      animations && (animations.ref && (animatedRef = animations.ref), isHydrated && animations && (animationStyles = animations.style, viewProps.style = animationStyles, animations.className && (viewProps.className = `${state.unmounted === "should-enter" ? "t_unmounted " : ""}${viewProps.className || ""} ${animations.className}`)));
    }
    !isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal" && (nonTamaguiProps.onLayout = composeEventHandlers(nonTamaguiProps.onLayout, function(e2) {
      var _stateRef_current_group, layout = e2.nativeEvent.layout;
      groupContext.state.layout = layout, (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || _stateRef_current_group.emit({
        layout
      }), !stateRef.current.hasMeasured && props.untilMeasured === "hide" && setState(function(prev) {
        return __spreadValues({}, prev);
      }), stateRef.current.hasMeasured = true;
    })), viewProps = ((_hooks_usePropsTransform = hooks.usePropsTransform) === null || _hooks_usePropsTransform === void 0 ? void 0 : _hooks_usePropsTransform.call(hooks, elementType, nonTamaguiProps, stateRef, stateRef.current.willHydrate)) || nonTamaguiProps, stateRef.current.composedRef || (stateRef.current.composedRef = composeRefs(function(x) {
      return stateRef.current.host = x;
    }, forwardedRef, setElementProps, animatedRef)), viewProps.ref = stateRef.current.composedRef;
    var unPress = function() {
      setStateShallow({
        press: false,
        pressIn: false
      });
    };
    useIsomorphicLayoutEffect(function() {
      if (state.unmounted === true && hasEnterStyle) {
        setStateShallow({
          unmounted: "should-enter"
        });
        return;
      }
      var tm;
      if (state.unmounted) {
        if ((animationDriver == null ? void 0 : animationDriver.supportsCSS) || isAndroid) return tm = setTimeout(function() {
          setStateShallow({
            unmounted: false
          });
        }), function() {
          return clearTimeout(tm);
        };
        setStateShallow({
          unmounted: false
        });
        return;
      }
      return function() {
        componentSetStates.delete(setState);
      };
    }, [state.unmounted, disabled]), useIsomorphicLayoutEffect(function() {
      if (!disabled && !(!pseudoGroups && !mediaGroups) && allGroupContexts) return subscribeToContextGroup({
        groupContext: allGroupContexts,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }, [allGroupContexts, disabled, pseudoGroups ? objectIdentityKey(pseudoGroups) : 0, mediaGroups ? objectIdentityKey(mediaGroups) : 0]);
    var groupEmitter = stateRef.current.group;
    useIsomorphicLayoutEffect(function() {
      !groupContext || !groupEmitter || notifyGroupSubscribers(groupContext, groupEmitter, state);
    }, [groupContext, groupEmitter, state]);
    var runtimePressStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.pressStyle), runtimeFocusStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusStyle), runtimeFocusVisibleStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusVisibleStyle), attachFocus = !!(runtimePressStyle || runtimeFocusStyle || runtimeFocusVisibleStyle || onFocus || onBlur || componentContext.setParentFocusState), hasDynamicGroupChildren = !!(groupName && state.hasDynGroupChildren), attachPress = !!(hasDynamicGroupChildren || runtimePressStyle || onPress || onPressOut || onPressIn || onMouseDown || onMouseUp || onLongPress || onClick || (pseudos == null ? void 0 : pseudos.focusVisibleStyle)), runtimeHoverStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.hoverStyle), needsHoverState = !!(hasDynamicGroupChildren || runtimeHoverStyle), attachHover = isWeb, shouldAttach = !disabled && !props.asChild && !!(attachFocus || attachPress || attachHover || runtimePressStyle || runtimeHoverStyle || runtimeFocusStyle), needsPressState = !!(hasDynamicGroupChildren || runtimePressStyle);
    var events = shouldAttach ? __spreadValues(__spreadValues(__spreadProps(__spreadValues({
      onPressOut: attachPress ? function(e2) {
        unPress(), onPressOut == null ? void 0 : onPressOut(e2), onMouseUp == null ? void 0 : onMouseUp(e2);
      } : void 0
    }, attachPress && {
      onMouseEnter: function(e2) {
        var next = {};
        needsHoverState && (next.hover = true), needsPressState && state.pressIn && (next.press = true), setStateShallow(next), onHoverIn == null ? void 0 : onHoverIn(e2), onMouseEnter == null ? void 0 : onMouseEnter(e2);
      },
      onMouseLeave: function(e2) {
        var next = {};
        needsHoverState && (next.hover = false), needsPressState && (next.press = false, next.pressIn = false), setStateShallow(next), onHoverOut == null ? void 0 : onHoverOut(e2), onMouseLeave == null ? void 0 : onMouseLeave(e2);
      }
    }), {
      onPressIn: attachPress ? function(e2) {
        needsPressState && setStateShallow({
          press: true,
          pressIn: true
        }), onPressIn == null ? void 0 : onPressIn(e2), onMouseDown == null ? void 0 : onMouseDown(e2);
      } : void 0,
      onPress: attachPress ? function(e2) {
        unPress(), onPress == null ? void 0 : onPress(e2);
      } : void 0
    }), attachPress && onLongPress && {
      onLongPress: function(e2) {
        unPress(), onLongPress == null ? void 0 : onLongPress(e2);
      }
    }), attachFocus && {
      onFocus: function(e2) {
        var next = {};
        componentContext.setParentFocusState && (next.focusWithin = true), (pseudos == null ? void 0 : pseudos.focusVisibleStyle) && lastInteractionWasKeyboard.value ? next.focusVisible = true : next.focus = true, setStateShallow(next), onFocus == null ? void 0 : onFocus(e2);
      },
      onBlur: function(e2) {
        componentContext.setParentFocusState && componentContext.setParentFocusState({
          focusWithin: false
        }), setStateShallow({
          focus: false,
          focusVisible: false,
          focusWithin: false
        }), onBlur == null ? void 0 : onBlur(e2);
      }
    }) : null;
    if (events && !asChild) {
      var _viewProps_focusable;
      Object.assign(events, {
        cancelable: !viewProps.rejectResponderTermination,
        disabled,
        hitSlop: viewProps.hitSlop,
        delayLongPress: viewProps.delayLongPress,
        delayPressIn: viewProps.delayPressIn,
        delayPressOut: viewProps.delayPressOut,
        focusable: (_viewProps_focusable = viewProps.focusable) !== null && _viewProps_focusable !== void 0 ? _viewProps_focusable : true,
        minPressDuration: 0
      });
    }
    (_hooks_useEvents = hooks.useEvents) === null || _hooks_useEvents === void 0 || _hooks_useEvents.call(hooks, viewProps, events, splitStyles, setStateShallow, staticConfig);
    var direction = props.spaceDirection || "both";
    var content = !children || asChild || !splitStyles ? children : spacedChildren({
      separator,
      children,
      space,
      direction,
      isZStack
    });
    if (asChild) if (elementType = Slot, 0) ;
    else Object.assign(viewProps, {
      onPress,
      onLongPress
    });
    isPassthrough && (content = propsIn.children, elementType = BaseViewComponent, viewProps = {
      style: {
        display: "contents"
      }
    });
    var useChildrenResult;
    hooks.useChildren && (useChildrenResult = hooks.useChildren(elementType, content, viewProps)), useChildrenResult ? content = useChildrenResult : content = /* @__PURE__ */ React.createElement(elementType, viewProps, content);
    var ResetPresence = config == null || (_config_animations = config.animations) === null || _config_animations === void 0 ? void 0 : _config_animations.ResetPresence, needsReset = !!// not when passing down to child
    (!asChild && // not when passThrough
    splitStyles && // not when HOC
    !isHOC && ResetPresence && willBeAnimated && (hasEnterStyle || presenceState)), hasEverReset = stateRef.current.hasEverResetPresence;
    needsReset && !hasEverReset && (stateRef.current.hasEverResetPresence = true);
    var renderReset = needsReset || hasEverReset;
    if (renderReset && ResetPresence && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence, {
      disabled: !needsReset,
      children: content
    })), "focusWithinStyle" in propsIn && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, componentContext), {
      setParentFocusState: setStateShallow,
      children: content
    }))), "group" in props && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(GroupContext.Provider, {
      value: allGroupContexts,
      children: content
    })), content = disableTheme || !splitStyles ? content : getThemedChildren(themeState, content, themeStateProps, false, stateRef), overriddenContextProps && contextForOverride) {
      var Provider = contextForOverride.Provider;
      for (var key1 in styledContextValue) key1 in overriddenContextProps || (overriddenContextProps[key1] = styledContextValue[key1]);
      debugProp && console.info("overriddenContextProps", overriddenContextProps), content = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues({
        __disableMergeDefaultValues: true
      }, overriddenContextProps), {
        children: content
      }));
    }
    return content;
  });
  function notifyGroupSubscribers(groupContext, groupEmitter, pseudo) {
    if (!(!groupContext || !groupEmitter)) {
      var nextState = __spreadProps(__spreadValues({}, groupContext.state), {
        pseudo
      });
      groupEmitter.emit(nextState), groupContext.state = nextState;
    }
  }
  staticConfig.componentName && (component.displayName = staticConfig.componentName);
  var res = component;
  (process.env.TAMAGUI_FORCE_MEMO || staticConfig.memo) && (res = /* @__PURE__ */ React.memo(res)), res.staticConfig = staticConfig;
  function extendStyledConfig(extended) {
    return __spreadProps(__spreadValues(__spreadValues({}, staticConfig), extended), {
      neverFlatten: true,
      isHOC: true,
      isStyledHOC: false
    });
  }
  function extractable(Component2, extended) {
    return Component2.staticConfig = extendStyledConfig(extended), Component2.styleable = styleable, Component2;
  }
  function styleable(Component2, options) {
    var _Component_render, skipForwardRef = IS_REACT_19 && typeof Component2 == "function" && Component2.length === 1 || ((_Component_render = Component2.render) === null || _Component_render === void 0 ? void 0 : _Component_render.length) === 2, out = skipForwardRef ? Component2 : /* @__PURE__ */ React.forwardRef(Component2), extendedConfig = extendStyledConfig(options == null ? void 0 : options.staticConfig);
    return out = (options == null ? void 0 : options.disableTheme) ? out : themeable(out, extendedConfig, true), (extendedConfig.memo || process.env.TAMAGUI_MEMOIZE_STYLEABLE) && (out = /* @__PURE__ */ React.memo(out)), out.staticConfig = extendedConfig, out.styleable = styleable, out;
  }
  return res.extractable = extractable, res.styleable = styleable, res;
}
function Unspaced(props) {
  return props.children;
}
Unspaced.isUnspaced = true;
var getSpacerSize = function(size, param) {
  var {
    tokens
  } = param;
  size = size === false ? 0 : size === true ? "$true" : size;
  var _tokens_space_size, sizePx = (_tokens_space_size = tokens.space[size]) !== null && _tokens_space_size !== void 0 ? _tokens_space_size : size;
  return {
    width: sizePx,
    height: sizePx,
    minWidth: sizePx,
    minHeight: sizePx
  };
}, Spacer = createComponent({
  acceptsClassName: true,
  memo: true,
  componentName: "Spacer",
  validStyles,
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    // avoid nesting issues
    tag: "span",
    size: true,
    pointerEvents: "none"
  }),
  variants: {
    size: {
      "...": getSpacerSize
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  var _childrenList__type, _childrenList_, {
    isZStack,
    children,
    space,
    direction,
    spaceFlex,
    separator,
    ensureKeys
  } = props, hasSpace = !!(space || spaceFlex), hasSeparator = separator != null, areChildrenArray = Array.isArray(children);
  if (!ensureKeys && !(hasSpace || hasSeparator || isZStack)) return children;
  var childrenList = areChildrenArray ? children : React.Children.toArray(children), len = childrenList.length;
  if (len <= 1 && !isZStack && !(!((_childrenList_ = childrenList[0]) === null || _childrenList_ === void 0 || (_childrenList__type = _childrenList_.type) === null || _childrenList__type === void 0) && _childrenList__type.shouldForwardSpace)) return children;
  var final = [], _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = childrenList.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var [index2, child] = _step.value, _child_type, isEmpty = child == null || Array.isArray(child) && child.length === 0;
      if (!isEmpty && /* @__PURE__ */ React.isValidElement(child) && !((_child_type = child.type) === null || _child_type === void 0) && _child_type.shouldForwardSpace && (child = /* @__PURE__ */ React.cloneElement(child, {
        // @ts-expect-error we explicitly know with shouldForwardSpace
        space,
        spaceFlex,
        separator,
        key: child.key
      })), isEmpty || !child || child.key && !isZStack ? final.push(child) : final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
        children: isZStack ? /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteFill, {
          children: child
        }) : child
      }, `${index2}0t`)), !(isUnspaced(child) && index2 === 0) && !isZStack) {
        var next = childrenList[index2 + 1];
        next && !isEmpty && !isUnspaced(next) && (separator ? (hasSpace && final.push(createSpacer({
          key: `_${index2}_00t`,
          direction,
          space,
          spaceFlex
        })), final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
          children: separator
        }, `${index2}03t`)), hasSpace && final.push(createSpacer({
          key: `_${index2}01t`,
          direction,
          space,
          spaceFlex
        }))) : final.push(createSpacer({
          key: `_${index2}02t`,
          direction,
          space,
          spaceFlex
        })));
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return final;
}
function createSpacer(param) {
  var {
    key,
    direction,
    space,
    spaceFlex
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, __spreadValues({
    size: space,
    direction
  }, typeof spaceFlex < "u" && {
    flex: spaceFlex === true ? 1 : spaceFlex === false ? 0 : spaceFlex
  }), key);
}
function isUnspaced(child) {
  var t2 = child == null ? void 0 : child.type;
  return (t2 == null ? void 0 : t2.isVisuallyHidden) || (t2 == null ? void 0 : t2.isUnspaced);
}
var AbsoluteFill = createComponent({
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  })
}), fromPx = function(val) {
  return typeof val == "number" ? val : typeof val == "string" ? +val.replace("px", "") : 0;
};
function getExpandedShorthands(props) {
  var shorthands = getConfig().shorthands;
  if (!shorthands) return props;
  var res = {};
  for (var key in props) res[shorthands[key] || key] = props[key];
  return res;
}
function getExpandedShorthand(propKey, props) {
  var shorthands = getConfig().inverseShorthands, _props_propKey;
  return (_props_propKey = props[propKey]) !== null && _props_propKey !== void 0 ? _props_propKey : props[shorthands[propKey]];
}
var inverseShorthands = null, getShorthandValue = function(props, key) {
  inverseShorthands || (inverseShorthands = getConfig().inverseShorthands);
  var _props_key;
  return (_props_key = props[key]) !== null && _props_key !== void 0 ? _props_key : inverseShorthands ? props[inverseShorthands[key]] : void 0;
};
function getThemeCSSRules() {
  return [];
}
function isTamaguiComponent(comp, name) {
  var config = comp == null ? void 0 : comp.staticConfig;
  return !!(config && (!name || name === config.componentName));
}
var isTamaguiElement = function(child, name) {
  return /* @__PURE__ */ React.isValidElement(child) && isTamaguiComponent(child.type, name);
};
var themesRaw = {};
function proxyThemesToParents(dedupedThemes) {
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = dedupedThemes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var {
        names,
        theme
      } = _step.value, _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
      try {
        for (var _iterator1 = names[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var name = _step1.value;
          themesRaw[name] = theme;
        }
      } catch (err) {
        _didIteratorError1 = true, _iteratorError1 = err;
      } finally {
        try {
          !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError1) throw _iteratorError1;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  var themes2 = {}, _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
  try {
    for (var _iterator2 = dedupedThemes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var {
        names: names1,
        theme: theme1
      } = _step2.value, _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = void 0;
      try {
        for (var _iterator3 = names1[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var themeName = _step3.value, proxiedTheme = proxyThemeToParents(themeName, theme1);
          themes2[themeName] = proxiedTheme;
        }
      } catch (err) {
        _didIteratorError3 = true, _iteratorError3 = err;
      } finally {
        try {
          !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
        } finally {
          if (_didIteratorError3) throw _iteratorError3;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
    } finally {
      if (_didIteratorError2) throw _iteratorError2;
    }
  }
  return themes2;
}
function proxyThemeToParents(themeName, theme) {
  var out = {}, cur = [], parents = themeName.split("_").slice(0, -1).map(function(part) {
    return cur.push(part), cur.join("_");
  }), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = parents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var parent = _step.value;
      Object.assign(out, themesRaw[parent]);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return Object.assign(out, theme), out;
}
function proxyThemeVariables(obj) {
  return new Proxy(obj || {}, {
    has(target, key) {
      return Reflect.has(target, removeStarting$(key));
    },
    get(target, key) {
      return Reflect.get(target, removeStarting$(key));
    }
  });
}
var removeStarting$ = function(str) {
  return typeof str == "string" && str[0] === "$" ? str.slice(1) : str;
};
function ensureThemeVariable(theme, key) {
  var val = theme[key];
  isVariable(val) ? val.name !== key && (theme[key] = createVariable({
    key: val.name,
    name: key,
    val: val.val
  })) : theme[key] = createVariable({
    key,
    name: key,
    val
  });
}
var fontWeights = ["100", "200", "300", "400", "500", "600", "700", "800", "900"], processSection = function(section, keys, defaultValue2) {
  if (typeof section == "string") return section;
  var sectionKeys = Object.keys(section), fillValue = section[sectionKeys[0]];
  return Object.fromEntries([.../* @__PURE__ */ new Set([...keys, ...sectionKeys])].map(function(key) {
    var _section_key, _ref, value = (_ref = (_section_key = section[key]) !== null && _section_key !== void 0 ? _section_key : defaultValue2) !== null && _ref !== void 0 ? _ref : fillValue;
    return fillValue = value, defaultValue2 = value, [key, value];
  }));
}, createFont = function(font) {
  var sizeKeys = Object.keys(font.size || {}), processedFont = Object.fromEntries(Object.entries(font).map(function(param) {
    var [key, section] = param;
    return [key, processSection(section, key === "face" ? fontWeights : sizeKeys, key === "face" ? {
      normal: font.family
    } : void 0)];
  }));
  return Object.freeze(processedFont);
};
function createShorthands(shorthands) {
  return Object.freeze(shorthands);
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var cache = /* @__PURE__ */ new WeakMap(), createVariables = function(tokens) {
  var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (cache.has(tokens)) return tokens;
  var res = {};
  for (var keyIn in tokens) {
    var val = tokens[keyIn], isPrefixed = keyIn[0] === "$", keyWithPrefix = isPrefixed ? keyIn : `$${keyIn}`, key = isPrefixed ? keyWithPrefix.slice(1) : keyIn;
    if (isVariable(val)) {
      res[key] = val;
      continue;
    }
    var niceKey = simpleHash(key, 1e3), name = parentPath && parentPath !== "t-color" ? `${parentPath}-${niceKey}` : `c-${niceKey}`;
    if (val && (typeof val > "u" ? "undefined" : _type_of(val)) === "object" && "needsPx" in val && "val" in val) {
      var finalValue = createVariable({
        val: val.val,
        name,
        key: keyWithPrefix
      });
      res[key] = finalValue;
      continue;
    }
    if (val && (typeof val > "u" ? "undefined" : _type_of(val)) === "object") {
      res[key] = createVariables(tokens[key], name, false);
      continue;
    }
    var finalValue1 = isVariable(val) ? val : createVariable({
      val,
      name,
      key: keyWithPrefix
    });
    res[key] = finalValue1;
  }
  return cache.set(res, true), res;
};
var noAnimationDriver = function(method) {
  console.warn(`No animation driver configured. To use ${method}, you must pass \`animations\` to createTamagui. See: https://tamagui.dev/docs/core/animations`);
}, createEmptyAnimationDriver = function() {
  return {
    isReactNative: false,
    supportsCSS: true,
    classNameAnimation: true,
    isStub: true,
    animations: {},
    useAnimations: function() {
      return noAnimationDriver("animations");
    },
    usePresence: function() {
      return noAnimationDriver("usePresence");
    },
    ResetPresence: function() {
      return noAnimationDriver("ResetPresence");
    },
    useAnimatedNumber: function() {
      return noAnimationDriver("useAnimatedNumber");
    },
    useAnimatedNumberStyle: function() {
      return noAnimationDriver("useAnimatedNumberStyle");
    },
    useAnimatedNumberReaction: function() {
      return noAnimationDriver("useAnimatedNumberReaction");
    }
  };
}, defaultAnimationDriver = createEmptyAnimationDriver();
var registerCSSVariable = function(v) {
  tokensValueToVariable.set(getVariableValue(v), v);
}, variableToCSS = function(v) {
  var unitless = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return `--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${createCSSVariable(v.name, false)}:${!unitless && typeof v.val == "number" ? `${v.val}px` : v.val}`;
}, tokensValueToVariable = /* @__PURE__ */ new Map();
function insertFont(name, fontIn) {
  var font = createFont(fontIn), tokened = createVariables(font, name), parsed = parseFont(tokened);
  return setConfigFont(name, tokened, parsed), parsed;
}
var updateFont = insertFont;
function parseFont(definition) {
  var parsed = {};
  for (var attrKey in definition) {
    var attr = definition[attrKey];
    if (attrKey === "family" || attrKey === "face") parsed[attrKey] = attr;
    else {
      parsed[attrKey] = {};
      for (var key in attr) {
        var _val_val, val = attr[key];
        ((_val_val = val.val) === null || _val_val === void 0 ? void 0 : _val_val[0]) === "$" && (val = val.val), parsed[attrKey][`$${key}`] = val;
      }
    }
  }
  return parsed;
}
function registerFontVariables(parsedFont) {
  var response = [];
  for (var fkey in parsedFont) if (fkey !== "face") if (fkey === "family") {
    var val = parsedFont[fkey];
    registerCSSVariable(val), response.push(variableToCSS(val));
  } else for (var fskey in parsedFont[fkey]) {
    var fval = parsedFont[fkey][fskey];
    if (typeof fval != "string") {
      var val1 = parsedFont[fkey][fskey];
      registerCSSVariable(val1), response.push(variableToCSS(val1));
    }
  }
  return response;
}
var Tamagui = /* @__PURE__ */ (function() {
})(), identifierToValue = /* @__PURE__ */ new Map(), getValueFromIdentifier = function(identifier) {
  return identifierToValue.get(identifier);
}, setIdentifierValue = function(identifier, value) {
  identifierToValue.set(identifier, value);
};
function shouldTokenCategoryHaveUnits(category) {
  var UNIT_CATEGORIES = /* @__PURE__ */ new Set(["size", "space", "radius"]);
  return UNIT_CATEGORIES.has(category);
}
function createTamagui$1(configIn) {
  var _configIn_settings, existingConfig = getConfigMaybe();
  existingConfig && (configIn = __spreadValues(__spreadValues({}, existingConfig), configIn));
  var tokensParsed = {}, tokens = createVariables(configIn.tokens || {});
  if (configIn.tokens) {
    var tokensMerged2 = {};
    for (var cat in tokens) {
      tokensParsed[cat] = {}, tokensMerged2[cat] = {};
      var tokenCat = tokens[cat];
      for (var key in tokenCat) {
        var val = tokenCat[key], prefixedKey = `$${key}`;
        tokensParsed[cat][prefixedKey] = val, tokensMerged2[cat][prefixedKey] = val, tokensMerged2[cat][key] = val;
      }
    }
    setTokens(tokensMerged2);
  }
  var foundThemes;
  if (configIn.themes) {
    var noThemes = Object.keys(configIn.themes).length === 0;
    noThemes && (foundThemes = scanAllSheets());
  }
  var fontSizeTokens = null, fontsParsed;
  if (configIn.fonts) {
    var fontTokens = Object.fromEntries(Object.entries(configIn.fonts).map(function(param) {
      var [k, v] = param;
      return [k, createVariables(v, "f", true)];
    }));
    fontsParsed = (function() {
      var res = {};
      for (var familyName in fontTokens) {
        var font = fontTokens[familyName], fontParsed = parseFont(font);
        res[`$${familyName}`] = fontParsed, !fontSizeTokens && fontParsed.size && (fontSizeTokens = new Set(Object.keys(fontParsed.size)));
      }
      return res;
    })();
  }
  var specificTokens = {}, themeConfig = (function() {
    var cssRuleSets = [], declarations = [], sortedTokenKeys = Object.keys(tokens).sort(), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = sortedTokenKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key2 = _step.value, sortedSubKeys = Object.keys(tokens[key2]).sort(), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
        try {
          for (var _iterator1 = sortedSubKeys[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var skey = _step1.value, variable = tokens[key2][skey];
            if (specificTokens[`$${key2}.${skey}`] = variable, false) ;
            var variableNeedsPx, categoryNeedsPx, shouldBeUnitless;
            if (isWeb) ;
          }
        } catch (err) {
          _didIteratorError1 = true, _iteratorError1 = err;
        } finally {
          try {
            !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError1) throw _iteratorError1;
          }
        }
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    var themesIn = configIn.themes, dedupedThemes = foundThemes != null ? foundThemes : getThemesDeduped(themesIn, tokens.color), themes2 = proxyThemesToParents(dedupedThemes);
    return {
      themes: themes2,
      cssRuleSets,
      getThemeRulesSets() {
        var themeRuleSets = [];
        return themeRuleSets;
      }
    };
  })(), userShorthands = configIn.shorthands || {}, shorthands = __spreadValues(__spreadValues({}, builtinShorthands), userShorthands), getCSS = function() {
    return "";
  }, getNewCSS = function(opts2) {
    return getCSS(__spreadValues({}, opts2));
  }, _configIn_settings_defaultFont, defaultFontSetting = (_configIn_settings_defaultFont = (_configIn_settings = configIn.settings) === null || _configIn_settings === void 0 ? void 0 : _configIn_settings.defaultFont) !== null && _configIn_settings_defaultFont !== void 0 ? _configIn_settings_defaultFont : configIn.defaultFont, defaultFont = (function() {
    var val2 = defaultFontSetting;
    return (val2 == null ? void 0 : val2[0]) === "$" && (val2 = val2.slice(1)), val2;
  })(), defaultFontToken = defaultFont ? `$${defaultFont}` : "", unset = __spreadValues({}, configIn.unset);
  !unset.fontFamily && defaultFont && (unset.fontFamily = defaultFontToken);
  var config = __spreadProps(__spreadValues({
    fonts: {},
    onlyAllowShorthands: false,
    fontLanguages: [],
    animations: defaultAnimationDriver,
    media: {}
  }, configIn), {
    unset,
    settings: __spreadValues({
      // move deprecated settings here so we can reference them all using `getSetting`
      // TODO remove this on v2
      disableSSR: configIn.disableSSR,
      defaultFont: configIn.defaultFont,
      disableRootThemeClass: configIn.disableRootThemeClass,
      onlyAllowShorthands: configIn.onlyAllowShorthands,
      mediaQueryDefaultActive: configIn.mediaQueryDefaultActive,
      themeClassNameOnRoot: configIn.themeClassNameOnRoot,
      cssStyleSeparator: configIn.cssStyleSeparator,
      webContainerType: "inline-size"
    }, configIn.settings),
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    userShorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(function(param) {
      var [k, v] = param;
      return [v, k];
    })) : {},
    themes: themeConfig.themes,
    fontsParsed: fontsParsed || {},
    themeConfig,
    tokensParsed,
    parsed: true,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens,
    defaultFontToken
  });
  if (setConfig(config), configureMedia(config), configListeners.size && (configListeners.forEach(function(cb) {
    return cb(config);
  }), configListeners.clear()), false) ;
  return config;
}
function getThemesDeduped(themes2, colorTokens) {
  var dedupedThemes = [], existing = /* @__PURE__ */ new Map(), sortedThemeNames = Object.keys(themes2).sort(), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = sortedThemeNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var themeName = _step.value, darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "", rawTheme = themes2[themeName], key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
      if (existing.has(key)) {
        var e2 = existing.get(key);
        e2.names.push(themeName);
        continue;
      }
      var theme = __spreadValues(__spreadValues({}, colorTokens), rawTheme);
      for (var key1 in theme) ensureThemeVariable(theme, key1);
      var deduped = {
        names: [themeName],
        theme
      };
      dedupedThemes.push(deduped), existing.set(key, deduped);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return dedupedThemes;
}
var builtinShorthands = {
  fd: "flexDirection",
  fb: "flexBasis",
  bblr: "borderBottomLeftRadius",
  bbrr: "borderBottomRightRadius",
  fwr: "flexWrap",
  col: "color",
  ff: "fontFamily",
  fst: "fontStyle",
  tr: "transform",
  tt: "textTransform",
  td: "textDecorationLine",
  va: "verticalAlign",
  ws: "whiteSpace",
  wb: "wordBreak",
  ww: "wordWrap",
  brc: "borderRightColor",
  brw: "borderRightWidth",
  bs: "borderStyle",
  btc: "borderTopColor",
  btlr: "borderTopLeftRadius",
  btrr: "borderTopRightRadius",
  btw: "borderTopWidth",
  bw: "borderWidth",
  o: "opacity",
  cur: "cursor",
  pe: "pointerEvents",
  ov: "overflow",
  pos: "position",
  dsp: "display",
  fw: "fontWeight",
  fs: "fontSize",
  ls: "letterSpacing",
  lh: "lineHeight",
  bxs: "boxSizing",
  bxsh: "boxShadow",
  ox: "overflowX",
  oy: "overflowY"
};
var createTheme = function(theme) {
  return theme;
};
function createTokens(tokens) {
  var _process_env_TAMAGUI_TOKEN_PREFIX;
  return createVariables(tokens, (_process_env_TAMAGUI_TOKEN_PREFIX = process.env.TAMAGUI_TOKEN_PREFIX) !== null && _process_env_TAMAGUI_TOKEN_PREFIX !== void 0 ? _process_env_TAMAGUI_TOKEN_PREFIX : "t");
}
function getReactNativeConfig(Component) {
  if (Component) {
    var _Component_propTypes, _Component_propTypes1, _Component_propTypes2;
    return !((_Component_propTypes = Component.propTypes) === null || _Component_propTypes === void 0) && _Component_propTypes.onTextInput || !((_Component_propTypes1 = Component.propTypes) === null || _Component_propTypes1 === void 0) && _Component_propTypes1.onChangeText ? RNConfigs.TextInput : Component.getSizeWithHeaders ? RNConfigs.Image : !((_Component_propTypes2 = Component.propTypes) === null || _Component_propTypes2 === void 0) && _Component_propTypes2.textBreakStrategy ? RNConfigs.Text : RNConfigs.default;
  }
}
var RNConfigs = {
  Image: {
    isReactNative: true,
    inlineProps: /* @__PURE__ */ new Set(["src", "width", "height"])
  },
  Text: {
    isReactNative: true,
    isText: true
  },
  TextInput: {
    isReactNative: true,
    isInput: true,
    isText: true
  },
  default: {
    isReactNative: true
  }
};
function setupReactNative(rnExports) {
}
var mergeVariants = function(parentVariants, ourVariants) {
  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, variants = {};
  for (var key in ourVariants) {
    var parentVariant = parentVariants == null ? void 0 : parentVariants[key], ourVariant = ourVariants[key];
    !parentVariant || typeof ourVariant == "function" ? variants[key] = ourVariant : parentVariant && !ourVariant ? variants[key] = parentVariant[key] : level === 0 ? variants[key] = mergeVariants(parentVariant, ourVariant, level + 1) : variants[key] = __spreadValues(__spreadValues({}, parentVariant), ourVariant);
  }
  return __spreadValues(__spreadValues({}, parentVariants), variants);
};
function styled(ComponentIn, options, config) {
  var parentStaticConfig = ComponentIn.staticConfig, isPlainStyledComponent = !!parentStaticConfig && !(parentStaticConfig.isReactNative || parentStaticConfig.isHOC), isNonStyledHOC = (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && !(parentStaticConfig == null ? void 0 : parentStaticConfig.isStyledHOC), Component = isNonStyledHOC || isPlainStyledComponent ? ComponentIn : (parentStaticConfig == null ? void 0 : parentStaticConfig.Component) || ComponentIn, reactNativeConfig = parentStaticConfig ? void 0 : getReactNativeConfig(Component), isReactNative = !!(reactNativeConfig || (config == null ? void 0 : config.isReactNative) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isReactNative)), staticConfigProps = (function() {
    var _a = options || {}, {
      variants,
      name,
      defaultVariants,
      acceptsClassName: acceptsClassNameProp,
      context
    } = _a, defaultProps2 = __objRest(_a, [
      "variants",
      "name",
      "defaultVariants",
      "acceptsClassName",
      "context"
    ]), parentDefaultVariants, parentDefaultProps;
    if (parentStaticConfig) {
      var avoid = parentStaticConfig.isHOC && !parentStaticConfig.isStyledHOC;
      if (!avoid) {
        var pdp = parentStaticConfig.defaultProps;
        for (var key2 in pdp) {
          var val = pdp[key2];
          parentStaticConfig.defaultVariants && key2 in parentStaticConfig.defaultVariants && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultVariants || (parentDefaultVariants = {}), parentDefaultVariants[key2] = val), !(key2 in defaultProps2) && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultProps || (parentDefaultProps = {}), parentDefaultProps[key2] = pdp[key2]);
        }
        parentStaticConfig.variants && (variants = mergeVariants(parentStaticConfig.variants, variants));
      }
    }
    (parentDefaultProps || defaultVariants || parentDefaultVariants) && (defaultProps2 = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, parentDefaultProps), parentDefaultVariants), defaultProps2), defaultVariants)), (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && name && (defaultProps2.componentName = name);
    var isText = !!((config == null ? void 0 : config.isText) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isText)), _config_acceptsClassName, _ref, acceptsClassName = (_ref = (_config_acceptsClassName = config == null ? void 0 : config.acceptsClassName) !== null && _config_acceptsClassName !== void 0 ? _config_acceptsClassName : acceptsClassNameProp) !== null && _ref !== void 0 ? _ref : isPlainStyledComponent || isReactNative || (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && (parentStaticConfig == null ? void 0 : parentStaticConfig.acceptsClassName), conf2 = __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, parentStaticConfig), config), !isPlainStyledComponent && {
      Component
    }), {
      // @ts-expect-error
      variants,
      defaultProps: defaultProps2,
      defaultVariants,
      componentName: name || (parentStaticConfig == null ? void 0 : parentStaticConfig.componentName),
      isReactNative,
      isText,
      acceptsClassName,
      context
    }), reactNativeConfig), {
      isStyledHOC: !!(parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC),
      parentStaticConfig
    });
    return (defaultProps2.children || !acceptsClassName || context) && (conf2.neverFlatten = true), conf2;
  })(), component = createComponent(staticConfigProps || {});
  for (var key in ComponentIn) key !== "propTypes" && (key in component || (component[key] = ComponentIn[key]));
  return component;
}
var useIsTouchDevice = function() {
  return true;
};
var Stack$1 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
Stack$1.displayName = "Stack";
function useProps(props, opts2) {
  var [propsOut, styleOut] = usePropsAndStyle(props, __spreadProps(__spreadValues({}, opts2), {
    noExpand: true,
    noNormalize: true,
    resolveValues: "none"
  }));
  return __spreadValues(__spreadValues({}, propsOut), styleOut);
}
function useStyle(props, opts2) {
  return usePropsAndStyle(props, opts2)[1] || {};
}
function usePropsAndStyle(props, opts2) {
  var _opts_forComponent, _opts_forComponent_staticConfig, staticConfig = (_opts_forComponent_staticConfig = opts2 == null || (_opts_forComponent = opts2.forComponent) === null || _opts_forComponent === void 0 ? void 0 : _opts_forComponent.staticConfig) !== null && _opts_forComponent_staticConfig !== void 0 ? _opts_forComponent_staticConfig : Stack$1.staticConfig, [theme, themeState] = useThemeWithState({
    componentName: staticConfig.componentName,
    name: "theme" in props ? props.theme : void 0,
    inverse: "themeInverse" in props ? props.themeInverse : void 0,
    needsUpdate() {
      return true;
    }
  }), componentContext = React.useContext(ComponentContext), groupContext = React.useContext(GroupContext), {
    state,
    disabled,
    setStateShallow
  } = useComponentState(props, componentContext.animationDriver, staticConfig, getConfig()), mediaStateNow = (opts2 == null ? void 0 : opts2.noMedia) ? (
    // not safe to use mediaState but really marginal to hit this
    exports.mediaState
  ) : useMedia(), splitStyles = useSplitStyles(props, staticConfig, theme, (themeState == null ? void 0 : themeState.name) || "", state, __spreadValues({
    isAnimated: false,
    mediaState: mediaStateNow,
    noSkip: true,
    noMergeStyle: true,
    noClass: true,
    resolveValues: "auto"
  }, opts2), null, componentContext, groupContext), {
    mediaGroups,
    pseudoGroups
  } = splitStyles || {};
  return useIsomorphicLayoutEffect(function() {
    if (!disabled) {
      if (state.unmounted) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      if (groupContext) return subscribeToContextGroup({
        groupContext,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }
  }, [disabled, groupContext, pseudoGroups ? Object.keys([...pseudoGroups]).join("") : 0, mediaGroups ? Object.keys([...mediaGroups]).join("") : 0]), [(splitStyles == null ? void 0 : splitStyles.viewProps) || {}, (splitStyles == null ? void 0 : splitStyles.style) || {}, theme, exports.mediaState];
}
var forceUpdateState = {
  forceClassName: true,
  deopt: true,
  needsUpdate: function() {
    return true;
  }
}, forceKeys = {
  current: /* @__PURE__ */ new Set([""])
};
function useThemeName() {
  var _useThemeState;
  return ((_useThemeState = useThemeState(forceUpdateState, false, forceKeys)) === null || _useThemeState === void 0 ? void 0 : _useThemeState.name) || "";
}
var Configuration = function(props) {
  var current = React.useContext(ComponentContext), _props_disableSSR;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: (_props_disableSSR = props.disableSSR) !== null && _props_disableSSR !== void 0 ? _props_disableSSR : current.disableSSR,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadValues(__spreadValues({}, current), props))
  });
};
function FontLanguage(param) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]), parentProps = React.useContext(ComponentContext), language = React.useMemo(function() {
    return props;
  }, [JSON.stringify(props)]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, parentProps), {
    language,
    children
  }));
}
var ThemeProvider = function(props) {
  var _props_disableRootThemeClass, disableRootThemeClass = (_props_disableRootThemeClass = props.disableRootThemeClass) !== null && _props_disableRootThemeClass !== void 0 ? _props_disableRootThemeClass : getSetting("disableRootThemeClass"), _props_themeClassNameOnRoot, themeClassNameOnRoot = (_props_themeClassNameOnRoot = props.themeClassNameOnRoot) !== null && _props_themeClassNameOnRoot !== void 0 ? _props_themeClassNameOnRoot : getSetting("themeClassNameOnRoot");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
    className: props.className,
    name: props.defaultTheme,
    // if root class disabled, force class here
    forceClassName: !disableRootThemeClass && !themeClassNameOnRoot,
    // @ts-expect-error
    _isRoot: React.useId,
    children: props.children
  });
};
function TamaguiProvider$1(param) {
  var {
    children,
    disableInjectCSS,
    config,
    className,
    defaultTheme,
    disableRootThemeClass,
    reset,
    themeClassNameOnRoot
  } = param;
  useIsomorphicLayoutEffect(function() {
    updateMediaListeners();
  }, []);
  var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(UnmountedClassName, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, {
      animationDriver: config == null ? void 0 : config.animations,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, {
        themeClassNameOnRoot: themeClassNameOnRoot != null ? themeClassNameOnRoot : getSetting("themeClassNameOnRoot"),
        disableRootThemeClass: disableRootThemeClass != null ? disableRootThemeClass : getSetting("disableRootThemeClass"),
        defaultTheme: defaultTheme != null ? defaultTheme : config ? Object.keys(config.themes)[0] : "",
        reset,
        className,
        children
      })
    })
  });
  return getSetting("disableSSR") && (contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: true,
    children: contents
  })), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [contents, false]
  });
}
function UnmountedClassName(props) {
  var [mounted, setMounted] = React.useState(false);
  return React.useEffect(function() {
    setMounted(true);
  }, []), props.children;
}
TamaguiProvider$1.displayName = "TamaguiProvider";
var ellipsisStyle = {
  numberOfLines: 1,
  lineBreakMode: "clip"
}, Text$1 = createComponent({
  acceptsClassName: true,
  isText: true,
  defaultProps: {
    fontFamily: "unset",
    suppressHighlighting: true
  },
  inlineWhenUnflattened: /* @__PURE__ */ new Set(["fontFamily"]),
  variants: {
    /**
    * @deprecated Use ellipsis instead
    */
    ellipse: {
      true: ellipsisStyle
    },
    ellipsis: {
      true: ellipsisStyle
    }
  },
  validStyles: __spreadValues(__spreadValues({}, validStyles), stylePropsTextOnly)
});
Text$1.displayName = "Text";
var View$1 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
function useGet(currentValue, initialValue, forwardToFunction) {
  var curRef = React__namespace.useRef(initialValue != null ? initialValue : currentValue);
  return useIsomorphicLayoutEffect(function() {
    curRef.current = currentValue;
  }), React__namespace.useCallback(forwardToFunction ? function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
    var _curRef_current;
    return (_curRef_current = curRef.current) === null || _curRef_current === void 0 ? void 0 : _curRef_current.apply(null, args);
  } : function() {
    return curRef.current;
  }, []);
}
function useEvent(callback) {
  return useGet(callback, defaultValue, true);
}
var defaultValue = function() {
  throw new Error("Cannot call an event handler while rendering.");
};
var RE_MEDIA_QUERY = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;
function matchQuery(mediaQuery, values) {
  return parseQuery(mediaQuery).some(function(query2) {
    if (query2) {
      var inverse = query2.inverse, typeMatch = query2.type === "all" || values.type === query2.type;
      if (typeMatch && inverse || !(typeMatch || inverse)) return false;
      var expressionsMatch = query2.expressions.every(function(expression) {
        var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];
        if (!value) return false;
        switch (feature) {
          case "orientation":
          case "scan":
            return value.toLowerCase() === expValue.toLowerCase();
          case "width":
          case "height":
          case "device-width":
          case "device-height":
            expValue = toPx(expValue), value = toPx(value);
            break;
          case "resolution":
            expValue = toDpi(expValue), value = toDpi(value);
            break;
          case "aspect-ratio":
          case "device-aspect-ratio":
          case /* Deprecated */
          "device-pixel-ratio":
            expValue = toDecimal(expValue), value = toDecimal(value);
            break;
          case "grid":
          case "color":
          case "color-index":
          case "monochrome":
            expValue = Number.parseInt(expValue, 10) || 1, value = Number.parseInt(value, 10) || 0;
            break;
        }
        switch (modifier) {
          case "min":
            return value >= expValue;
          case "max":
            return value <= expValue;
          default:
            return value === expValue;
        }
      });
      return expressionsMatch && !inverse || !expressionsMatch && inverse;
    }
  });
}
function parseQuery(mediaQuery) {
  return mediaQuery.split(",").map(function(query2) {
    query2 = query2.trim();
    var captures = query2.match(RE_MEDIA_QUERY);
    if (!captures) return null;
    var modifier = captures[1], type = captures[2], expressionsCapture = captures[3] || "", expressions = expressionsCapture.match(/\([^\)]+\)/g) || [];
    return {
      inverse: !!modifier && modifier.toLowerCase() === "not",
      type: type ? type.toLowerCase() : "all",
      expressions: expressions.map(function(expression) {
        var captures2 = expression.match(RE_MQ_EXPRESSION), feature = captures2[1].toLowerCase().match(RE_MQ_FEATURE);
        return {
          modifier: feature[1],
          feature: feature[2],
          value: captures2[2]
        };
      })
    };
  });
}
function toDecimal(ratio) {
  var decimal = Number(ratio), numbers;
  return decimal || (numbers = ratio.match(/^(\d+)\s*\/\s*(\d+)$/), decimal = numbers[1] / numbers[2]), decimal;
}
function toDpi(resolution) {
  var _String_match, value = Number.parseFloat(resolution), units = (_String_match = String(resolution).match(RE_RESOLUTION_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "dpcm":
      return value / 2.54;
    case "dppx":
      return value * 96;
    default:
      return value;
  }
}
function toPx(length) {
  var _String_match, value = Number.parseFloat(length), units = (_String_match = String(length).match(RE_LENGTH_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "em":
      return value * 16;
    case "rem":
      return value * 16;
    case "cm":
      return value * 96 / 2.54;
    case "mm":
      return value * 96 / 2.54 / 10;
    case "in":
      return value * 96;
    case "pt":
      return value * 72;
    case "pc":
      return value * 72 / 12;
    default:
      return value;
  }
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var NativeMediaQueryList = /* @__PURE__ */ (function() {
  function NativeMediaQueryList2(query2) {
    var _this = this;
    _class_call_check(this, NativeMediaQueryList2), _define_property(this, "query", void 0), _define_property(this, "listeners", void 0), this.query = query2, this.listeners = [], this.notify(), Dimensions2.addEventListener("change", function() {
      _this.notify();
    });
  }
  return _create_class(NativeMediaQueryList2, [{
    key: "orientation",
    get: function() {
      var windowDimensions = Dimensions2.get("window");
      return windowDimensions.height > windowDimensions.width ? "portrait" : "landscape";
    }
  }, {
    key: "notify",
    value: function() {
      var _this = this;
      this.listeners.forEach(function(listener) {
        listener(_this.orientation);
      });
    }
  }, {
    key: "addListener",
    value: function(listener) {
      this.listeners.push(listener);
    }
  }, {
    key: "removeListener",
    value: function(listener) {
      var index2 = this.listeners.indexOf(listener);
      index2 !== -1 && this.listeners.splice(index2, 1);
    }
  }, {
    key: "match",
    value: function(query2, param) {
      var {
        width,
        height
      } = param;
      return matchQuery(query2, {
        type: "screen",
        orientation: height > width ? "portrait" : "landscape",
        "device-width": width,
        "device-height": height
      });
    }
  }, {
    key: "matches",
    get: function() {
      var windowDimensions = Dimensions2.get("window"), matches = matchQuery(this.query, __spreadProps(__spreadValues({
        type: "screen",
        orientation: this.orientation
      }, windowDimensions), {
        "device-width": windowDimensions.width,
        "device-height": windowDimensions.height
      }));
      return matches;
    }
  }]), NativeMediaQueryList2;
})();
var matchMedia = function(query2) {
  return new NativeMediaQueryList(query2);
};
function createMedia(media) {
  return setupMatchMedia(matchMedia), media;
}
function createOptimizedView(children, viewProps, baseViews2) {
  var _a, _b, _c;
  const TextAncestor = baseViews2.TextAncestor;
  const {
    accessibilityElementsHidden,
    accessibilityLabel,
    accessibilityLabelledBy,
    accessibilityLiveRegion,
    accessibilityState,
    accessibilityValue,
    "aria-busy": ariaBusy,
    "aria-checked": ariaChecked,
    "aria-disabled": ariaDisabled,
    "aria-expanded": ariaExpanded,
    "aria-hidden": ariaHidden,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-live": ariaLive,
    "aria-selected": ariaSelected,
    "aria-valuemax": ariaValueMax,
    "aria-valuemin": ariaValueMin,
    "aria-valuenow": ariaValueNow,
    "aria-valuetext": ariaValueText,
    focusable,
    id: id2,
    role,
    tabIndex
    // ...otherProps
  } = viewProps;
  const _accessibilityLabelledBy = (_a = ariaLabelledBy == null ? void 0 : ariaLabelledBy.split(/\s*,\s*/g)) != null ? _a : accessibilityLabelledBy;
  let _accessibilityState;
  if (accessibilityState != null || ariaBusy != null || ariaChecked != null || ariaDisabled != null || ariaExpanded != null || ariaSelected != null) {
    _accessibilityState = {
      busy: ariaBusy != null ? ariaBusy : accessibilityState == null ? void 0 : accessibilityState.busy,
      checked: ariaChecked != null ? ariaChecked : accessibilityState == null ? void 0 : accessibilityState.checked,
      disabled: ariaDisabled != null ? ariaDisabled : accessibilityState == null ? void 0 : accessibilityState.disabled,
      expanded: ariaExpanded != null ? ariaExpanded : accessibilityState == null ? void 0 : accessibilityState.expanded,
      selected: ariaSelected != null ? ariaSelected : accessibilityState == null ? void 0 : accessibilityState.selected
    };
  }
  let _accessibilityValue;
  if (accessibilityValue != null || ariaValueMax != null || ariaValueMin != null || ariaValueNow != null || ariaValueText != null) {
    _accessibilityValue = {
      max: ariaValueMax != null ? ariaValueMax : accessibilityValue == null ? void 0 : accessibilityValue.max,
      min: ariaValueMin != null ? ariaValueMin : accessibilityValue == null ? void 0 : accessibilityValue.min,
      now: ariaValueNow != null ? ariaValueNow : accessibilityValue == null ? void 0 : accessibilityValue.now,
      text: ariaValueText != null ? ariaValueText : accessibilityValue == null ? void 0 : accessibilityValue.text
    };
  }
  if ((_b = viewProps.style) == null ? void 0 : _b.pointerEvents) {
    viewProps.pointerEvents = (_c = viewProps.style) == null ? void 0 : _c.pointerEvents;
  }
  if (id2) {
    viewProps.nativeID = id2;
  }
  if (ariaHidden === true) {
    viewProps.importantForAccessibility = "no-hide-descendants";
  }
  if (_accessibilityValue) {
    viewProps.accessibilityValue = _accessibilityValue;
  }
  if (role) {
    viewProps.accessibilityRole = getAccessibilityRoleFromRole(role);
  }
  if (ariaLive === "off") {
    viewProps.accessibilityLiveRegion = "none";
  } else {
    const alr = ariaLive != null ? ariaLive : accessibilityLiveRegion;
    if (alr) {
      viewProps.accessibilityLiveRegion = alr;
    }
  }
  const al = ariaLabel != null ? ariaLabel : accessibilityLabel;
  if (al) {
    viewProps.accessibilityLabel = al;
  }
  const f = tabIndex !== void 0 ? !tabIndex : focusable;
  if (f != null) {
    viewProps.focusable = f;
  }
  if (_accessibilityState != null) {
    viewProps.accessibilityState = _accessibilityState;
  }
  const ah = ariaHidden != null ? ariaHidden : accessibilityElementsHidden;
  if (ah != null) {
    viewProps.accessibilityElementsHidden = ah;
  }
  if (_accessibilityLabelledBy) {
    viewProps.accessibilityLabelledBy = _accessibilityLabelledBy;
  }
  const isInText = React.useContext(TextAncestor);
  const finalElement = React.createElement("RCTView", viewProps, children);
  if (!isInText) {
    return finalElement;
  }
  return React.createElement(TextAncestor.Provider, { value: false }, finalElement);
}
function getAccessibilityRoleFromRole(role) {
  switch (role) {
    case "alert":
      return "alert";
    case "alertdialog":
      return;
    case "application":
      return;
    case "article":
      return;
    case "banner":
      return;
    case "button":
      return "button";
    case "cell":
      return;
    case "checkbox":
      return "checkbox";
    case "columnheader":
      return;
    case "combobox":
      return "combobox";
    case "complementary":
      return;
    case "contentinfo":
      return;
    case "definition":
      return;
    case "dialog":
      return;
    case "directory":
      return;
    case "document":
      return;
    case "feed":
      return;
    case "figure":
      return;
    case "form":
      return;
    case "grid":
      return "grid";
    case "group":
      return;
    case "heading":
      return "header";
    case "img":
      return "image";
    case "link":
      return "link";
    case "list":
      return "list";
    case "listitem":
      return;
    case "log":
      return;
    case "main":
      return;
    case "marquee":
      return;
    case "math":
      return;
    case "menu":
      return "menu";
    case "menubar":
      return "menubar";
    case "menuitem":
      return "menuitem";
    case "meter":
      return;
    case "navigation":
      return;
    case "none":
      return "none";
    case "note":
      return;
    case "option":
      return;
    case "presentation":
      return "none";
    case "progressbar":
      return "progressbar";
    case "radio":
      return "radio";
    case "radiogroup":
      return "radiogroup";
    case "region":
      return;
    case "row":
      return;
    case "rowgroup":
      return;
    case "rowheader":
      return;
    case "scrollbar":
      return "scrollbar";
    case "searchbox":
      return "search";
    case "separator":
      return;
    case "slider":
      return "adjustable";
    case "spinbutton":
      return "spinbutton";
    case "status":
      return;
    case "summary":
      return "summary";
    case "switch":
      return "switch";
    case "tab":
      return "tab";
    case "table":
      return;
    case "tablist":
      return "tablist";
    case "tabpanel":
      return;
    case "term":
      return;
    case "timer":
      return "timer";
    case "toolbar":
      return "toolbar";
    case "tooltip":
      return;
    case "tree":
      return;
    case "treegrid":
      return;
    case "treeitem":
      return;
  }
  return;
}
function getBaseViews() {
  var _a, _b, _c, _d;
  const native = require("react-native");
  return {
    View: native.View || ((_a = native.default) == null ? void 0 : _a.View),
    Text: native.Text || ((_b = native.default) == null ? void 0 : _b.Text),
    TextAncestor: native.unstable_TextAncestorContext,
    StyleSheet: native.StyleSheet || ((_c = native.default) == null ? void 0 : _c.StyleSheet),
    Pressable: native.Pressable || ((_d = native.default) == null ? void 0 : _d.Pressable)
  };
}
require("react-native/Libraries/Pressability/Pressability").default;
const usePressability = require("react-native/Libraries/Pressability/usePressability").default;
const TamaguiProvider = (props) => {
  useIsomorphicLayoutEffect(() => {
    enable();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TamaguiProvider$1, __spreadValues({}, props));
};
const createTamagui = (conf2) => {
  {
    if (conf2.media) {
      conf2.media = createMedia(conf2.media);
    }
  }
  return createTamagui$1(conf2);
};
const baseViews = getBaseViews();
setupHooks(__spreadValues({
  getBaseViews,
  setElementProps: (node) => {
  },
  usePropsTransform(elementType, propsIn, stateRef, willHydrate) {
  },
  useEvents(viewProps, events, splitStyles, setStateShallow, staticConfig) {
    {
      if (events) {
        if (events.onFocus) {
          viewProps["onFocus"] = events.onFocus;
        }
        if (events.onBlur) {
          viewProps["onBlur"] = events.onBlur;
        }
      }
      if (staticConfig.isInput) {
        if (events) {
          const { onPressIn, onPressOut, onPress } = events;
          const inputEvents = {
            onPressIn,
            onPressOut: onPressOut || onPress
          };
          if (onPressOut && onPress) {
            inputEvents.onPressOut = composeEventHandlers(onPress, onPressOut);
          }
          Object.assign(viewProps, inputEvents);
        }
      } else {
        if (events && viewProps.hitSlop) {
          events.hitSlop = viewProps.hitSlop;
        }
        const pressability = usePressability(events);
        if (events) {
          if (events.onPress) {
            for (const key in pressability) {
              const og = viewProps[key];
              const val = pressability[key];
              viewProps[key] = og && !dontComposePressabilityKeys[key] ? composeEventHandlers(og, val) : val;
            }
          }
        }
      }
    }
  }
}, {
  useChildren(elementType, children, viewProps) {
    if (elementType === baseViews.View && baseViews.TextAncestor) {
      return createOptimizedView(children, viewProps, baseViews);
    }
  }
}));
const dontComposePressabilityKeys = {
  onClick: true
};
const View = View$1;
const Stack = Stack$1;
const Text = Text$1;
exports.ClientOnly = ClientOnly;
exports.ClientOnlyContext = ClientOnlyContext;
exports.ComponentContext = ComponentContext;
exports.Configuration = Configuration;
exports.FONT_DATA_ATTRIBUTE_NAME = FONT_DATA_ATTRIBUTE_NAME;
exports.FontLanguage = FontLanguage;
exports.GroupContext = GroupContext;
exports.IS_REACT_19 = IS_REACT_19;
exports.LayoutMeasurementController = LayoutMeasurementController;
exports.MEDIA_SEP = MEDIA_SEP;
exports.MISSING_THEME_MESSAGE = MISSING_THEME_MESSAGE;
exports.PROP_SPLIT = PROP_SPLIT;
exports.Slot = Slot;
exports.Slottable = Slottable;
exports.Spacer = Spacer;
exports.Stack = Stack;
exports.StyleObjectIdentifier = StyleObjectIdentifier;
exports.StyleObjectProperty = StyleObjectProperty;
exports.StyleObjectPseudo = StyleObjectPseudo;
exports.StyleObjectRules = StyleObjectRules;
exports.StyleObjectValue = StyleObjectValue;
exports.THEME_CLASSNAME_PREFIX = THEME_CLASSNAME_PREFIX;
exports.THEME_NAME_SEPARATOR = THEME_NAME_SEPARATOR;
exports.Tamagui = Tamagui;
exports.TamaguiProvider = TamaguiProvider;
exports.Text = Text;
exports.Theme = Theme;
exports.ThemeProvider = ThemeProvider;
exports.Unspaced = Unspaced;
exports.View = View;
exports._disableMediaTouch = _disableMediaTouch;
exports._withStableStyle = _withStableStyle;
exports.clamp = clamp;
exports.componentSetStates = componentSetStates;
exports.composeEventHandlers = composeEventHandlers;
exports.composeRefs = composeRefs;
exports.configureMedia = configureMedia;
exports.createCSSVariable = createCSSVariable;
exports.createComponent = createComponent;
exports.createFont = createFont;
exports.createMediaStyle = createMediaStyle;
exports.createShorthands = createShorthands;
exports.createStyledContext = createStyledContext;
exports.createTamagui = createTamagui;
exports.createTheme = createTheme;
exports.createTokens = createTokens;
exports.createVariable = createVariable;
exports.createVariables = createVariables;
exports.currentPlatform = currentPlatform;
exports.defaultMediaImportance = defaultMediaImportance;
exports.didGetVariableValue = didGetVariableValue;
exports.ensureThemeVariable = ensureThemeVariable;
exports.fixStyles = fixStyles;
exports.forceUpdateThemes = forceUpdateThemes;
exports.getCSSStylesAtomic = getCSSStylesAtomic;
exports.getConfig = getConfig;
exports.getExpandedShorthand = getExpandedShorthand;
exports.getExpandedShorthands = getExpandedShorthands;
exports.getFontFamilyFromNameOrVariable = getFontFamilyFromNameOrVariable;
exports.getFontsForLanguage = getFontsForLanguage;
exports.getMedia = getMedia;
exports.getReactNativeConfig = getReactNativeConfig;
exports.getRgba = getRgba;
exports.getSetting = getSetting;
exports.getShorthandValue = getShorthandValue;
exports.getSplitStyles = getSplitStyles;
exports.getStyleAtomic = getStyleAtomic;
exports.getStyleTags = getStyleTags;
exports.getSubStyle = getSubStyle;
exports.getThemeCSSRules = getThemeCSSRules;
exports.getThemedChildren = getThemedChildren;
exports.getThemes = getThemes;
exports.getToken = getToken;
exports.getTokenForKey = getTokenForKey;
exports.getTokenValue = getTokenValue;
exports.getTokens = getTokens;
exports.getValueFromIdentifier = getValueFromIdentifier;
exports.getVariable = getVariable;
exports.getVariableName = getVariableName;
exports.getVariableValue = getVariableValue;
exports.getVariableVariable = getVariableVariable;
exports.getVariantExtras = getVariantExtras;
exports.hooks = hooks;
exports.insertFont = insertFont;
exports.insertStyleRules = insertStyleRules;
exports.isAndroid = isAndroid;
exports.isChrome = isChrome;
exports.isClient = isClient;
exports.isEqualShallow = isEqualShallow;
exports.isIos = isIos;
exports.isServer = isServer;
exports.isTamaguiComponent = isTamaguiComponent;
exports.isTamaguiElement = isTamaguiElement;
exports.isTouchable = isTouchable;
exports.isVariable = isVariable;
exports.isWeb = isWeb;
exports.isWebTouchable = isWebTouchable;
exports.isWindowDefined = isWindowDefined;
exports.matchMedia = matchMedia$1;
exports.mediaKeyMatch = mediaKeyMatch;
exports.mediaObjectToString = mediaObjectToString;
exports.mediaQueryConfig = mediaQueryConfig;
exports.mergeComponentProps = mergeComponentProps;
exports.mergeIfNotShallowEqual = mergeIfNotShallowEqual;
exports.mergeProps = mergeProps;
exports.normalizeColor = normalizeColor;
exports.normalizeStyle = normalizeStyle$1;
exports.normalizeValueWithProperty = normalizeValueWithProperty;
exports.parseFont = parseFont;
exports.propMapper = propMapper;
exports.proxyThemeToParents = proxyThemeToParents;
exports.proxyThemeVariables = proxyThemeVariables;
exports.proxyThemesToParents = proxyThemesToParents;
exports.pseudoDescriptors = pseudoDescriptors;
exports.pseudoDescriptorsBase = pseudoDescriptorsBase;
exports.pseudoPriorities = pseudoPriorities;
exports.px = px;
exports.registerFontVariables = registerFontVariables;
exports.rgba = rgba;
exports.setConfig = setConfig;
exports.setDidGetVariableValue = setDidGetVariableValue;
exports.setIdentifierValue = setIdentifierValue;
exports.setNonce = setNonce;
exports.setOnLayoutStrategy = setOnLayoutStrategy;
exports.setRef = setRef;
exports.setupDev = setupDev;
exports.setupHooks = setupHooks;
exports.setupMatchMedia = setupMatchMedia;
exports.setupReactNative = setupReactNative;
exports.shouldRenderNativePlatform = shouldRenderNativePlatform;
exports.simpleHash = simpleHash;
exports.spacedChildren = spacedChildren;
exports.stackDefaultStyles = stackDefaultStyles;
exports.styleOriginalValues = styleOriginalValues;
exports.stylePropsAll = stylePropsAll;
exports.stylePropsText = stylePropsText;
exports.stylePropsTextOnly = stylePropsTextOnly;
exports.stylePropsTransform = stylePropsTransform;
exports.stylePropsUnitless = stylePropsUnitless;
exports.stylePropsView = stylePropsView;
exports.styleToCSS = styleToCSS;
exports.styled = styled;
exports.themeable = themeable;
exports.tokenCategories = tokenCategories;
exports.transformsToString = transformsToString;
exports.updateConfig = updateConfig;
exports.updateFont = updateFont;
exports.useClientValue = useClientValue;
exports.useComposedRefs = useComposedRefs;
exports.useConfiguration = useConfiguration;
exports.useCreateShallowSetState = useCreateShallowSetState;
exports.useDidFinishSSR = useDidFinishSSR;
exports.useEvent = useEvent;
exports.useGet = useGet;
exports.useIsClientOnly = useIsClientOnly;
exports.useIsTouchDevice = useIsTouchDevice;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useMedia = useMedia;
exports.useProps = useProps;
exports.usePropsAndStyle = usePropsAndStyle;
exports.useSplitStyles = useSplitStyles;
exports.useStyle = useStyle;
exports.useTheme = useTheme;
exports.useThemeName = useThemeName;
exports.useThemeWithState = useThemeWithState;
exports.validPseudoKeys = validPseudoKeys;
exports.validStyles = validStyles;
exports.variableToString = variableToString;
exports.webViewFlexCompatStyles = webViewFlexCompatStyles;
exports.withStaticProperties = withStaticProperties;
