"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a, prop, b2[prop]);
    }
  return a;
};
var __spreadProps = (a, b2) => __defProps(a, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
function _interopNamespaceDefault(e2) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e2) {
    for (const k in e2) {
      if (k !== "default") {
        const d = Object.getOwnPropertyDescriptor(e2, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: () => e2[k]
        });
      }
    }
  }
  n.default = e2;
  return Object.freeze(n);
}
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e2 = m[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k in e2) {
        if (k !== "default" && !(k in n)) {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          if (d) {
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: () => e2[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
if (typeof globalThis["__DEV__"] === "undefined") {
  globalThis["__DEV__"] = false;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_development = {};
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function() {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch ("number" === typeof type.tag && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e2) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty2.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return false;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          displayName
        ));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
      self = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
      var children = config.children;
      if (void 0 !== children)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else validateChildKeys(children);
      if (hasOwnProperty2.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function(k) {
          return "key" !== k;
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
          'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
          isStaticChildren,
          children,
          keys,
          children
        ), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children && defineKeyPropWarningGetter(
        maybeKey,
        "function" === typeof type ? type.displayName || type.name || "Unknown" : type
      );
      return ReactElement(
        type,
        children,
        self,
        source,
        getOwner(),
        maybeKey,
        debugStack,
        debugTask
      );
    }
    function validateChildKeys(node) {
      "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React$1 = React, REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty2 = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React$1 = {
      "react-stack-bottom-frame": function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React$1["react-stack-bottom-frame"].bind(
      React$1,
      UnknownOwner
    )();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_development.jsx = function(type, config, maybeKey, source, self) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        false,
        source,
        self,
        trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
    reactJsxRuntime_development.jsxs = function(type, config, maybeKey, source, self) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        true,
        source,
        self,
        trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
  })();
  return reactJsxRuntime_development;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_development();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
const assets = [];
function getAssetByID(assetId) {
  return assets[assetId - 1];
}
const defaultProps$1 = {
  children: true,
  dataSet: true,
  nativeID: true,
  ref: true,
  suppressHydrationWarning: true,
  testID: true,
  id: true
}, accessibilityProps = {
  accessibilityActiveDescendant: true,
  accessibilityAtomic: true,
  accessibilityAutoComplete: true,
  accessibilityBusy: true,
  accessibilityChecked: true,
  accessibilityColumnCount: true,
  accessibilityColumnIndex: true,
  accessibilityColumnSpan: true,
  accessibilityControls: true,
  accessibilityCurrent: true,
  accessibilityDescribedBy: true,
  accessibilityDetails: true,
  accessibilityDisabled: true,
  accessibilityErrorMessage: true,
  accessibilityExpanded: true,
  accessibilityFlowTo: true,
  accessibilityHasPopup: true,
  accessibilityHidden: true,
  accessibilityInvalid: true,
  accessibilityKeyShortcuts: true,
  accessibilityLabel: true,
  accessibilityLabelledBy: true,
  accessibilityLevel: true,
  accessibilityLiveRegion: true,
  accessibilityModal: true,
  accessibilityMultiline: true,
  accessibilityMultiSelectable: true,
  accessibilityOrientation: true,
  accessibilityOwns: true,
  accessibilityPlaceholder: true,
  accessibilityPosInSet: true,
  accessibilityPressed: true,
  accessibilityReadOnly: true,
  accessibilityRequired: true,
  accessibilityRole: true,
  accessibilityRoleDescription: true,
  accessibilityRowCount: true,
  accessibilityRowIndex: true,
  accessibilityRowSpan: true,
  accessibilitySelected: true,
  accessibilitySetSize: true,
  accessibilitySort: true,
  accessibilityValueMax: true,
  accessibilityValueMin: true,
  accessibilityValueNow: true,
  accessibilityValueText: true,
  dir: true,
  focusable: true
}, clickProps = {
  onClick: true,
  onClickCapture: true,
  onContextMenu: true
}, focusProps = {
  onBlur: true,
  onFocus: true
}, keyboardProps = {
  onKeyDown: true,
  onKeyDownCapture: true,
  onKeyUp: true,
  onKeyUpCapture: true
}, mouseProps = {
  onMouseDown: true,
  onMouseEnter: true,
  onMouseLeave: true,
  onMouseMove: true,
  onMouseOver: true,
  onMouseOut: true,
  onMouseUp: true
}, touchProps = {
  onTouchCancel: true,
  onTouchCancelCapture: true,
  onTouchEnd: true,
  onTouchEndCapture: true,
  onTouchMove: true,
  onTouchMoveCapture: true,
  onTouchStart: true,
  onTouchStartCapture: true
}, styleProps = {
  classList: true,
  style: true
}, forwardedProps = {
  defaultProps: defaultProps$1,
  accessibilityProps,
  clickProps,
  focusProps,
  keyboardProps,
  mouseProps,
  touchProps,
  styleProps
}, forwardPropsListText = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaultProps$1), accessibilityProps), clickProps), focusProps), keyboardProps), mouseProps), touchProps), styleProps), {
  href: true,
  lang: true,
  pointerEvents: true
}), forwardPropsListView = __spreadProps(__spreadValues({}, forwardPropsListText), {
  onScroll: true,
  onWheel: true
});
function mergeRefs(...args) {
  return function(node) {
    args.forEach((ref) => {
      if (ref != null) {
        if (typeof ref == "function") {
          ref(node);
          return;
        }
        if (typeof ref == "object") {
          ref.current = node;
          return;
        }
        console.error(`mergeRefs cannot handle Refs of type boolean, number or string, received ref ${String(ref)}`);
      }
    });
  };
}
const canUseDOM$1 = !!(typeof window < "u" && window.document && window.document.createElement);
const emptyFunction$1 = () => {
};
function supportsPassiveEvents() {
  let supported = false;
  if (canUseDOM$1) try {
    const options = {};
    Object.defineProperty(options, "passive", {
      get() {
        return supported = true, false;
      }
    }), window.addEventListener("test", null, options), window.removeEventListener("test", null, options);
  } catch (e2) {
  }
  return supported;
}
const canUsePassiveEvents = supportsPassiveEvents();
function getOptions(options) {
  return options == null ? false : canUsePassiveEvents ? options : !!options.capture;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function normalizeEvent(event) {
  return event.nativeEvent = event, event.persist = emptyFunction$1, event.isDefaultPrevented = isDefaultPrevented, event.isPropagationStopped = isPropagationStopped, event;
}
function createEventHandle(type, options) {
  const opts2 = getOptions(options);
  return function(target, listener) {
    if (target == null || typeof target.addEventListener != "function") throw new Error("createEventHandle: called on an invalid target.");
    const element = target;
    if (listener != null) {
      const compatListener = (e2) => listener(normalizeEvent(e2));
      return element.addEventListener(type, compatListener, opts2), function() {
        element == null ? void 0 : element.removeEventListener(type, compatListener, opts2);
      };
    } else return emptyFunction$1;
  };
}
const supportsPointerEvent$1 = () => typeof window < "u" && window.PointerEvent != null;
let activeModality = "keyboard", modality = "keyboard", previousModality, previousActiveModality, isEmulatingMouseEvents$1 = false;
const listeners$3 = /* @__PURE__ */ new Set(), KEYBOARD = "keyboard", MOUSE = "mouse", TOUCH = "touch", BLUR = "blur", CONTEXTMENU = "contextmenu", FOCUS = "focus", KEYDOWN = "keydown", MOUSEDOWN = "mousedown", MOUSEMOVE = "mousemove", MOUSEUP = "mouseup", POINTERDOWN = "pointerdown", POINTERMOVE = "pointermove", SCROLL$1 = "scroll", SELECTIONCHANGE = "selectionchange", TOUCHCANCEL = "touchcancel", TOUCHMOVE = "touchmove", TOUCHSTART = "touchstart", VISIBILITYCHANGE = "visibilitychange", bubbleOptions = {
  passive: true
}, captureOptions = {
  capture: true,
  passive: true
}, addBlurListener = createEventHandle(BLUR, bubbleOptions), addFocusListener = createEventHandle(FOCUS, bubbleOptions), addVisibilityChangeListener = createEventHandle(VISIBILITYCHANGE, captureOptions), addKeyDownListener = createEventHandle(KEYDOWN, captureOptions), addPointerDownListener = createEventHandle(POINTERDOWN, captureOptions), addPointerMoveListener = createEventHandle(POINTERMOVE, captureOptions), addContextMenuListener = createEventHandle(CONTEXTMENU, captureOptions), addMouseDownListener = createEventHandle(MOUSEDOWN, captureOptions), addMouseMoveListener = createEventHandle(MOUSEMOVE, captureOptions), addMouseUpListener = createEventHandle(MOUSEUP, captureOptions), addScrollListener = createEventHandle(SCROLL$1, captureOptions), addSelectiomChangeListener = createEventHandle(SELECTIONCHANGE, captureOptions), addTouchCancelListener = createEventHandle(TOUCHCANCEL, captureOptions), addTouchMoveListener = createEventHandle(TOUCHMOVE, captureOptions), addTouchStartListener = createEventHandle(TOUCHSTART, captureOptions);
function restoreModality() {
  (previousModality != null || previousActiveModality != null) && (previousModality != null && (modality = previousModality, previousModality = null), previousActiveModality != null && (activeModality = previousActiveModality, previousActiveModality = null), callListeners());
}
function onBlurWindow() {
  previousModality = modality, previousActiveModality = activeModality, activeModality = KEYBOARD, modality = KEYBOARD, callListeners(), isEmulatingMouseEvents$1 = false;
}
function onFocusWindow() {
  restoreModality();
}
function onKeyDown(event) {
  event.metaKey || event.altKey || event.ctrlKey || modality !== KEYBOARD && (modality = KEYBOARD, activeModality = KEYBOARD, callListeners());
}
function onVisibilityChange() {
  document.visibilityState !== "hidden" && restoreModality();
}
function onPointerish(event) {
  const eventType = event.type;
  if (supportsPointerEvent$1()) {
    if (eventType === POINTERDOWN) {
      activeModality !== event.pointerType && (modality = event.pointerType, activeModality = event.pointerType, callListeners());
      return;
    }
    if (eventType === POINTERMOVE) {
      modality !== event.pointerType && (modality = event.pointerType, callListeners());
      return;
    }
  } else {
    if (isEmulatingMouseEvents$1 || (eventType === MOUSEDOWN && activeModality !== MOUSE && (modality = MOUSE, activeModality = MOUSE, callListeners()), eventType === MOUSEMOVE && modality !== MOUSE && (modality = MOUSE, callListeners())), eventType === TOUCHSTART) {
      isEmulatingMouseEvents$1 = true, event.touches && event.touches.length > 1 && (isEmulatingMouseEvents$1 = false), activeModality !== TOUCH && (modality = TOUCH, activeModality = TOUCH, callListeners());
      return;
    }
    (eventType === CONTEXTMENU || eventType === MOUSEUP || eventType === SELECTIONCHANGE || eventType === SCROLL$1 || eventType === TOUCHCANCEL || eventType === TOUCHMOVE) && (isEmulatingMouseEvents$1 = false);
  }
}
canUseDOM$1 && (addBlurListener(window, onBlurWindow), addFocusListener(window, onFocusWindow), addKeyDownListener(document, onKeyDown), addPointerDownListener(document, onPointerish), addPointerMoveListener(document, onPointerish), addVisibilityChangeListener(document, onVisibilityChange), addContextMenuListener(document, onPointerish), addMouseDownListener(document, onPointerish), addMouseMoveListener(document, onPointerish), addMouseUpListener(document, onPointerish), addTouchCancelListener(document, onPointerish), addTouchMoveListener(document, onPointerish), addTouchStartListener(document, onPointerish), addSelectiomChangeListener(document, onPointerish), addScrollListener(document, onPointerish));
function callListeners() {
  const value = {
    activeModality,
    modality
  };
  listeners$3.forEach((listener) => {
    listener(value);
  });
}
function getModality() {
  return modality;
}
const rtlScripts = /* @__PURE__ */ new Set(["Arab", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]), rtlLangs = /* @__PURE__ */ new Set([
  "ae",
  // Avestan
  "ar",
  // Arabic
  "arc",
  // Aramaic
  "bcc",
  // Southern Balochi
  "bqi",
  // Bakthiari
  "ckb",
  // Sorani
  "dv",
  // Dhivehi
  "fa",
  "far",
  // Persian
  "glk",
  // Gilaki
  "he",
  "iw",
  // Hebrew
  "khw",
  // Khowar
  "ks",
  // Kashmiri
  "ku",
  // Kurdish
  "mzn",
  // Mazanderani
  "nqo",
  // N'Ko
  "pnb",
  // Western Punjabi
  "ps",
  // Pashto
  "sd",
  // Sindhi
  "ug",
  // Uyghur
  "ur",
  // Urdu
  "yi"
  // Yiddish
]), cache$7 = /* @__PURE__ */ new Map();
function isLocaleRTL(locale) {
  const cachedRTL = cache$7.get(locale);
  if (cachedRTL) return cachedRTL;
  let isRTL = false;
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script;
    isRTL = rtlScripts.has(script);
  } else {
    const lang = locale.split("-")[0];
    isRTL = rtlLangs.has(lang);
  }
  return cache$7.set(locale, isRTL), isRTL;
}
const defaultLocale = {
  direction: "ltr",
  locale: "en-US"
}, LocaleContext = React.createContext(defaultLocale);
function getLocaleDirection(locale) {
  return isLocaleRTL(locale) ? "rtl" : "ltr";
}
function LocaleProvider(props) {
  const {
    direction,
    locale,
    children
  } = props;
  return direction || locale ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleContext.Provider, {
    value: {
      direction: locale ? getLocaleDirection(locale) : direction,
      locale
    },
    children
  }) : children;
}
function useLocaleContext() {
  return React.useContext(LocaleContext);
}
function useCreateShallowSetState(setter, debug) {
  return React.useCallback(function(stateOrGetState) {
    setter(function(prev) {
      var next = typeof stateOrGetState == "function" ? stateOrGetState(prev) : stateOrGetState, update2 = mergeIfNotShallowEqual(prev, next);
      return update2;
    });
  }, [setter, debug]);
}
function mergeIfNotShallowEqual(prev, next) {
  return !prev || !next || isEqualShallow(prev, next) ? prev || next : __spreadValues(__spreadValues({}, prev), next);
}
function isEqualShallow(prev, next) {
  for (var key in next) if (prev[key] !== next[key]) return false;
  return true;
}
function _instanceof$1(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
var LayoutHandlers = /* @__PURE__ */ new WeakMap(), LayoutDisableKey = /* @__PURE__ */ new WeakMap(), Nodes = /* @__PURE__ */ new Set(), IntersectionState = /* @__PURE__ */ new WeakMap(), DisableLayoutContextKey = /* @__PURE__ */ React.createContext(""), LayoutMeasurementController = function(param) {
  var {
    disable,
    children
  } = param, id2 = React.useId();
  return useIsomorphicLayoutEffect(function() {
  }, [disable, id2]), /* @__PURE__ */ jsxRuntimeExports.jsx(DisableLayoutContextKey.Provider, {
    value: id2,
    children
  });
};
function setOnLayoutStrategy(state) {
}
var NodeRectCache = /* @__PURE__ */ new WeakMap(), LastChangeTime = /* @__PURE__ */ new WeakMap(), avoidUpdates = true, queuedUpdates = /* @__PURE__ */ new Map();
function enable() {
  avoidUpdates && (avoidUpdates = false, queuedUpdates && (queuedUpdates.forEach(function(cb) {
    return cb();
  }), queuedUpdates.clear()));
}
var getElementLayoutEvent = function(nodeRect, parentRect) {
  return {
    nativeEvent: {
      layout: getRelativeDimensions(nodeRect, parentRect),
      target: nodeRect
    },
    timeStamp: Date.now()
  };
}, getRelativeDimensions = function(a, b2) {
  var {
    height,
    left,
    top,
    width
  } = a, x = left - b2.left, y = top - b2.top;
  return {
    x,
    y,
    width,
    height,
    pageX: a.left,
    pageY: a.top
  };
};
function useElementLayout$1(ref, onLayout) {
  var _ref_current, disableKey = React.useContext(DisableLayoutContextKey), node = ensureWebElement((_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.host);
  node && onLayout && (LayoutHandlers.set(node, onLayout), LayoutDisableKey.set(node, disableKey)), useIsomorphicLayoutEffect(function() {
    var _ref_current2;
    if (onLayout) {
      var node2 = (_ref_current2 = ref.current) === null || _ref_current2 === void 0 ? void 0 : _ref_current2.host;
      if (node2) {
        Nodes.add(node2);
        var parentNode = node2.parentNode;
        return parentNode && onLayout(getElementLayoutEvent(node2.getBoundingClientRect(), parentNode.getBoundingClientRect())), function() {
          Nodes.delete(node2), LayoutHandlers.delete(node2), NodeRectCache.delete(node2), LastChangeTime.delete(node2), IntersectionState.delete(node2);
        };
      }
    }
  }, [ref, !!onLayout]);
}
function ensureWebElement(x) {
  if (!(typeof HTMLElement > "u")) return _instanceof$1(x, HTMLElement) ? x : void 0;
}
var getBoundingClientRectAsync = function(node) {
  return new Promise(function(res) {
    if (!node || node.nodeType !== 1) return res(false);
    var io = new IntersectionObserver(function(entries) {
      return io.disconnect(), res(entries[0].boundingClientRect);
    }, {
      threshold: 0
    });
    io.observe(node);
  });
}, measureNode = function(node, relativeTo) {
  return __async(this, null, function* () {
    var relativeNode = relativeTo || (node == null ? void 0 : node.parentElement);
    if (_instanceof$1(relativeNode, HTMLElement)) {
      var [nodeDim, relativeNodeDim] = yield Promise.all([getBoundingClientRectAsync(node), getBoundingClientRectAsync(relativeNode)]);
      if (relativeNodeDim && nodeDim) return getRelativeDimensions(nodeDim, relativeNodeDim);
    }
    return null;
  });
}, measure = function(node, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, _instanceof$1(node.parentNode, HTMLElement) ? node.parentNode : null);
    return out && (callback == null ? void 0 : callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
  });
};
function createMeasure(node) {
  return function(callback) {
    return measure(node, callback);
  };
}
var measureInWindow = function(node, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, null);
    return out && (callback == null ? void 0 : callback(out.pageX, out.pageY, out.width, out.height)), out;
  });
}, createMeasureInWindow = function(node) {
  return function(callback) {
    return measureInWindow(node, callback);
  };
}, measureLayout$1 = function(node, relativeNode, callback) {
  return __async(this, null, function* () {
    var out = yield measureNode(node, relativeNode);
    return out && (callback == null ? void 0 : callback(out.x, out.y, out.width, out.height, out.pageX, out.pageY)), out;
  });
};
function createMeasureLayout(node) {
  return function(relativeTo, callback) {
    return measureLayout$1(node, relativeTo, callback);
  };
}
const UNINITIALIZED = typeof Symbol == "function" && typeof Symbol() == "symbol" ? Symbol() : Object.freeze({});
function useStable(getInitialValue) {
  const ref = React__namespace.useRef(UNINITIALIZED);
  return ref.current === UNINITIALIZED && (ref.current = getInitialValue()), ref.current;
}
function usePlatformMethods({
  pointerEvents,
  style
}) {
  return useStable(() => (hostNode) => {
    hostNode != null && (hostNode.measure = createMeasure(hostNode), hostNode.measureLayout = createMeasureLayout(hostNode), hostNode.measureInWindow = createMeasureInWindow(hostNode));
  });
}
const TextAncestorContext = React.createContext(false);
function _class_call_check$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$2(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties$2(Constructor.prototype, protoProps), Constructor;
}
function _define_property$2(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var DELAY = "DELAY", ERROR = "ERROR", LONG_PRESS_DETECTED = "LONG_PRESS_DETECTED", NOT_RESPONDER = "NOT_RESPONDER", RESPONDER_ACTIVE_LONG_PRESS_START = "RESPONDER_ACTIVE_LONG_PRESS_START", RESPONDER_ACTIVE_PRESS_START = "RESPONDER_ACTIVE_PRESS_START", RESPONDER_INACTIVE_PRESS_START = "RESPONDER_INACTIVE_PRESS_START", RESPONDER_GRANT = "RESPONDER_GRANT", RESPONDER_RELEASE = "RESPONDER_RELEASE", RESPONDER_TERMINATED = "RESPONDER_TERMINATED", Transitions = Object.freeze({
  NOT_RESPONDER: {
    DELAY: ERROR,
    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
    RESPONDER_RELEASE: ERROR,
    RESPONDER_TERMINATED: ERROR,
    LONG_PRESS_DETECTED: ERROR
  },
  RESPONDER_INACTIVE_PRESS_START: {
    DELAY: RESPONDER_ACTIVE_PRESS_START,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: ERROR
  },
  RESPONDER_ACTIVE_PRESS_START: {
    DELAY: ERROR,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
  },
  RESPONDER_ACTIVE_LONG_PRESS_START: {
    DELAY: ERROR,
    RESPONDER_GRANT: ERROR,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
  },
  ERROR: {
    DELAY: NOT_RESPONDER,
    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
    RESPONDER_RELEASE: NOT_RESPONDER,
    RESPONDER_TERMINATED: NOT_RESPONDER,
    LONG_PRESS_DETECTED: NOT_RESPONDER
  }
}), isActiveSignal = function(signal) {
  return signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
}, isButtonRole = function(element) {
  return element.getAttribute("role") === "button";
}, isPressStartSignal = function(signal) {
  return signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
}, isTerminalSignal = function(signal) {
  return signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;
}, isValidKeyPress = function(event) {
  var key = event.key, target = event.target, role = target.getAttribute("role"), isSpacebar = key === " " || key === "Spacebar";
  return key === "Enter" || isSpacebar && role === "button";
}, DEFAULT_LONG_PRESS_DELAY_MS = 450, DEFAULT_PRESS_DELAY_MS = 50, PressResponder = /* @__PURE__ */ (function() {
  function PressResponder2(config) {
    _class_call_check$2(this, PressResponder2), _define_property$2(this, "_touchActivatePosition", null), _define_property$2(this, "_pressDelayTimeout", 0), _define_property$2(this, "_selectionTerminated", false), _define_property$2(this, "_isPointerTouch", false), _define_property$2(this, "_longPressDelayTimeout", 0), _define_property$2(this, "_longPressDispatched", false), _define_property$2(this, "_pressOutDelayTimeout", 0), _define_property$2(this, "_touchState", NOT_RESPONDER), _define_property$2(this, "_config", null), _define_property$2(this, "_eventHandlers", null), this.configure(config);
  }
  return _create_class$2(PressResponder2, [{
    key: "configure",
    value: function(config) {
      this._config = config;
    }
  }, {
    /**
    * Resets any pending timers. This should be called on unmount.
    */
    key: "reset",
    value: function() {
      this._cancelLongPressDelayTimeout(), this._cancelPressDelayTimeout(), this._cancelPressOutDelayTimeout();
    }
  }, {
    /**
    * Returns a set of props to spread into the interactive element.
    */
    key: "getEventHandlers",
    value: function() {
      return this._eventHandlers == null && (this._eventHandlers = this._createEventHandlers()), this._eventHandlers;
    }
  }, {
    key: "_createEventHandlers",
    value: function() {
      var _this = this, start = function(event, shouldDelay) {
        event.persist(), _this._cancelPressOutDelayTimeout(), _this._longPressDispatched = false, _this._selectionTerminated = false, _this._touchState = NOT_RESPONDER, _this._isPointerTouch = event.nativeEvent.type === "touchstart", _this._receiveSignal(RESPONDER_GRANT, event);
        var delayPressStart = normalizeDelay(_this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);
        shouldDelay !== false && delayPressStart > 0 ? _this._pressDelayTimeout = setTimeout(function() {
          _this._receiveSignal(DELAY, event);
        }, delayPressStart) : _this._receiveSignal(DELAY, event);
        var delayLongPress = normalizeDelay(_this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);
        _this._longPressDelayTimeout = setTimeout(function() {
          _this._handleLongPress(event);
        }, delayLongPress + delayPressStart);
      }, end = function(event) {
        _this._receiveSignal(RESPONDER_RELEASE, event);
      }, keyupHandler = function(event) {
        var onPress = _this._config.onPress, target = event.target;
        if (_this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {
          end(event), document.removeEventListener("keyup", keyupHandler);
          var role = target.getAttribute("role"), elementType = target.tagName.toLowerCase(), isNativeInteractiveElement = role === "link" || elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea";
          onPress != null && !isNativeInteractiveElement && onPress(event);
        }
      };
      return {
        onStartShouldSetResponder: function(event) {
          var disabled = _this._config.disabled;
          return disabled && isButtonRole(event.currentTarget) && event.stopPropagation(), disabled == null ? true : !disabled;
        },
        onKeyDown: function(event) {
          var disabled = _this._config.disabled, key = event.key, target = event.target;
          if (!disabled && isValidKeyPress(event)) {
            _this._touchState === NOT_RESPONDER && (start(event, false), document.addEventListener("keyup", keyupHandler));
            var role = target.getAttribute("role"), isSpacebarKey = key === " " || key === "Spacebar", _isButtonRole = role === "button" || role === "menuitem";
            isSpacebarKey && _isButtonRole && event.preventDefault(), event.stopPropagation();
          }
        },
        onResponderGrant: function(event) {
          return start(event);
        },
        onResponderMove: function(event) {
          _this._config.onPressMove != null && _this._config.onPressMove(event);
          var touch = getTouchFromResponderEvent(event);
          if (_this._touchActivatePosition != null) {
            var deltaX = _this._touchActivatePosition.pageX - touch.pageX, deltaY = _this._touchActivatePosition.pageY - touch.pageY;
            Math.hypot(deltaX, deltaY) > 10 && _this._cancelLongPressDelayTimeout();
          }
        },
        onResponderRelease: function(event) {
          return end(event);
        },
        onResponderTerminate: function(event) {
          event.nativeEvent.type === "selectionchange" && (_this._selectionTerminated = true), _this._receiveSignal(RESPONDER_TERMINATED, event);
        },
        onResponderTerminationRequest: function(event) {
          var _this$_config = _this._config, cancelable = _this$_config.cancelable, disabled = _this$_config.disabled, onLongPress = _this$_config.onLongPress;
          return !disabled && onLongPress != null && _this._isPointerTouch && event.nativeEvent.type === "contextmenu" ? false : cancelable != null ? cancelable : true;
        },
        // NOTE: this diverges from react-native in 3 significant ways:
        // * The `onPress` callback is not connected to the responder system (the native
        //  `click` event must be used but is dispatched in many scenarios where no pointers
        //   are on the screen.) Therefore, it's possible for `onPress` to be called without
        //   `onPress{Start,End}` being called first.
        // * The `onPress` callback is only be called on the first ancestor of the native
        //   `click` target that is using the PressResponder.
        // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.
        onClick: function(event) {
          var _this$_config2 = _this._config, disabled = _this$_config2.disabled, onPress = _this$_config2.onPress;
          disabled ? isButtonRole(event.currentTarget) && event.stopPropagation() : (event.stopPropagation(), _this._longPressDispatched || _this._selectionTerminated ? event.preventDefault() : onPress != null && event.altKey === false && onPress(event));
        },
        // If `onLongPress` is provided and a touch pointer is being used, prevent the
        // default context menu from opening.
        onContextMenu: function(event) {
          var _this$_config3 = _this._config, disabled = _this$_config3.disabled, onLongPress = _this$_config3.onLongPress;
          disabled ? isButtonRole(event.currentTarget) && event.stopPropagation() : onLongPress != null && _this._isPointerTouch && !event.defaultPrevented && (event.preventDefault(), event.stopPropagation());
        }
      };
    }
  }, {
    /**
    * Receives a state machine signal, performs side effects of the transition
    * and stores the new state. Validates the transition as well.
    */
    key: "_receiveSignal",
    value: function(signal, event) {
      var prevState = this._touchState, nextState = null;
      Transitions[prevState] != null && (nextState = Transitions[prevState][signal]), !(this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) && (nextState == null || nextState === ERROR ? console.error(`PressResponder: Invalid signal ${signal} for state ${prevState} on responder`) : prevState !== nextState && (this._performTransitionSideEffects(prevState, nextState, signal, event), this._touchState = nextState));
    }
  }, {
    /**
    * Performs a transition between touchable states and identify any activations
    * or deactivations (and callback invocations).
    */
    key: "_performTransitionSideEffects",
    value: function(prevState, nextState, signal, event) {
      var _this = this;
      if (isTerminalSignal(signal) && (setTimeout(function() {
        _this._isPointerTouch = false;
      }, 0), this._touchActivatePosition = null, this._cancelLongPressDelayTimeout()), isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {
        var onLongPress = this._config.onLongPress;
        onLongPress != null && event.nativeEvent.key == null && (onLongPress(event), this._longPressDispatched = true);
      }
      var isPrevActive = isActiveSignal(prevState), isNextActive = isActiveSignal(nextState);
      if (!isPrevActive && isNextActive ? this._activate(event) : isPrevActive && !isNextActive && this._deactivate(event), isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {
        var _this$_config4 = this._config, _onLongPress = _this$_config4.onLongPress, onPress = _this$_config4.onPress;
        if (onPress != null) {
          var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;
          isPressCanceledByLongPress || isNextActive || isPrevActive || (this._activate(event), this._deactivate(event));
        }
      }
      this._cancelPressDelayTimeout();
    }
  }, {
    key: "_activate",
    value: function(event) {
      var _this$_config5 = this._config, onPressChange = _this$_config5.onPressChange, onPressStart = _this$_config5.onPressStart, touch = getTouchFromResponderEvent(event);
      this._touchActivatePosition = {
        pageX: touch.pageX,
        pageY: touch.pageY
      }, onPressStart == null ? void 0 : onPressStart(event), onPressChange == null ? void 0 : onPressChange(true);
    }
  }, {
    key: "_deactivate",
    value: function(event) {
      var _this$_config6 = this._config, onPressChange = _this$_config6.onPressChange, onPressEnd = _this$_config6.onPressEnd;
      function end() {
        onPressEnd == null ? void 0 : onPressEnd(event), onPressChange == null ? void 0 : onPressChange(false);
      }
      var delayPressEnd = normalizeDelay(this._config.delayPressEnd);
      delayPressEnd > 0 ? this._pressOutDelayTimeout = setTimeout(function() {
        end();
      }, delayPressEnd) : end();
    }
  }, {
    key: "_handleLongPress",
    value: function(event) {
      (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) && this._receiveSignal(LONG_PRESS_DETECTED, event);
    }
  }, {
    key: "_cancelLongPressDelayTimeout",
    value: function() {
      this._longPressDelayTimeout != null && (clearTimeout(this._longPressDelayTimeout), this._longPressDelayTimeout = null);
    }
  }, {
    key: "_cancelPressDelayTimeout",
    value: function() {
      this._pressDelayTimeout != null && (clearTimeout(this._pressDelayTimeout), this._pressDelayTimeout = null);
    }
  }, {
    key: "_cancelPressOutDelayTimeout",
    value: function() {
      this._pressOutDelayTimeout != null && (clearTimeout(this._pressOutDelayTimeout), this._pressOutDelayTimeout = null);
    }
  }]), PressResponder2;
})();
function normalizeDelay(delay, min2, fallback) {
  return min2 === void 0 && (min2 = 0), fallback === void 0 && (fallback = 0), Math.max(min2, delay != null ? delay : fallback);
}
function getTouchFromResponderEvent(event) {
  var _event$nativeEvent = event.nativeEvent, changedTouches = _event$nativeEvent.changedTouches, touches = _event$nativeEvent.touches;
  return touches != null && touches.length > 0 ? touches[0] : changedTouches != null && changedTouches.length > 0 ? changedTouches[0] : event.nativeEvent;
}
function usePressEvents(_, config) {
  var pressResponderRef = React.useRef(null);
  pressResponderRef.current == null && (pressResponderRef.current = new PressResponder(config));
  var pressResponder = pressResponderRef.current;
  return React.useEffect(function() {
    pressResponder.configure(config);
  }, [config, pressResponder]), React.useEffect(function() {
    return function() {
      pressResponder.reset();
    };
  }, [pressResponder]), React.useDebugValue(config), pressResponder.getEventHandlers();
}
var keyName = "__reactResponderId", canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement), getBoundingClientRect = function(node) {
  if (node && node.nodeType === 1 && node.getBoundingClientRect) return node.getBoundingClientRect();
};
function getEventPath(domEvent) {
  if (domEvent.type === "selectionchange") {
    var _window_getSelection, target = (_window_getSelection = window.getSelection()) === null || _window_getSelection === void 0 ? void 0 : _window_getSelection.anchorNode;
    return composedPathFallback(target);
  }
  var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
  return path;
}
function composedPathFallback(target) {
  for (var path = []; target != null && target !== document.body; ) path.push(target), target = target.parentNode;
  return path;
}
function getResponderId(node) {
  return node != null ? node[keyName] : null;
}
function setResponderId(node, id2) {
  node != null && (node[keyName] = id2);
}
function getResponderPaths(domEvent) {
  for (var idPath = [], nodePath = [], eventPath = getEventPath(domEvent), i = 0; i < eventPath.length; i++) {
    var node = eventPath[i], id2 = getResponderId(node);
    id2 != null && (idPath.push(id2), nodePath.push(node));
  }
  return {
    idPath,
    nodePath
  };
}
function getLowestCommonAncestor(pathA, pathB) {
  var pathALength = pathA.length, pathBLength = pathB.length;
  if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]
  ) return null;
  var itemA = pathA[0], indexA = 0, itemB = pathB[0], indexB = 0;
  pathALength - pathBLength > 0 && (indexA = pathALength - pathBLength, itemA = pathA[indexA], pathALength = pathBLength), pathBLength - pathALength > 0 && (indexB = pathBLength - pathALength, itemB = pathB[indexB], pathBLength = pathALength);
  for (var depth = pathALength; depth--; ) {
    if (itemA === itemB) return itemA;
    itemA = pathA[indexA++], itemB = pathB[indexB++];
  }
  return null;
}
function hasTargetTouches(target, touches) {
  if (!touches || touches.length === 0) return false;
  for (var i = 0; i < touches.length; i++) {
    var node = touches[i].target;
    if (node != null && target.contains(node)) return true;
  }
  return false;
}
function hasValidSelection(domEvent) {
  return domEvent.type === "selectionchange" ? isSelectionValid() : domEvent.type === "select";
}
function isPrimaryPointerDown(domEvent) {
  var {
    altKey,
    button,
    buttons,
    ctrlKey,
    type
  } = domEvent, isTouch = type === "touchstart" || type === "touchmove", isPrimaryMouseDown = type === "mousedown" && (button === 0 || buttons === 1), isPrimaryMouseMove = type === "mousemove" && buttons === 1, noModifiers = altKey === false && ctrlKey === false;
  return !!(isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers);
}
function isSelectionValid() {
  var selection = window.getSelection();
  if (!selection) return false;
  var string = selection.toString(), anchorNode = selection.anchorNode, focusNode = selection.focusNode, isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
  return string.length >= 1 && string !== `
` && !!isTextNode;
}
var emptyFunction = function() {
}, emptyObject$9 = {}, emptyArray = [];
function normalizeIdentifier(identifier) {
  return identifier > 20 ? identifier % 20 : identifier;
}
function createResponderEvent(domEvent, responderTouchHistoryStore2) {
  var rect, propagationWasStopped = false, changedTouches, touches, domEventChangedTouches = domEvent.changedTouches, domEventType = domEvent.type, metaKey = domEvent.metaKey === true, shiftKey = domEvent.shiftKey === true, force = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].force) || 0, identifier = normalizeIdentifier((domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].identifier) || 0), clientX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientX) || domEvent.clientX, clientY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].clientY) || domEvent.clientY, pageX = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageX) || domEvent.pageX, pageY = (domEventChangedTouches == null ? void 0 : domEventChangedTouches[0].pageY) || domEvent.pageY, preventDefault = typeof domEvent.preventDefault == "function" ? domEvent.preventDefault.bind(domEvent) : emptyFunction, timestamp = domEvent.timeStamp;
  function normalizeTouches(touches2) {
    return Array.prototype.slice.call(touches2).map(function(touch) {
      return {
        force: touch.force,
        identifier: normalizeIdentifier(touch.identifier),
        get locationX() {
          return locationX(touch.clientX);
        },
        get locationY() {
          return locationY(touch.clientY);
        },
        pageX: touch.pageX,
        pageY: touch.pageY,
        target: touch.target,
        timestamp
      };
    });
  }
  if (domEventChangedTouches != null) changedTouches = normalizeTouches(domEventChangedTouches), touches = normalizeTouches(domEvent.touches);
  else {
    var emulatedTouches = [{
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp
    }];
    changedTouches = emulatedTouches, touches = domEventType === "mouseup" || domEventType === "dragstart" ? emptyArray : emulatedTouches;
  }
  var responderEvent = {
    bubbles: true,
    cancelable: true,
    // `currentTarget` is set before dispatch
    currentTarget: null,
    defaultPrevented: domEvent.defaultPrevented,
    dispatchConfig: emptyObject$9,
    eventPhase: domEvent.eventPhase,
    isDefaultPrevented() {
      return domEvent.defaultPrevented;
    },
    isPropagationStopped() {
      return propagationWasStopped;
    },
    isTrusted: domEvent.isTrusted,
    nativeEvent: {
      altKey: false,
      ctrlKey: false,
      metaKey,
      shiftKey,
      changedTouches,
      force,
      identifier,
      get locationX() {
        return locationX(clientX);
      },
      get locationY() {
        return locationY(clientY);
      },
      pageX,
      pageY,
      target: domEvent.target,
      timestamp,
      touches,
      type: domEventType
    },
    persist: emptyFunction,
    preventDefault,
    stopPropagation() {
      propagationWasStopped = true;
    },
    target: domEvent.target,
    timeStamp: timestamp,
    touchHistory: responderTouchHistoryStore2.touchHistory
  };
  function locationX(x) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return x - rect.left;
  }
  function locationY(y) {
    if (rect = rect || getBoundingClientRect(responderEvent.currentTarget), rect) return y - rect.top;
  }
  return responderEvent;
}
var MOUSE_DOWN = "mousedown", MOUSE_MOVE = "mousemove", MOUSE_UP = "mouseup", MOUSE_CANCEL = "dragstart", TOUCH_START = "touchstart", TOUCH_MOVE = "touchmove", TOUCH_END = "touchend", TOUCH_CANCEL = "touchcancel", SCROLL = "scroll", SELECT = "select", SELECTION_CHANGE = "selectionchange";
function isStartish(eventType) {
  return eventType === TOUCH_START || eventType === MOUSE_DOWN;
}
function isMoveish(eventType) {
  return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
}
function isEndish(eventType) {
  return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
}
function isCancelish(eventType) {
  return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
}
function isScroll(eventType) {
  return eventType === SCROLL;
}
function isSelectionChange(eventType) {
  return eventType === SELECT || eventType === SELECTION_CHANGE;
}
function _class_call_check$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class$1(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties$1(Constructor.prototype, protoProps), Constructor;
}
function _define_property$1(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var ResponderTouchHistoryStore = /* @__PURE__ */ (function() {
  function ResponderTouchHistoryStore2() {
    _class_call_check$1(this, ResponderTouchHistoryStore2), _define_property$1(this, "_touchHistory", {
      touchBank: [],
      //Array<TouchRecord>
      numberActiveTouches: 0,
      // If there is only one active touch, we remember its location. This prevents
      // us having to loop through all of the touches all the time in the most
      // common case.
      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    });
  }
  return _create_class$1(ResponderTouchHistoryStore2, [{
    key: "recordTouchTrack",
    value: function(topLevelType, nativeEvent) {
      var touchHistory = this._touchHistory;
      if (isMoveish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchMove(touch, touchHistory);
      });
      else if (isStartish(topLevelType)) nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchStart(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1 && (touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier);
      else if (isEndish(topLevelType) && (nativeEvent.changedTouches.forEach(function(touch) {
        return recordTouchEnd(touch, touchHistory);
      }), touchHistory.numberActiveTouches = nativeEvent.touches.length, touchHistory.numberActiveTouches === 1)) {
        for (var {
          touchBank
        } = touchHistory, i = 0; i < touchBank.length; i++) {
          var touchTrackToCheck = touchBank[i];
          if (touchTrackToCheck == null ? void 0 : touchTrackToCheck.touchActive) {
            touchHistory.indexOfSingleActiveTouch = i;
            break;
          }
        }
      }
    }
  }, {
    key: "touchHistory",
    get: function() {
      return this._touchHistory;
    }
  }]), ResponderTouchHistoryStore2;
})(), MAX_TOUCH_BANK = 20;
function timestampForTouch(touch) {
  return touch.timeStamp || touch.timestamp;
}
function createTouchRecord(touch) {
  return {
    touchActive: true,
    startPageX: touch.pageX,
    startPageY: touch.pageY,
    startTimeStamp: timestampForTouch(touch),
    currentPageX: touch.pageX,
    currentPageY: touch.pageY,
    currentTimeStamp: timestampForTouch(touch),
    previousPageX: touch.pageX,
    previousPageY: touch.pageY,
    previousTimeStamp: timestampForTouch(touch)
  };
}
function resetTouchRecord(touchRecord, touch) {
  touchRecord.touchActive = true, touchRecord.startPageX = touch.pageX, touchRecord.startPageY = touch.pageY, touchRecord.startTimeStamp = timestampForTouch(touch), touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchRecord.previousPageX = touch.pageX, touchRecord.previousPageY = touch.pageY, touchRecord.previousTimeStamp = timestampForTouch(touch);
}
function getTouchIdentifier(param) {
  var {
    identifier
  } = param;
  return identifier == null && console.error("Touch object is missing identifier."), identifier;
}
function recordTouchStart(touch, touchHistory) {
  var identifier = getTouchIdentifier(touch), touchRecord = touchHistory.touchBank[identifier];
  touchRecord ? resetTouchRecord(touchRecord, touch) : touchHistory.touchBank[identifier] = createTouchRecord(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
}
function recordTouchMove(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = true, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch move without a touch start.
`, `Touch Move: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function recordTouchEnd(touch, touchHistory) {
  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
  touchRecord ? (touchRecord.touchActive = false, touchRecord.previousPageX = touchRecord.currentPageX, touchRecord.previousPageY = touchRecord.currentPageY, touchRecord.previousTimeStamp = touchRecord.currentTimeStamp, touchRecord.currentPageX = touch.pageX, touchRecord.currentPageY = touch.pageY, touchRecord.currentTimeStamp = timestampForTouch(touch), touchHistory.mostRecentTimeStamp = timestampForTouch(touch)) : console.warn(`Cannot record touch end without a touch start.
`, `Touch End: ${printTouch(touch)}
`, `Touch Bank: ${printTouchBank(touchHistory)}`);
}
function printTouch(touch) {
  return JSON.stringify({
    identifier: touch.identifier,
    pageX: touch.pageX,
    pageY: touch.pageY,
    timestamp: timestampForTouch(touch)
  });
}
function printTouchBank(touchHistory) {
  var {
    touchBank
  } = touchHistory, printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
  return touchBank.length > MAX_TOUCH_BANK && (printed += ` (original size: ${touchBank.length})`), printed;
}
var emptyObject$8 = {}, startRegistration = ["onStartShouldSetResponderCapture", "onStartShouldSetResponder", {
  bubbles: true
}], moveRegistration = ["onMoveShouldSetResponderCapture", "onMoveShouldSetResponder", {
  bubbles: true
}], scrollRegistration = ["onScrollShouldSetResponderCapture", "onScrollShouldSetResponder", {
  bubbles: false
}], shouldSetResponderEvents = {
  touchstart: startRegistration,
  mousedown: startRegistration,
  touchmove: moveRegistration,
  mousemove: moveRegistration,
  scroll: scrollRegistration
}, emptyResponder = {
  id: null,
  idPath: null,
  node: null
}, responderListenersMap = /* @__PURE__ */ new Map(), isEmulatingMouseEvents = false, trackedTouchCount = 0, currentResponder = {
  id: null,
  node: null,
  idPath: null
}, responderTouchHistoryStore = new ResponderTouchHistoryStore();
function changeCurrentResponder(responder) {
  currentResponder = responder;
}
function getResponderConfig(id2) {
  var config = responderListenersMap.get(id2);
  return config != null ? config : emptyObject$8;
}
function eventListener(domEvent) {
  var eventType = domEvent.type, eventTarget = domEvent.target;
  if (eventType === "touchstart" && (isEmulatingMouseEvents = true), (eventType === "touchmove" || trackedTouchCount > 1) && (isEmulatingMouseEvents = false), // Ignore browser emulated mouse events
  !(eventType === "mousedown" && isEmulatingMouseEvents || eventType === "mousemove" && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first
  eventType === "mousemove" && trackedTouchCount < 1)) {
    if (isEmulatingMouseEvents && eventType === "mouseup") {
      trackedTouchCount === 0 && (isEmulatingMouseEvents = false);
      return;
    }
    var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent), isMoveEvent = isMoveish(eventType), isEndEvent = isEndish(eventType), isScrollEvent = isScroll(eventType), isSelectionChangeEvent = isSelectionChange(eventType), responderEvent = createResponderEvent(domEvent, responderTouchHistoryStore);
    (isStartEvent || isMoveEvent || isEndEvent) && (domEvent.touches ? trackedTouchCount = domEvent.touches.length : isStartEvent ? trackedTouchCount = 1 : isEndEvent && (trackedTouchCount = 0), responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent));
    var eventPaths = getResponderPaths(domEvent), wasNegotiated = false, wantsResponder;
    if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
      var currentResponderIdPath = currentResponder.idPath, eventIdPath = eventPaths.idPath;
      if (currentResponderIdPath != null && eventIdPath != null) {
        var lowestCommonAncestor = getLowestCommonAncestor(currentResponderIdPath, eventIdPath);
        if (lowestCommonAncestor != null) {
          var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor), index2 = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
          eventPaths = {
            idPath: eventIdPath.slice(index2),
            nodePath: eventPaths.nodePath.slice(index2)
          };
        } else eventPaths = null;
      }
      eventPaths != null && (wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent), wantsResponder != null && (attemptTransfer(responderEvent, wantsResponder), wasNegotiated = true));
    }
    if (currentResponder.id != null && currentResponder.node != null) {
      var {
        id: id2,
        node
      } = currentResponder, {
        onResponderStart,
        onResponderMove,
        onResponderEnd,
        onResponderRelease,
        onResponderTerminate,
        onResponderTerminationRequest
      } = getResponderConfig(id2);
      if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node, isStartEvent) onResponderStart != null && (responderEvent.dispatchConfig.registrationName = "onResponderStart", onResponderStart(responderEvent));
      else if (isMoveEvent) onResponderMove != null && (responderEvent.dispatchConfig.registrationName = "onResponderMove", onResponderMove(responderEvent));
      else {
        var isTerminateEvent = isCancelish(eventType) || // native context menu
        eventType === "contextmenu" || // window blur
        eventType === "blur" && eventTarget === window || // responder (or ancestors) blur
        eventType === "blur" && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer
        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)
        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node
        isSelectionChangeEvent && hasValidSelection(domEvent), isReleaseEvent = isEndEvent && !isTerminateEvent && !hasTargetTouches(node, domEvent.touches);
        if (isEndEvent && onResponderEnd != null && (responderEvent.dispatchConfig.registrationName = "onResponderEnd", onResponderEnd(responderEvent)), isReleaseEvent && (onResponderRelease != null && (responderEvent.dispatchConfig.registrationName = "onResponderRelease", onResponderRelease(responderEvent)), changeCurrentResponder(emptyResponder)), isTerminateEvent) {
          var shouldTerminate = true;
          (eventType === "contextmenu" || eventType === "scroll" || eventType === "selectionchange") && (wasNegotiated ? shouldTerminate = false : onResponderTerminationRequest != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (shouldTerminate = false))), shouldTerminate && (onResponderTerminate != null && (responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), changeCurrentResponder(emptyResponder), isEmulatingMouseEvents = false, trackedTouchCount = 0);
        }
      }
    }
  }
}
function findWantsResponder(eventPaths, domEvent, responderEvent) {
  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type];
  if (shouldSetCallbacks != null) {
    for (var {
      idPath,
      nodePath
    } = eventPaths, shouldSetCallbackCaptureName = shouldSetCallbacks[0], shouldSetCallbackBubbleName = shouldSetCallbacks[1], {
      bubbles
    } = shouldSetCallbacks[2], check = function(id3, node3, callbackName) {
      var config = getResponderConfig(id3), shouldSetCallback = config[callbackName];
      if (shouldSetCallback != null && (responderEvent.currentTarget = node3, shouldSetCallback(responderEvent) === true)) {
        var prunedIdPath = idPath.slice(idPath.indexOf(id3));
        return {
          id: id3,
          node: node3,
          idPath: prunedIdPath
        };
      }
    }, i = idPath.length - 1; i >= 0; i--) {
      var id2 = idPath[i], node = nodePath[i], result = check(id2, node, shouldSetCallbackCaptureName);
      if (result != null) return result;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    if (bubbles) for (var i1 = 0; i1 < idPath.length; i1++) {
      var id1 = idPath[i1], node1 = nodePath[i1], result1 = check(id1, node1, shouldSetCallbackBubbleName);
      if (result1 != null) return result1;
      if (responderEvent.isPropagationStopped() === true) return;
    }
    else {
      var id22 = idPath[0], node2 = nodePath[0], target = domEvent.target;
      if (target === node2) return check(id22, node2, shouldSetCallbackBubbleName);
    }
  }
}
function attemptTransfer(responderEvent, wantsResponder) {
  var {
    id: currentId,
    node: currentNode
  } = currentResponder, {
    id: id2,
    node
  } = wantsResponder, {
    onResponderGrant,
    onResponderReject
  } = getResponderConfig(id2);
  if (responderEvent.bubbles = false, responderEvent.cancelable = false, responderEvent.currentTarget = node, currentId == null) onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder);
  else {
    var {
      onResponderTerminate,
      onResponderTerminationRequest
    } = getResponderConfig(currentId), allowTransfer = true;
    onResponderTerminationRequest != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminationRequest", onResponderTerminationRequest(responderEvent) === false && (allowTransfer = false)), allowTransfer ? (onResponderTerminate != null && (responderEvent.currentTarget = currentNode, responderEvent.dispatchConfig.registrationName = "onResponderTerminate", onResponderTerminate(responderEvent)), onResponderGrant != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderGrant", onResponderGrant(responderEvent)), changeCurrentResponder(wantsResponder)) : onResponderReject != null && (responderEvent.currentTarget = node, responderEvent.dispatchConfig.registrationName = "onResponderReject", onResponderReject(responderEvent));
  }
}
var documentEventsCapturePhase = ["blur", "scroll"], documentEventsBubblePhase = [
  // mouse
  "mousedown",
  "mousemove",
  "mouseup",
  "dragstart",
  // touch
  "touchstart",
  "touchmove",
  "touchend",
  "touchcancel",
  // other
  "contextmenu",
  "select",
  "selectionchange"
], isTamaguiResponderActive = Symbol();
function attachListeners() {
  canUseDOM && !window[isTamaguiResponderActive] && (window.addEventListener("blur", eventListener), documentEventsBubblePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener);
  }), documentEventsCapturePhase.forEach(function(eventType) {
    document.addEventListener(eventType, eventListener, true);
  }), window[isTamaguiResponderActive] = true);
}
function addNode(id2, node, config) {
  setResponderId(node, id2), responderListenersMap.set(id2, config);
}
function removeNode(id2) {
  currentResponder.id === id2 && terminateResponder(), responderListenersMap.has(id2) && responderListenersMap.delete(id2);
}
function terminateResponder() {
  var {
    id: id2,
    node
  } = currentResponder;
  if (id2 != null && node != null) {
    var {
      onResponderTerminate
    } = getResponderConfig(id2);
    if (onResponderTerminate != null) {
      var event = createResponderEvent({}, responderTouchHistoryStore);
      event.currentTarget = node, onResponderTerminate(event);
    }
    changeCurrentResponder(emptyResponder);
  }
  isEmulatingMouseEvents = false, trackedTouchCount = 0;
}
var emptyObject$7 = {}, Attached = /* @__PURE__ */ new WeakMap(), Ids = /* @__PURE__ */ new WeakMap();
function useResponderEvents(hostRef) {
  var configIn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : emptyObject$7, _hostRef_current, config = getResponderConfigIfDefined(configIn), node = (hostRef == null || (_hostRef_current = hostRef.current) === null || _hostRef_current === void 0 ? void 0 : _hostRef_current.host) || (hostRef == null ? void 0 : hostRef.current);
  React__namespace.useEffect(function() {
    if (config !== emptyObject$7) {
      attachListeners(), Ids.has(hostRef) || Ids.set(hostRef, `${Math.random()}`);
      var id2 = Ids.get(hostRef);
      return addNode(id2, node, config), Attached.set(hostRef, true), function() {
        removeNode(node), Attached.set(hostRef, false);
      };
    }
  }, [config, hostRef]);
}
function getResponderConfigIfDefined(param) {
  var {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } = param;
  return onMoveShouldSetResponder || onMoveShouldSetResponderCapture || onResponderEnd || onResponderGrant || onResponderMove || onResponderReject || onResponderRelease || onResponderStart || onResponderTerminate || onResponderTerminationRequest || onScrollShouldSetResponder || onScrollShouldSetResponderCapture || onSelectionChangeShouldSetResponder || onSelectionChangeShouldSetResponderCapture || onStartShouldSetResponder || onStartShouldSetResponderCapture ? {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } : emptyObject$7;
}
const isDisabled$1 = (props) => props.disabled || Array.isArray(props.accessibilityStates) && props.accessibilityStates.indexOf("disabled") > -1;
const accessibilityRoleToWebRole = {
  adjustable: "slider",
  button: "button",
  header: "heading",
  image: "img",
  imagebutton: null,
  keyboardkey: null,
  label: null,
  link: "link",
  none: "presentation",
  search: "search",
  summary: "region",
  text: null
}, propsToAriaRole = ({
  accessibilityRole
}) => {
  if (accessibilityRole) {
    const inferredRole = accessibilityRoleToWebRole[accessibilityRole];
    if (inferredRole !== null) return inferredRole || accessibilityRole;
  }
};
const roleComponents = {
  article: "article",
  banner: "header",
  blockquote: "blockquote",
  code: "code",
  complementary: "aside",
  contentinfo: "footer",
  deletion: "del",
  emphasis: "em",
  figure: "figure",
  insertion: "ins",
  form: "form",
  list: "ul",
  listitem: "li",
  main: "main",
  navigation: "nav",
  region: "section",
  strong: "strong"
}, emptyObject$6 = {}, propsToAccessibilityComponent = (props = emptyObject$6) => {
  if (props.accessibilityRole === "label") return "label";
  const role = propsToAriaRole(props);
  if (role) {
    if (role === "heading") {
      const level = props.accessibilityLevel || props["aria-level"];
      return level != null ? `h${level}` : "h1";
    }
    return roleComponents[role];
  }
};
const AccessibilityUtil = {
  isDisabled: isDisabled$1,
  propsToAccessibilityComponent,
  propsToAriaRole
};
var pseudoDescriptorsBase = {
  // order of keys here important! in priority order
  hoverStyle: {
    name: "hover",
    priority: 2
  },
  pressStyle: {
    name: "active",
    stateKey: "press",
    priority: 3
  },
  focusVisibleStyle: {
    name: "focus-visible",
    priority: 4,
    stateKey: "focusVisible"
  },
  focusStyle: {
    name: "focus",
    priority: 4
  },
  focusWithinStyle: {
    name: "focus-within",
    priority: 4,
    stateKey: "focusWithin"
  },
  disabledStyle: {
    name: "disabled",
    priority: 5,
    stateKey: "disabled"
  }
}, pseudoPriorities = {
  hover: pseudoDescriptorsBase.hoverStyle.priority,
  press: pseudoDescriptorsBase.pressStyle.priority,
  focus: pseudoDescriptorsBase.focusStyle.priority,
  focusVisible: pseudoDescriptorsBase.focusVisibleStyle.priority,
  focusWithin: pseudoDescriptorsBase.focusWithinStyle.priority,
  disabled: pseudoDescriptorsBase.disabledStyle.priority
}, pseudoDescriptors = __spreadProps(__spreadValues({}, pseudoDescriptorsBase), {
  enterStyle: {
    name: "enter",
    selector: ".t_unmounted",
    priority: 4
  },
  exitStyle: {
    name: "exit",
    priority: 5
  }
}), defaultMediaImportance = Object.keys(pseudoDescriptors).length;
function _type_of$d(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var mergeProps = function(defaultProps2, props) {
  var out = {};
  for (var key in defaultProps2) key in props || (out[key] = defaultProps2[key]);
  for (var key1 in props) mergeProp(out, defaultProps2, props, key1);
  return out;
}, mergeComponentProps = function(defaultProps2, contextProps, props) {
  var overriddenContext = null;
  if (!defaultProps2 && !contextProps) return [props, overriddenContext];
  if (defaultProps2 && !contextProps) return [mergeProps(defaultProps2, props), overriddenContext];
  var out = {};
  for (var key in defaultProps2) key in props || (out[key] = defaultProps2[key]);
  for (var key1 in contextProps) if (!(key1 in props)) {
    var contextValue = contextProps[key1];
    contextValue !== void 0 && (out[key1] = contextValue);
  }
  for (var key2 in props) mergeProp(out, defaultProps2, props, key2), contextProps && key2 in contextProps && (overriddenContext || (overriddenContext = {}), overriddenContext[key2] = props[key2]);
  return [out, overriddenContext];
};
function mergeProp(out, defaultProps2, props, key) {
  var val = props[key];
  if (defaultProps2 && key in defaultProps2 && (key in pseudoDescriptors || key[0] === "$") && val && (typeof val > "u" ? "undefined" : _type_of$d(val)) === "object") {
    var defaultVal = defaultProps2[key];
    defaultVal && (typeof defaultVal > "u" ? "undefined" : _type_of$d(defaultVal)) === "object" && (val = mergeProps(defaultVal, val));
  }
  out[key] = val;
}
function _type_of$c(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function objectIdentityKey(obj) {
  var k = "";
  for (var key in obj) {
    k += key;
    var arg = obj[key], type = typeof arg > "u" ? "undefined" : _type_of$c(arg);
    if (!arg || type !== "object" && type !== "function") k += type + arg;
    else if (cache$6.has(arg)) k += cache$6.get(arg);
    else {
      var v = Math.random();
      cache$6.set(arg, v), k += v;
    }
  }
  return k;
}
var cache$6 = /* @__PURE__ */ new WeakMap();
var createReactContext = React["createContext"];
function createStyledContext(defaultValues) {
  var namespace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", OGContext = createReactContext(defaultValues), OGProvider = OGContext.Provider, Context = OGContext, scopedContexts = /* @__PURE__ */ new Map(), LastScopeInNamespace = createReactContext(namespace);
  function getOrCreateScopedContext(scope) {
    var ScopedContext = scopedContexts.get(scope);
    return ScopedContext || (ScopedContext = createReactContext(defaultValues), scopedContexts.set(scope, ScopedContext)), ScopedContext;
  }
  var getNamespacedScope = function(scope) {
    return namespace ? `${namespace}--${scope}` : scope;
  }, Provider = function(param) {
    var _a = param, {
      children,
      scope: scopeIn,
      __disableMergeDefaultValues: __disableMergeDefaultValues
    } = _a, values = __objRest(_a, [
      "children",
      "scope",
      // performance: avoid creating objects
      "__disableMergeDefaultValues"
    ]), scope = getNamespacedScope(scopeIn), next = React.useMemo(function() {
      return __disableMergeDefaultValues ? values : mergeProps(defaultValues, values);
    }, [objectIdentityKey(values)]), ScopedProvider = OGProvider;
    return scope && (ScopedProvider = getOrCreateScopedContext(scope).Provider), /* @__PURE__ */ jsxRuntimeExports.jsx(LastScopeInNamespace.Provider, {
      value: scope,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScopedProvider, {
        value: next,
        children
      })
    });
  }, useStyledContext = function() {
    var scopeIn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", lastScopeInNamespace = React.useContext(LastScopeInNamespace), scope = namespace ? scopeIn ? getNamespacedScope(scopeIn) : lastScopeInNamespace : scopeIn, context2 = scope ? getOrCreateScopedContext(scope) : OGContext, value = React.useContext(context2);
    return value;
  };
  return Context.Provider = Provider, Context.props = defaultValues, Context.context = OGContext, Context.useStyledContext = useStyledContext, Context;
}
var ComponentContext = createStyledContext({
  disableSSR: void 0,
  inText: false,
  language: null,
  animationDriver: null,
  setParentFocusState: null
}), useConfiguration = function() {
  return React.useContext(ComponentContext);
};
var GroupContext = /* @__PURE__ */ React.createContext(null);
var stackDefaultStyles = {};
({
  position: process.env.TAMAGUI_POSITION_STATIC === "1" ? "static" : "relative"
});
var MISSING_THEME_MESSAGE = "Missing theme.";
var conf$1, getConfigFromGlobalOrLocal = function() {
  return conf$1 || (globalThis.__tamaguiConfig ? globalThis.__tamaguiConfig : null);
}, getSetting = function(key) {
  var config = getConfigFromGlobalOrLocal();
  var _config_settings_key;
  return (_config_settings_key = config.settings[key]) !== null && _config_settings_key !== void 0 ? _config_settings_key : (
    // @ts-expect-error
    config[key]
  );
}, setConfig = function(next) {
  conf$1 = next, globalThis.__tamaguiConfig = next;
}, setConfigFont = function(name, font, fontParsed) {
  var config = getConfigFromGlobalOrLocal();
  config.fonts[name] = font, config.fontsParsed[`$${name}`] = fontParsed;
}, getConfig = function() {
  var config = getConfigFromGlobalOrLocal();
  if (!config) throw new Error("Missing tamagui config, you either have a duplicate config, or haven't set it up. Be sure createTamagui is called before rendering. Also, make sure all of your tamagui dependencies are on the same version (`tamagui`, `@tamagui/package-name`, etc.) not just in your package.json, but in your lockfile.");
  return config;
}, getConfigMaybe = function() {
  return getConfigFromGlobalOrLocal();
}, tokensMerged;
function setTokens(_) {
  tokensMerged = _;
}
var getTokens = function() {
  var {
    prefixed
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (
    /**
    * Force either with $ or without $ prefix
    */
    {}
  ), config = getConfigFromGlobalOrLocal();
  var {
    tokens,
    tokensParsed
  } = config;
  return prefixed === false ? tokens : prefixed === true ? tokensParsed : tokensMerged;
}, getTokenObject = function(value, group) {
  var _tokensMerged_group, _tokensMerged_, config = getConfigFromGlobalOrLocal(), _config_specificTokens_value;
  return (_config_specificTokens_value = config.specificTokens[value]) !== null && _config_specificTokens_value !== void 0 ? _config_specificTokens_value : group ? (_tokensMerged_group = tokensMerged[group]) === null || _tokensMerged_group === void 0 ? void 0 : _tokensMerged_group[value] : (_tokensMerged_ = tokensMerged[Object.keys(tokensMerged).find(function(cat) {
    return tokensMerged[cat][value];
  }) || ""]) === null || _tokensMerged_ === void 0 ? void 0 : _tokensMerged_[value];
}, getToken = function(value, group) {
  var useVariable = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : isWeb, token = getTokenObject(value, group);
  return useVariable ? token == null ? void 0 : token.variable : token == null ? void 0 : token.val;
}, getTokenValue = function(value, group) {
  if (!(value === "unset" || value === "auto")) return getToken(value, group, false);
}, getThemes = function() {
  return getConfigFromGlobalOrLocal().themes;
}, configListeners = /* @__PURE__ */ new Set(), onConfiguredOnce = function(cb) {
  var config = getConfigFromGlobalOrLocal();
  config ? cb(config) : configListeners.add(cb);
}, updateConfig = function(key, value) {
  var config = getConfigFromGlobalOrLocal();
  Object.assign(config[key], value);
}, getFont = function(name) {
  var _Object_entries_find, conf2 = getConfig(), _conf_fontsParsed_name;
  return (_conf_fontsParsed_name = conf2.fontsParsed[name]) !== null && _conf_fontsParsed_name !== void 0 ? _conf_fontsParsed_name : (_Object_entries_find = Object.entries(conf2.fontsParsed).find(function(param) {
    var [k] = param, _conf_fontsParsed_k_family, _conf_fontsParsed_k;
    return ((_conf_fontsParsed_k = conf2.fontsParsed[k]) === null || _conf_fontsParsed_k === void 0 || (_conf_fontsParsed_k_family = _conf_fontsParsed_k.family) === null || _conf_fontsParsed_k_family === void 0 ? void 0 : _conf_fontsParsed_k_family.val) === name;
  })) === null || _Object_entries_find === void 0 ? void 0 : _Object_entries_find[1];
};
function setupDev(conf2) {
}
var cache$5 = /* @__PURE__ */ new Map(), cacheSize = 0, simpleHash = function(strIn) {
  var hashMin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10;
  if (cache$5.has(strIn)) return cache$5.get(strIn);
  var str = strIn;
  str[0] === "v" && str.startsWith("var(") && (str = str.slice(6, str.length - 1));
  for (var hash = 0, valids = "", added = 0, len = str.length, i = 0; i < len; i++) {
    if (hashMin !== "strict" && added <= hashMin) {
      var char = str.charCodeAt(i);
      if (char === 46) {
        valids += "--";
        continue;
      }
      if (isValidCSSCharCode(char)) {
        added++, valids += str[i];
        continue;
      }
    }
    hash = hashChar(hash, str[i]);
  }
  var res = valids + (hash ? Math.abs(hash) : "");
  return cacheSize > 1e4 && (cache$5.clear(), cacheSize = 0), cache$5.set(strIn, res), cacheSize++, res;
}, hashChar = function(hash, c) {
  return Math.imul(31, hash) + c.charCodeAt(0) | 0;
};
function isValidCSSCharCode(code) {
  return (
    // A-Z
    code >= 65 && code <= 90 || // a-z
    code >= 97 && code <= 122 || // _
    code === 95 || // -
    code === 45 || // 0-9
    code >= 48 && code <= 57
  );
}
function clamp$1(value, param) {
  var [min2, max2] = param;
  return Math.min(max2, Math.max(min2, value));
}
function _type_of$b(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function composeEventHandlers(og, next) {
  var {
    checkDefaultPrevented = true
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return !og || !next ? next || og || void 0 : function(event) {
    if (og == null ? void 0 : og(event), !event || !(checkDefaultPrevented && (typeof event > "u" ? "undefined" : _type_of$b(event)) === "object" && "defaultPrevented" in event) || // @ts-ignore
    "defaultPrevented" in event && !event.defaultPrevented) return next == null ? void 0 : next(event);
  };
}
var StyleObjectProperty = 0, StyleObjectValue = 1, StyleObjectIdentifier = 2, StyleObjectPseudo = 3, StyleObjectRules = 4;
var ALL_PLATFORMS = ["web", "android", "ios"];
function shouldRenderNativePlatform(nativeProp) {
  if (!nativeProp) return null;
  var userRequestedPlatforms = resolvePlatformNames(nativeProp), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = ALL_PLATFORMS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var platform2 = _step.value;
      if (platform2 === currentPlatform && userRequestedPlatforms.has(platform2)) return platform2;
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return null;
}
function resolvePlatformNames(nativeProp) {
  var platforms2 = nativeProp === true ? (
    // all native platforms
    ALL_PLATFORMS
  ) : nativeProp === false ? (
    // no native platform
    []
  ) : Array.isArray(nativeProp) ? nativeProp : [nativeProp], set = new Set(platforms2);
  return set.has("mobile") && (set.add("android"), set.add("ios"), set.delete("mobile")), set;
}
var textColors = {
  color: true,
  textDecorationColor: true,
  textShadowColor: true
}, tokenCategories = {
  radius: {
    borderRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    // logical
    borderStartStartRadius: true,
    borderStartEndRadius: true,
    borderEndStartRadius: true,
    borderEndEndRadius: true
  },
  size: {
    width: true,
    height: true,
    minWidth: true,
    minHeight: true,
    maxWidth: true,
    maxHeight: true,
    blockSize: true,
    minBlockSize: true,
    maxBlockSize: true,
    inlineSize: true,
    minInlineSize: true,
    maxInlineSize: true
  },
  zIndex: {
    zIndex: true
  },
  color: __spreadValues({
    backgroundColor: true,
    borderColor: true,
    borderBlockStartColor: true,
    borderBlockEndColor: true,
    borderBlockColor: true,
    borderBottomColor: true,
    borderInlineColor: true,
    borderInlineStartColor: true,
    borderInlineEndColor: true,
    borderTopColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderEndColor: true,
    borderStartColor: true,
    shadowColor: true
  }, textColors)
}, stylePropsUnitless = {
  WebkitLineClamp: true,
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexOrder: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  fontWeight: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowGap: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnGap: true,
  gridColumnStart: true,
  gridTemplateColumns: true,
  gridTemplateAreas: true,
  lineClamp: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  scaleZ: true,
  shadowOpacity: true
}, stylePropsTransform = {
  x: true,
  y: true,
  scale: true,
  perspective: true,
  scaleX: true,
  scaleY: true,
  skewX: true,
  skewY: true,
  matrix: true,
  rotate: true,
  rotateY: true,
  rotateX: true,
  rotateZ: true
}, stylePropsView = __spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
  backfaceVisibility: true,
  borderBottomEndRadius: true,
  borderBottomStartRadius: true,
  borderBottomWidth: true,
  borderLeftWidth: true,
  borderRightWidth: true,
  borderBlockWidth: true,
  borderBlockEndWidth: true,
  borderBlockStartWidth: true,
  borderInlineWidth: true,
  borderInlineEndWidth: true,
  borderInlineStartWidth: true,
  borderStyle: true,
  borderBlockStyle: true,
  borderBlockEndStyle: true,
  borderBlockStartStyle: true,
  borderInlineStyle: true,
  borderInlineEndStyle: true,
  borderInlineStartStyle: true,
  borderTopEndRadius: true,
  borderTopStartRadius: true,
  borderTopWidth: true,
  borderWidth: true,
  transform: true,
  transformOrigin: true,
  alignContent: true,
  alignItems: true,
  alignSelf: true,
  borderEndWidth: true,
  borderStartWidth: true,
  bottom: true,
  display: true,
  end: true,
  flexBasis: true,
  flexDirection: true,
  flexWrap: true,
  gap: true,
  columnGap: true,
  rowGap: true,
  justifyContent: true,
  left: true,
  margin: true,
  marginBlock: true,
  marginBlockEnd: true,
  marginBlockStart: true,
  marginInline: true,
  marginInlineStart: true,
  marginInlineEnd: true,
  marginBottom: true,
  marginEnd: true,
  marginHorizontal: true,
  marginLeft: true,
  marginRight: true,
  marginStart: true,
  marginTop: true,
  marginVertical: true,
  overflow: true,
  padding: true,
  paddingBottom: true,
  paddingInline: true,
  paddingBlock: true,
  paddingBlockStart: true,
  paddingInlineEnd: true,
  paddingInlineStart: true,
  paddingEnd: true,
  paddingHorizontal: true,
  paddingLeft: true,
  paddingRight: true,
  paddingStart: true,
  paddingTop: true,
  paddingVertical: true,
  position: true,
  right: true,
  start: true,
  top: true,
  inset: true,
  insetBlock: true,
  insetBlockEnd: true,
  insetBlockStart: true,
  insetInline: true,
  insetInlineEnd: true,
  insetInlineStart: true,
  direction: true,
  shadowOffset: true,
  shadowRadius: true
}, tokenCategories.color), tokenCategories.radius), tokenCategories.size), tokenCategories.radius), stylePropsTransform), stylePropsUnitless), {
  boxShadow: true,
  filter: true
}), !process.env.REACT_NATIVE_PRE_77 && {
  boxSizing: true,
  mixBlendMode: true,
  outlineColor: true,
  outlineSpread: true,
  outlineStyle: true,
  outlineWidth: true
}), isAndroid ? {
  elevationAndroid: true
} : {}), stylePropsFont = {
  fontFamily: true,
  fontSize: true,
  fontStyle: true,
  fontWeight: true,
  fontVariant: true,
  letterSpacing: true,
  lineHeight: true,
  textTransform: true
}, stylePropsTextOnly = __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, stylePropsFont), {
  textAlign: true,
  textDecorationLine: true,
  textDecorationStyle: true
}), textColors), {
  textShadowOffset: true,
  textShadowRadius: true,
  userSelect: true,
  selectable: true,
  verticalAlign: true
}), stylePropsText = __spreadValues(__spreadValues({}, stylePropsView), stylePropsTextOnly), stylePropsAll = stylePropsText, validPseudoKeys = {
  enterStyle: true,
  exitStyle: true,
  hoverStyle: true,
  pressStyle: true,
  focusStyle: true,
  disabledStyle: true,
  focusWithinStyle: true
}, validStyles = stylePropsView;
function _type_of$a(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var Decorated = Symbol(), withStaticProperties = function(component, staticProps) {
  var next = (function() {
    if (component[Decorated]) {
      var _ = /* @__PURE__ */ React.forwardRef(function(props, ref) {
        return /* @__PURE__ */ React.createElement(component, __spreadProps(__spreadValues({}, props), {
          ref
        }));
      });
      for (var key in component) {
        var v = component[key];
        _[key] = v && (typeof v > "u" ? "undefined" : _type_of$a(v)) === "object" ? __spreadValues({}, v) : v;
      }
    }
    return component;
  })();
  return Object.assign(next, staticProps), next[Decorated] = true, next;
};
function _type_of$9(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function constructCSSVariableName(name) {
  return `var(--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${name})`;
}
var createVariable = function(props) {
  var skipHash = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (!skipHash && isVariable(props)) return props;
  var {
    key,
    name,
    val
  } = props;
  return {
    isVar: true,
    key,
    name: skipHash ? name : simpleHash(name, 40),
    val,
    variable: ""
  };
};
function variableToString(vrble) {
  return isVariable(vrble) ? `${vrble.val}` : `${vrble || ""}`;
}
function isVariable(v) {
  return v && (typeof v > "u" ? "undefined" : _type_of$9(v)) === "object" && "isVar" in v;
}
function getVariable(nameOrVariable) {
  var group = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "size", _tokens_group;
  if (nameOrVariable == null ? void 0 : nameOrVariable.dynamic) return nameOrVariable;
  if (setDidGetVariableValue(true), isVariable(nameOrVariable)) return variableToString(nameOrVariable);
  var tokens = getConfig().tokensParsed, _tokens_group_nameOrVariable;
  return variableToString((_tokens_group_nameOrVariable = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[nameOrVariable]) !== null && _tokens_group_nameOrVariable !== void 0 ? _tokens_group_nameOrVariable : nameOrVariable);
}
var accessed = false, setDidGetVariableValue = function(val) {
  return accessed = val;
}, didGetVariableValue = function() {
  return accessed;
};
function getVariableValue(v, group) {
  if (isVariable(v)) return setDidGetVariableValue(true), v.val;
  if (group) {
    var _tokens_group, tokens = getConfig().tokensParsed, token = (_tokens_group = tokens[group]) === null || _tokens_group === void 0 ? void 0 : _tokens_group[v];
    if (token) return setDidGetVariableValue(true), token.val;
  }
  return v;
}
function getVariableName(v) {
  return isVariable(v) ? v.name : v;
}
var createCSSVariable = function(nameProp) {
  var includeVar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var name = simpleHash(nameProp, 60);
  return includeVar ? constructCSSVariableName(name) : name;
};
function getOppositeScheme(scheme) {
  return scheme === "dark" ? "light" : "dark";
}
function getDynamicVal(param) {
  var {
    scheme,
    val,
    oppositeVal
  } = param, oppositeScheme = getOppositeScheme(scheme);
  return {
    dynamic: {
      [scheme]: val,
      [oppositeScheme]: oppositeVal
    }
  };
}
function extractValueFromDynamic(val, scheme) {
  return (val == null ? void 0 : val.dynamic) ? val.dynamic[scheme] : val;
}
var ThemeStateContext = React.createContext(""), allListeners = /* @__PURE__ */ new Map(), listenersByParent = {}, HasRenderedOnce = /* @__PURE__ */ new WeakMap(), HadTheme = /* @__PURE__ */ new WeakMap(), PendingUpdate = /* @__PURE__ */ new Map(), states = /* @__PURE__ */ new Map(), localStates = /* @__PURE__ */ new Map(), shouldForce = false, forceUpdateThemes = function() {
  shouldForce = true, allListeners.forEach(function(cb) {
    return cb();
  });
}, getThemeState = function(id2) {
  return states.get(id2);
}, themes = null, rootThemeState = null, getRootThemeState = function() {
  return rootThemeState;
}, useThemeState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = arguments.length > 2 ? arguments[2] : void 0, {
    disable
  } = props, parentId = React.useContext(ThemeStateContext);
  if (!parentId && !isRoot) throw new Error(MISSING_THEME_MESSAGE);
  if (disable) return states.get(parentId) || {
    id: "",
    name: "light",
    theme: getConfig().themes.light,
    inverses: 0
  };
  var id2 = React.useId(), subscribe2 = React.useCallback(function(cb) {
    var _listenersByParent, _parentId;
    return (_listenersByParent = listenersByParent)[_parentId = parentId] || (_listenersByParent[_parentId] = /* @__PURE__ */ new Set()), listenersByParent[parentId].add(id2), allListeners.set(id2, function() {
      PendingUpdate.set(id2, shouldForce ? "force" : true), cb();
    }), function() {
      allListeners.delete(id2), listenersByParent[parentId].delete(id2), localStates.delete(id2), states.delete(id2), PendingUpdate.delete(id2);
    };
  }, [id2, parentId]), propsKey = getPropsKey(props), getSnapshot = function() {
    var _keys_current, _props_needsUpdate, local = localStates.get(id2), needsUpdate = props.passThrough ? false : isRoot || props.name === "light" || props.name === "dark" || props.name === null ? true : HasRenderedOnce.get(keys) ? !(keys == null || (_keys_current = keys.current) === null || _keys_current === void 0) && _keys_current.size ? true : (_props_needsUpdate = props.needsUpdate) === null || _props_needsUpdate === void 0 ? void 0 : _props_needsUpdate.call(props) : true, [rerender, next] = getNextState(local, props, propsKey, isRoot, id2, parentId, needsUpdate, PendingUpdate.get(id2));
    return PendingUpdate.delete(id2), (!local || rerender) && (local = __spreadValues({}, next), localStates.set(id2, local)), Object.assign(local, next), local.id = id2, states.set(id2, next), local;
  };
  var state = React.useSyncExternalStore(subscribe2, getSnapshot, getSnapshot);
  return useIsomorphicLayoutEffect(function() {
    if (!HasRenderedOnce.get(keys)) {
      HasRenderedOnce.set(keys, true);
      return;
    }
    if (!propsKey) {
      HadTheme.get(keys) && scheduleUpdate(id2), HadTheme.set(keys, false);
      return;
    }
    scheduleUpdate(id2), HadTheme.set(keys, true);
  }, [keys, propsKey]), state;
}, getNextState = function(lastState, props, propsKey) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, id2 = arguments.length > 4 ? arguments[4] : void 0, parentId = arguments.length > 5 ? arguments[5] : void 0, needsUpdate = arguments.length > 6 ? arguments[6] : void 0, pendingUpdate = arguments.length > 7 ? arguments[7] : void 0, {
    debug
  } = props, parentState = states.get(parentId);
  if (props.passThrough) return [false, lastState || parentState || {
    name: ""
  }];
  themes || (themes = getConfig().themes);
  var name = !propsKey && (!lastState || !(lastState == null ? void 0 : lastState.isNew)) ? null : getNewThemeName(parentState == null ? void 0 : parentState.name, props, pendingUpdate === "force" ? true : !!needsUpdate), isSameAsParent = parentState && (!name || name === parentState.name), shouldRerender = !!(needsUpdate && (pendingUpdate || (lastState == null ? void 0 : lastState.name) !== (parentState == null ? void 0 : parentState.name)));
  if (isSameAsParent) return [shouldRerender, __spreadProps(__spreadValues({}, parentState), {
    isNew: false
  })];
  if (!name) {
    var next = lastState != null ? lastState : parentState;
    if (!next) throw new Error(MISSING_THEME_MESSAGE);
    if (shouldRerender) {
      var updated = __spreadValues({}, parentState || lastState);
      return [true, updated];
    }
    return [false, next];
  }
  var scheme = getScheme(name), _parentState_inverses, parentInverses = (_parentState_inverses = parentState == null ? void 0 : parentState.inverses) !== null && _parentState_inverses !== void 0 ? _parentState_inverses : 0, isInverse = parentState && scheme !== parentState.scheme, inverses = parentInverses + (isInverse ? 1 : 0), nextState = {
    id: id2,
    name,
    theme: themes[name],
    scheme,
    parentId,
    parentName: parentState == null ? void 0 : parentState.name,
    inverses,
    isInverse,
    isNew: true
  };
  if (isRoot && (rootThemeState = nextState), pendingUpdate !== "force" && lastState && lastState.name === name) return [false, nextState];
  var shouldAvoidRerender = pendingUpdate !== "force" && lastState && !needsUpdate && nextState.name === lastState.name;
  return shouldAvoidRerender ? [false, nextState] : [true, nextState];
};
function scheduleUpdate(id2) {
  for (var queue2 = [id2], visited = /* @__PURE__ */ new Set(); queue2.length; ) {
    var parent = queue2.shift(), children = listenersByParent[parent];
    if (children) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var childId = _step.value;
          visited.has(childId) || (visited.add(childId), queue2.push(childId));
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
  }
  visited.forEach(function(childId2) {
    var cb = allListeners.get(childId2);
    cb == null ? void 0 : cb();
  });
}
var validSchemes = {
  light: "light",
  dark: "dark"
};
function getScheme(name) {
  return validSchemes[name.split("_")[0]];
}
function getNewThemeName() {
  var parentName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", {
    name,
    reset,
    componentName,
    inverse,
    debug
  } = arguments.length > 1 ? arguments[1] : void 0, forceUpdate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (name && reset) throw new Error("Cannot reset and set a new name at the same time.");
  var {
    themes: themes2
  } = getConfig();
  if (reset) {
    var isSchemeOnly = parentName === "light" || parentName === "dark";
    if (isSchemeOnly) return parentName === "light" ? "dark" : "light";
    var lastPartIndex = parentName.lastIndexOf("_"), name1 = lastPartIndex <= 0 ? parentName : parentName.slice(lastPartIndex), scheme = parentName.slice(0, lastPartIndex), result = themes2[name1] ? name1 : scheme;
    return result;
  }
  var parentParts = parentName.split("_"), lastName = parentParts[parentParts.length - 1];
  lastName && lastName[0].toLowerCase() !== lastName[0] && parentParts.pop();
  var subNames = [name && componentName ? `${name}_${componentName}` : void 0, name, componentName].filter(Boolean), found = null;
  if (name) {
    var nameHasScheme = getScheme(name);
    if (nameHasScheme) {
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = subNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var subName = _step.value;
          if (subName in themes2) {
            found = subName;
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
    }
    if (!found && !nameHasScheme) {
      var parentScheme = getScheme(parentName);
      if (parentScheme) {
        var parentBase = parentParts.join("_"), withScheme = [componentName ? `${parentBase}_${name}_${componentName}` : void 0, `${parentBase}_${name}`, componentName ? `${parentScheme}_${name}_${componentName}` : void 0, `${parentScheme}_${name}`].filter(Boolean), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
        try {
          for (var _iterator1 = withScheme[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var potential = _step1.value;
            if (potential in themes2) {
              found = potential;
              break;
            }
          }
        } catch (err) {
          _didIteratorError1 = true, _iteratorError1 = err;
        } finally {
          try {
            !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError1) throw _iteratorError1;
          }
        }
      }
    }
  }
  if (!found) if (!name && componentName) {
    var potential1 = `${parentParts.join("_")}_${componentName}`;
    potential1 in themes2 && (found = potential1);
  } else for (var max2 = parentParts.length, i = 0; i <= max2; i++) {
    var base = (i === 0 ? parentParts : parentParts.slice(0, -i)).join("_"), _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
    try {
      for (var _iterator2 = subNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var subName1 = _step2.value, potential2 = base ? `${base}_${subName1}` : subName1;
        if (potential2 in themes2) {
          found = potential2;
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true, _iteratorError2 = err;
    } finally {
      try {
        !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
      } finally {
        if (_didIteratorError2) throw _iteratorError2;
      }
    }
    if (found) break;
  }
  if (inverse) {
    found || (found = parentName);
    var scheme1 = found.split("_")[0];
    found = found.replace(new RegExp(`^${scheme1}`), scheme1 === "light" ? "dark" : "light");
  }
  return !forceUpdate && found === parentName && // if its a scheme only sub-theme, we always consider it "new" because it likely inverses
  // and we want to avoid reparenting
  !validSchemes[found] ? null : found;
}
var getPropsKey = function(param) {
  var {
    name,
    reset,
    inverse,
    forceClassName,
    componentName
  } = param;
  return `${name || ""}${inverse || ""}${reset || ""}${forceClassName || ""}${componentName || ""}`;
}, hasThemeUpdatingProps = function(props) {
  return "inverse" in props || "name" in props || "reset" in props || "forceClassName" in props;
};
function doesRootSchemeMatchSystem() {
  var _getRootThemeState;
  return ((_getRootThemeState = getRootThemeState()) === null || _getRootThemeState === void 0 ? void 0 : _getRootThemeState.scheme) === Appearance.getColorScheme();
}
var cache$4 = /* @__PURE__ */ new Map(), curKeys, curProps, curState, emptyObject$5 = {};
function getThemeProxied(_props, _state, _keys) {
  if (!(_state == null ? void 0 : _state.theme)) return emptyObject$5;
  if (curKeys = _keys, curProps = _props, curState = _state, cache$4.has(curState.theme)) {
    var proxied = cache$4.get(curState.theme);
    return proxied;
  }
  var config = getConfig();
  function track(key) {
    curKeys && (curKeys.current || (curKeys.current = /* @__PURE__ */ new Set()), curKeys.current.add(key), false);
  }
  var proxied1 = Object.fromEntries(Object.entries(_state.theme).flatMap(function(param) {
    var [key, value] = param, proxied2 = __spreadProps(__spreadValues({}, value), {
      get val() {
        return globalThis.tamaguiAvoidTracking || track(key), value.val;
      },
      get(platform2) {
        if (curState) {
          var outVal = getVariable(value), {
            name,
            scheme,
            inverses
          } = curState, shouldOptimize = scheme && platform2 !== "web" && isIos && !curProps.deopt && getSetting("fastSchemeChange") && inverses === 0 && doesRootSchemeMatchSystem();
          if (shouldOptimize) {
            var _config_themes_name, _config_themes_oppositeName, oppositeScheme = scheme === "dark" ? "light" : "dark", oppositeName = name.replace(scheme, oppositeScheme), color = getVariable((_config_themes_name = config.themes[name]) === null || _config_themes_name === void 0 ? void 0 : _config_themes_name[key]), oppositeColor = getVariable((_config_themes_oppositeName = config.themes[oppositeName]) === null || _config_themes_oppositeName === void 0 ? void 0 : _config_themes_oppositeName[key]), dynamicVal = getDynamicVal({
              scheme,
              val: color,
              oppositeVal: oppositeColor
            });
            return dynamicVal;
          }
          return track(key), outVal;
        }
      }
    });
    return [[key, proxied2], [`$${key}`, proxied2]];
  }));
  return cache$4.set(_state.theme, proxied1), proxied1;
}
var useTheme = function() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, [theme] = useThemeWithState(props), res = theme;
  return res;
}, useThemeWithState = function(props) {
  var isRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, keys = React.useRef(null), themeState = useThemeState(props, isRoot, keys);
  var themeProxied = props.passThrough ? {} : getThemeProxied(props, themeState, keys);
  return [themeProxied, themeState];
};
function setRef(ref, value) {
  typeof ref == "function" ? ref(value) : ref && (ref.current = value);
}
function composeRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return function(node) {
    return refs.forEach(function(ref) {
      return setRef(ref, node);
    });
  };
}
function useComposedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
  return React__namespace.useCallback(composeRefs(...refs), refs);
}
var defaultComponentState = {
  hover: false,
  press: false,
  pressIn: false,
  focus: false,
  focusVisible: false,
  focusWithin: false,
  unmounted: true,
  disabled: false
}, defaultComponentStateMounted = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: false
}), defaultComponentStateShouldEnter = __spreadProps(__spreadValues({}, defaultComponentState), {
  unmounted: "should-enter"
});
var matchMediaImpl = matchMediaFallback, matchMedia$1 = function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
  return matchMediaImpl(...args);
};
function matchMediaFallback(query2) {
  return !process.env.IS_STATIC && false, {
    match: function(a, b2) {
      return false;
    },
    addListener: function() {
    },
    removeListener: function() {
    },
    matches: false
  };
}
function setupMatchMedia(_) {
  matchMediaImpl = _, globalThis.matchMedia = _;
}
exports.mediaState = // development only safeguard
{};
var mediaQueryConfig = {}, getMedia = function() {
  return exports.mediaState;
}, mediaKeys = /* @__PURE__ */ new Set(), mediaKeyRegex = /\$(platform|theme|group)-/, getMediaKey = function(key) {
  if (key[0] !== "$") return false;
  if (mediaKeys.has(key)) return true;
  var match = key.match(mediaKeyRegex);
  return match ? match[1] : false;
}, initState, mediaKeysOrdered, getMediaKeyImportance = function(key) {
  var conf2 = getConfig();
  return conf2.settings.mediaPropOrder ? defaultMediaImportance : mediaKeysOrdered.indexOf(key) + 100;
}, dispose = /* @__PURE__ */ new Set(), mediaVersion = 0, configureMedia = function(config) {
  var {
    media
  } = config, mediaQueryDefaultActive = getSetting("mediaQueryDefaultActive");
  if (media) {
    mediaVersion++;
    for (var key in media) exports.mediaState[key] = (mediaQueryDefaultActive == null ? void 0 : mediaQueryDefaultActive[key]) || false, mediaKeys.add(`$${key}`);
    Object.assign(mediaQueryConfig, media), initState = __spreadValues({}, exports.mediaState), mediaKeysOrdered = Object.keys(media), setupMediaListeners();
  }
};
function unlisten() {
  dispose.forEach(function(cb) {
    return cb();
  }), dispose.clear();
}
var setupVersion = -1;
function setupMediaListeners() {
  var _loop2 = function(key2) {
    var str = mediaObjectToString(mediaQueryConfig[key2]), getMatch = function() {
      return matchMedia$1(str);
    }, match = getMatch();
    if (!match) throw new Error(" No match");
    match.addListener(update2), dispose.add(function() {
      match.removeListener(update2);
    });
    function update2() {
      var next = !!getMatch().matches;
      next !== exports.mediaState[key2] && (exports.mediaState = __spreadProps(__spreadValues({}, exports.mediaState), {
        [key2]: next
      }), updateMediaListeners());
    }
    update2();
  };
  if (!process.env.IS_STATIC && setupVersion !== mediaVersion) {
    setupVersion = mediaVersion, unlisten();
    for (var key in mediaQueryConfig) _loop2(key);
  }
}
var listeners$2 = /* @__PURE__ */ new Set();
function updateMediaListeners() {
  listeners$2.forEach(function(cb) {
    return cb(exports.mediaState);
  });
}
var States = /* @__PURE__ */ new WeakMap();
function setMediaShouldUpdate(ref, enabled, keys) {
  var cur = States.get(ref);
  (!cur || cur.enabled !== enabled || keys) && States.set(ref, __spreadProps(__spreadValues({}, cur), {
    enabled,
    keys
  }));
}
function subscribe$1(subscriber) {
  return listeners$2.add(subscriber), function() {
    listeners$2.delete(subscriber);
  };
}
function useMedia(componentContext, debug) {
  var componentState = componentContext ? States.get(componentContext) : null, internalRef = React.useRef(null);
  internalRef.current || (internalRef.current = {
    keys: /* @__PURE__ */ new Set(),
    lastState: exports.mediaState
  }), internalRef.current.pendingState && (internalRef.current.lastState = internalRef.current.pendingState, internalRef.current.pendingState = void 0);
  var {
    keys
  } = internalRef.current;
  keys.size && keys.clear();
  var state = React.useSyncExternalStore(subscribe$1, function() {
    var curKeys2 = (componentState == null ? void 0 : componentState.keys) || keys, {
      lastState,
      pendingState
    } = internalRef.current;
    if (!curKeys2.size) return lastState;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = curKeys2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;
        if (exports.mediaState[key] !== (pendingState || lastState)[key]) return false, (componentContext == null ? void 0 : componentContext.mediaEmit) ? (componentContext.mediaEmit(exports.mediaState), internalRef.current.pendingState = exports.mediaState, lastState) : (internalRef.current.lastState = exports.mediaState, exports.mediaState);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    return lastState;
  }, getServerSnapshot);
  return new Proxy(state, {
    get(_, key) {
      return !disableMediaTouch && typeof key == "string" && keys.add(key), Reflect.get(state, key);
    }
  });
}
var getServerSnapshot = function() {
  return initState;
}, disableMediaTouch = false;
function getMediaState(mediaGroups, layout) {
  disableMediaTouch = true;
  var res;
  try {
    res = Object.fromEntries([...mediaGroups].map(function(mediaKey) {
      return [mediaKey, mediaKeyMatch(mediaKey, layout)];
    }));
  } finally {
    disableMediaTouch = false;
  }
  return res;
}
var getMediaImportanceIfMoreImportant = function(mediaKey, key, styleState, isSizeMedia) {
  var importance = isSizeMedia && !getSetting("mediaPropOrder") ? getMediaKeyImportance(mediaKey) : defaultMediaImportance, usedKeys = styleState.usedKeys;
  return !usedKeys[key] || importance > usedKeys[key] ? importance : null;
};
function camelToHyphen(str) {
  return str.replace(/[A-Z]/g, function(m) {
    return `-${m.toLowerCase()}`;
  }).toLowerCase();
}
var cache$3 = /* @__PURE__ */ new WeakMap();
function mediaObjectToString(query2, key) {
  if (typeof query2 == "string") return query2;
  if (cache$3.has(query2)) return cache$3.get(query2);
  var res = Object.entries(query2).map(function(param) {
    var [feature, value] = param;
    return feature = camelToHyphen(feature), typeof value == "string" ? `(${feature}: ${value})` : (typeof value == "number" && /[height|width]$/.test(feature) && (value = `${value}px`), `(${feature}: ${value})`);
  }).join(" and ");
  return cache$3.set(query2, res), res;
}
function mediaKeyMatch(key, dimensions2) {
  var mediaQueries = mediaQueryConfig[key], result = Object.keys(mediaQueries).every(function(query2) {
    var expectedVal = +mediaQueries[query2], isMax = query2.startsWith("max"), isWidth = query2.endsWith("Width"), givenVal = dimensions2[isWidth ? "width" : "height"];
    return isMax ? givenVal < expectedVal : givenVal > expectedVal;
  });
  return result;
}
function getGroupPropParts(groupProp) {
  var mediaQueries = getMedia(), [_, name, part3, part4] = groupProp.split("-"), pseudo, media = part3 in mediaQueries ? part3 : void 0;
  return media ? pseudo = part4 : pseudo = part3, {
    name,
    pseudo,
    media
  };
}
var defaultOffset$1 = {
  height: 0,
  width: 0
};
var normalizeColor_1;
var hasRequiredNormalizeColor;
function requireNormalizeColor() {
  if (hasRequiredNormalizeColor) return normalizeColor_1;
  hasRequiredNormalizeColor = 1;
  function normalizeColor2(color) {
    if (typeof color === "number") {
      if (color >>> 0 === color && color >= 0 && color <= 4294967295) {
        return color;
      }
      return null;
    }
    if (typeof color !== "string") {
      return null;
    }
    const matchers = getMatchers();
    let match;
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + "ff", 16) >>> 0;
    }
    const colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 | // r
      parse255(match[2]) << 16 | // g
      parse255(match[3]) << 8 | // b
      255) >>> // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      if (match[6] !== void 0) {
        return (parse255(match[6]) << 24 | // r
        parse255(match[7]) << 16 | // g
        parse255(match[8]) << 8 | // b
        parse1(match[9])) >>> // a
        0;
      }
      return (parse255(match[2]) << 24 | // r
      parse255(match[3]) << 16 | // g
      parse255(match[4]) << 8 | // b
      parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        "ff",
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(
        match[1] + match[1] + // r
        match[2] + match[2] + // g
        match[3] + match[3] + // b
        match[4] + match[4],
        // a
        16
      ) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // s
        parsePercentage(match[3])
        // l
      ) | 255) >>> // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      if (match[6] !== void 0) {
        return (hslToRgb(
          parse360(match[6]),
          // h
          parsePercentage(match[7]),
          // s
          parsePercentage(match[8])
          // l
        ) | parse1(match[9])) >>> // a
        0;
      }
      return (hslToRgb(
        parse360(match[2]),
        // h
        parsePercentage(match[3]),
        // s
        parsePercentage(match[4])
        // l
      ) | parse1(match[5])) >>> // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(
        parse360(match[1]),
        // h
        parsePercentage(match[2]),
        // w
        parsePercentage(match[3])
        // b
      ) | 255) >>> // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p + (q - p) * 6 * t2;
    }
    if (t2 < 1 / 2) {
      return q;
    }
    if (t2 < 2 / 3) {
      return p + (q - p) * (2 / 3 - t2) * 6;
    }
    return p;
  }
  function hslToRgb(h2, s2, l) {
    const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h2 + 1 / 3);
    const g = hue2rgb(p, q, h2);
    const b2 = hue2rgb(p, q, h2 - 1 / 3);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function hwbToRgb(h2, w2, b2) {
    if (w2 + b2 >= 1) {
      const gray = Math.round(w2 * 255 / (w2 + b2));
      return gray << 24 | gray << 16 | gray << 8;
    }
    const red = hue2rgb(0, 1, h2 + 1 / 3) * (1 - w2 - b2) + w2;
    const green = hue2rgb(0, 1, h2) * (1 - w2 - b2) + w2;
    const blue = hue2rgb(0, 1, h2 - 1 / 3) * (1 - w2 - b2) + w2;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call(...args) {
    return "\\(\\s*(" + args.join(")\\s*,?\\s*(") + ")\\s*\\)";
  }
  function callWithSlashSeparator(...args) {
    return "\\(\\s*(" + args.slice(0, args.length - 1).join(")\\s*,?\\s*(") + ")\\s*/\\s*(" + args[args.length - 1] + ")\\s*\\)";
  }
  function commaSeparatedCall(...args) {
    return "\\(\\s*(" + args.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  let cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === void 0) {
      cachedMatchers = {
        rgb: new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp(
          "rgba(" + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + "|" + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ")"
        ),
        hsl: new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp(
          "hsla(" + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + "|" + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ")"
        ),
        hwb: new RegExp("hwb" + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    switch (name) {
      case "transparent":
        return 0;
      // http://www.w3.org/TR/css3-color/#svg-color
      case "aliceblue":
        return 4042850303;
      case "antiquewhite":
        return 4209760255;
      case "aqua":
        return 16777215;
      case "aquamarine":
        return 2147472639;
      case "azure":
        return 4043309055;
      case "beige":
        return 4126530815;
      case "bisque":
        return 4293182719;
      case "black":
        return 255;
      case "blanchedalmond":
        return 4293643775;
      case "blue":
        return 65535;
      case "blueviolet":
        return 2318131967;
      case "brown":
        return 2771004159;
      case "burlywood":
        return 3736635391;
      case "burntsienna":
        return 3934150143;
      case "cadetblue":
        return 1604231423;
      case "chartreuse":
        return 2147418367;
      case "chocolate":
        return 3530104575;
      case "coral":
        return 4286533887;
      case "cornflowerblue":
        return 1687547391;
      case "cornsilk":
        return 4294499583;
      case "crimson":
        return 3692313855;
      case "cyan":
        return 16777215;
      case "darkblue":
        return 35839;
      case "darkcyan":
        return 9145343;
      case "darkgoldenrod":
        return 3095792639;
      case "darkgray":
        return 2846468607;
      case "darkgreen":
        return 6553855;
      case "darkgrey":
        return 2846468607;
      case "darkkhaki":
        return 3182914559;
      case "darkmagenta":
        return 2332068863;
      case "darkolivegreen":
        return 1433087999;
      case "darkorange":
        return 4287365375;
      case "darkorchid":
        return 2570243327;
      case "darkred":
        return 2332033279;
      case "darksalmon":
        return 3918953215;
      case "darkseagreen":
        return 2411499519;
      case "darkslateblue":
        return 1211993087;
      case "darkslategray":
        return 793726975;
      case "darkslategrey":
        return 793726975;
      case "darkturquoise":
        return 13554175;
      case "darkviolet":
        return 2483082239;
      case "deeppink":
        return 4279538687;
      case "deepskyblue":
        return 12582911;
      case "dimgray":
        return 1768516095;
      case "dimgrey":
        return 1768516095;
      case "dodgerblue":
        return 512819199;
      case "firebrick":
        return 2988581631;
      case "floralwhite":
        return 4294635775;
      case "forestgreen":
        return 579543807;
      case "fuchsia":
        return 4278255615;
      case "gainsboro":
        return 3705462015;
      case "ghostwhite":
        return 4177068031;
      case "gold":
        return 4292280575;
      case "goldenrod":
        return 3668254975;
      case "gray":
        return 2155905279;
      case "green":
        return 8388863;
      case "greenyellow":
        return 2919182335;
      case "grey":
        return 2155905279;
      case "honeydew":
        return 4043305215;
      case "hotpink":
        return 4285117695;
      case "indianred":
        return 3445382399;
      case "indigo":
        return 1258324735;
      case "ivory":
        return 4294963455;
      case "khaki":
        return 4041641215;
      case "lavender":
        return 3873897215;
      case "lavenderblush":
        return 4293981695;
      case "lawngreen":
        return 2096890111;
      case "lemonchiffon":
        return 4294626815;
      case "lightblue":
        return 2916673279;
      case "lightcoral":
        return 4034953471;
      case "lightcyan":
        return 3774873599;
      case "lightgoldenrodyellow":
        return 4210742015;
      case "lightgray":
        return 3553874943;
      case "lightgreen":
        return 2431553791;
      case "lightgrey":
        return 3553874943;
      case "lightpink":
        return 4290167295;
      case "lightsalmon":
        return 4288707327;
      case "lightseagreen":
        return 548580095;
      case "lightskyblue":
        return 2278488831;
      case "lightslategray":
        return 2005441023;
      case "lightslategrey":
        return 2005441023;
      case "lightsteelblue":
        return 2965692159;
      case "lightyellow":
        return 4294959359;
      case "lime":
        return 16711935;
      case "limegreen":
        return 852308735;
      case "linen":
        return 4210091775;
      case "magenta":
        return 4278255615;
      case "maroon":
        return 2147483903;
      case "mediumaquamarine":
        return 1724754687;
      case "mediumblue":
        return 52735;
      case "mediumorchid":
        return 3126187007;
      case "mediumpurple":
        return 2473647103;
      case "mediumseagreen":
        return 1018393087;
      case "mediumslateblue":
        return 2070474495;
      case "mediumspringgreen":
        return 16423679;
      case "mediumturquoise":
        return 1221709055;
      case "mediumvioletred":
        return 3340076543;
      case "midnightblue":
        return 421097727;
      case "mintcream":
        return 4127193855;
      case "mistyrose":
        return 4293190143;
      case "moccasin":
        return 4293178879;
      case "navajowhite":
        return 4292783615;
      case "navy":
        return 33023;
      case "oldlace":
        return 4260751103;
      case "olive":
        return 2155872511;
      case "olivedrab":
        return 1804477439;
      case "orange":
        return 4289003775;
      case "orangered":
        return 4282712319;
      case "orchid":
        return 3664828159;
      case "palegoldenrod":
        return 4008225535;
      case "palegreen":
        return 2566625535;
      case "paleturquoise":
        return 2951671551;
      case "palevioletred":
        return 3681588223;
      case "papayawhip":
        return 4293907967;
      case "peachpuff":
        return 4292524543;
      case "peru":
        return 3448061951;
      case "pink":
        return 4290825215;
      case "plum":
        return 3718307327;
      case "powderblue":
        return 2967529215;
      case "purple":
        return 2147516671;
      case "rebeccapurple":
        return 1714657791;
      case "red":
        return 4278190335;
      case "rosybrown":
        return 3163525119;
      case "royalblue":
        return 1097458175;
      case "saddlebrown":
        return 2336560127;
      case "salmon":
        return 4202722047;
      case "sandybrown":
        return 4104413439;
      case "seagreen":
        return 780883967;
      case "seashell":
        return 4294307583;
      case "sienna":
        return 2689740287;
      case "silver":
        return 3233857791;
      case "skyblue":
        return 2278484991;
      case "slateblue":
        return 1784335871;
      case "slategray":
        return 1887473919;
      case "slategrey":
        return 1887473919;
      case "snow":
        return 4294638335;
      case "springgreen":
        return 16744447;
      case "steelblue":
        return 1182971135;
      case "tan":
        return 3535047935;
      case "teal":
        return 8421631;
      case "thistle":
        return 3636451583;
      case "tomato":
        return 4284696575;
      case "turquoise":
        return 1088475391;
      case "violet":
        return 4001558271;
      case "wheat":
        return 4125012991;
      case "white":
        return 4294967295;
      case "whitesmoke":
        return 4126537215;
      case "yellow":
        return 4294902015;
      case "yellowgreen":
        return 2597139199;
    }
    return null;
  }
  normalizeColor_1 = normalizeColor2;
  return normalizeColor_1;
}
var normalizeColorExports = requireNormalizeColor();
const index = /* @__PURE__ */ getDefaultExportFromCjs(normalizeColorExports);
const normalizeColor$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [normalizeColorExports]);
var norm = index || normalizeColor$3, normalizeCSSColor = norm;
function rgba(colorInt) {
  var r = Math.round((colorInt & 4278190080) >>> 24), g = Math.round((colorInt & 16711680) >>> 16), b2 = Math.round((colorInt & 65280) >>> 8), a = ((colorInt & 255) >>> 0) / 255;
  return {
    r,
    g,
    b: b2,
    a
  };
}
var index_default = normalizeCSSColor;
var normalizeColor$2 = function(color, opacity) {
  if (color) {
    if (color[0] === "$") return color;
    if (color.startsWith("var(")) ;
    else {
      var rgba3 = getRgba(color);
      if (rgba3) {
        var colors = `${rgba3.r},${rgba3.g},${rgba3.b}`, _ref;
        return opacity === 1 ? `rgb(${colors})` : `rgba(${colors},${(_ref = opacity) !== null && _ref !== void 0 ? _ref : 1})`;
      }
    }
    return color;
  }
}, getRgba = function(color) {
  var colorNum = normalizeCSSColor(color);
  if (colorNum != null) return rgba(colorNum);
};
function normalizeShadow(param) {
  var {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius
  } = param, _getRgba, {
    height,
    width
  } = shadowOffset || defaultOffset$1;
  return {
    shadowOffset: {
      width: width || 0,
      height: height || 0
    },
    shadowRadius: shadowRadius || 0,
    shadowColor: normalizeColor$2(shadowColor, 1),
    shadowOpacity: shadowOpacity != null ? shadowOpacity : shadowColor ? (_getRgba = getRgba(shadowColor)) === null || _getRgba === void 0 ? void 0 : _getRgba.a : 1
  };
}
function fixStyles(style) {
  "elevationAndroid" in style && (style.elevation = style.elevationAndroid, delete style.elevationAndroid), (style.shadowRadius != null || style.shadowColor || style.shadowOpacity != null || style.shadowOffset) && Object.assign(style, normalizeShadow(style));
  for (var key in borderDefaults) if (key in style) {
    var _style, _borderDefaults_key;
    (_style = style)[_borderDefaults_key = borderDefaults[key]] || (_style[_borderDefaults_key] = "solid");
  }
}
var nativeStyle = "borderStyle", borderDefaults = {
  borderWidth: "borderStyle",
  borderBottomWidth: nativeStyle,
  borderTopWidth: nativeStyle,
  borderLeftWidth: nativeStyle,
  borderRightWidth: nativeStyle
};
var empty = function() {
  console.warn("no-op native");
}, getCSSStylesAtomic = empty;
function scanAllSheets() {
}
process.env.TAMAGUI_BAIL_AFTER_SCANNING_X_CSS_RULES;
process.env.TAMAGUI_INSERT_SELECTOR_TRIES ? +process.env.TAMAGUI_INSERT_SELECTOR_TRIES : 1;
function isActivePlatform(key) {
  if (!key.startsWith("$platform")) return true;
  var platform2 = key.slice(10);
  return (
    // web, ios, android
    platform2 === currentPlatform || // web, native
    platform2 === "native"
  );
}
function isActiveTheme(key, activeThemeName) {
  if (key.startsWith("$theme-")) return key.slice(7).startsWith(activeThemeName);
}
__spreadValues({}, stylePropsAll);
function normalizeValueWithProperty$1(value) {
  return value;
}
var _loop$1 = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  expansionsNoPrefix[parent] = expansionsNoPrefix[parent].map(function(k) {
    return `${prefix}${k}`;
  });
}, resizeModeMap = {
  fill: "stretch",
  none: "center",
  "scale-down": "contain",
  contain: "contain",
  cover: "cover"
}, verticalAlignMap = {
  top: "top",
  middle: "center",
  bottom: "bottom",
  auto: "auto"
}, webToNativeDynamicExpansion = {
  objectFit: function(val) {
    var resizeMode = resizeModeMap[val] || "cover";
    return [["resizeMode", resizeMode]];
  },
  verticalAlign: function(val) {
    return [["textAlignVertical", verticalAlignMap[val] || "auto"]];
  }
}, vert$1 = ["Top", "Bottom"], es = ["End", "Start"], t = ["Top"], b = ["Bottom"], s = ["Start"], e = ["End"], h = ["Height"], w = ["Width"], expansionsNoPrefix = {
  borderBlockColor: ["TopColor", "BottomColor"],
  borderInlineColor: ["EndColor", "StartColor"],
  borderBlockWidth: ["TopWidth", "BottomWidth"],
  borderInlineWidth: ["EndWidth", "StartWidth"],
  borderBlockStyle: ["TopStyle", "BottomStyle"],
  borderInlineStyle: ["EndStyle", "StartStyle"],
  marginBlock: vert$1,
  marginInline: es,
  paddingBlock: vert$1,
  paddingInline: es,
  borderBlockStartColor: ["TopColor"],
  borderBlockEndColor: ["BottomColor"],
  borderInlineStartColor: ["StartColor"],
  borderInlineEndColor: ["EndColor"],
  borderBlockStartWidth: ["TopWidth"],
  borderBlockEndWidth: ["BottomWidth"],
  borderInlineStartWidth: ["StartWidth"],
  borderInlineEndWidth: ["EndWidth"],
  borderBlockStartStyle: ["TopStyle"],
  borderBlockEndStyle: ["BottomStyle"],
  borderInlineStartStyle: ["StartStyle"],
  borderInlineEndStyle: ["EndStyle"],
  marginBlockStart: t,
  marginBlockEnd: b,
  marginInlineStart: s,
  marginInlineEnd: e,
  paddingBlockStart: t,
  paddingBlockEnd: b,
  paddingInlineStart: s,
  paddingInlineEnd: e,
  minBlockSize: h,
  maxBlockSize: h,
  minInlineSize: w,
  maxInlineSize: w
};
for (var parent$1 in expansionsNoPrefix) _loop$1(parent$1);
var expansions = {
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  blockSize: ["height"],
  inlineSize: ["width"]
}, webToNativeExpansion = Object.assign(expansionsNoPrefix, expansions);
var _loop = function(parent) {
  var _exec, _exec_index, prefix = parent.slice(0, (_exec_index = (_exec = /[A-Z]/.exec(parent)) === null || _exec === void 0 ? void 0 : _exec.index) !== null && _exec_index !== void 0 ? _exec_index : parent.length);
  EXPANSIONS[parent] = EXPANSIONS[parent].map(function(k) {
    return `${prefix}${k}`;
  });
};
function expandStyle(key, value) {
  if (isAndroid && key === "elevationAndroid") return [["elevation", value]];
  if (key in EXPANSIONS) return EXPANSIONS[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeExpansion) return webToNativeExpansion[key].map(function(key2) {
    return [key2, value];
  });
  if (key in webToNativeDynamicExpansion) return webToNativeDynamicExpansion[key](value);
}
var all = ["Top", "Right", "Bottom", "Left"], horiz = ["Right", "Left"], vert = ["Top", "Bottom"], xy = ["X", "Y"], EXPANSIONS = __spreadValues({
  borderColor: ["TopColor", "RightColor", "BottomColor", "LeftColor"],
  borderRadius: ["TopLeftRadius", "TopRightRadius", "BottomRightRadius", "BottomLeftRadius"],
  borderWidth: ["TopWidth", "RightWidth", "BottomWidth", "LeftWidth"],
  margin: all,
  marginHorizontal: horiz,
  marginVertical: vert,
  overscrollBehavior: xy,
  padding: all,
  paddingHorizontal: horiz,
  paddingVertical: vert
}, isWeb);
for (var parent in EXPANSIONS) _loop(parent);
var cache$2 = /* @__PURE__ */ new WeakMap(), getVariantExtras = function(styleState) {
  if (cache$2.has(styleState)) return cache$2.get(styleState);
  var {
    props,
    conf: conf2,
    context: context2,
    theme,
    styleProps: styleProps2
  } = styleState, fonts = conf2.fontsParsed;
  (context2 == null ? void 0 : context2.language) && (fonts = getFontsForLanguage(conf2.fontsParsed, context2.language));
  var next = {
    fonts,
    tokens: conf2.tokensParsed,
    theme,
    context: styleProps2 == null ? void 0 : styleProps2.styledContext,
    get fontFamily() {
      return getVariableValue(styleState.fontFamily || styleState.props.fontFamily) || props.fontFamily || getVariableValue(getSetting("defaultFont"));
    },
    get font() {
      return fonts[this.fontFamily] || (!props.fontFamily || props.fontFamily[0] === "$" ? fonts[getSetting("defaultFont") || ""] : void 0);
    },
    props
  };
  return cache$2.set(styleState, next), next;
}, fontLanguageCache = /* @__PURE__ */ new WeakMap();
function getFontsForLanguage(fonts, language) {
  if (fontLanguageCache.has(language)) return fontLanguageCache.get(language);
  var next = __spreadValues(__spreadValues({}, fonts), Object.fromEntries(Object.entries(language).map(function(param) {
    var [name, lang] = param;
    if (lang === "default") return [];
    var langKey = `$${name}_${lang}`;
    return [`$${name}`, fonts[langKey]];
  })));
  return fontLanguageCache.set(language, next), next;
}
function _type_of$8(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var isObj = function(x) {
  return x && !Array.isArray(x) && (typeof x > "u" ? "undefined" : _type_of$8(x)) === "object";
};
function normalizeStyle$1(style) {
  var disableNormalize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, res = {};
  for (var key in style) {
    var prop = style[key];
    if (prop != null) {
      if (key in pseudoDescriptors || // this should capture all parent-based styles like media, group, etc
      key[0] === "$" && isObj(prop)) {
        res[key] = normalizeStyle$1(prop, disableNormalize);
        continue;
      }
      var value = disableNormalize ? prop : normalizeValueWithProperty$1(prop), out = expandStyle(key, value);
      out ? Object.assign(res, Object.fromEntries(out)) : res[key] = value;
    }
  }
  return fixStyles(res), res;
}
var webPropsToSkip = {
  whiteSpace: 1,
  wordWrap: 1,
  textOverflow: 1,
  textDecorationDistance: 1,
  cursor: 1,
  contain: 1,
  boxSizing: 1,
  touchAction: 1,
  outlineStyle: 1,
  outlineOffset: 1,
  outlineWidth: 1,
  outlineColor: 1,
  backdropFilter: 1,
  backgroundImage: 1,
  mixBlendMode: 1,
  scrollbarWidth: 1,
  backgroundOrigin: 1,
  backgroundPosition: 1,
  backgroundRepeat: 1,
  backgroundSize: 1,
  backgroundClip: 1,
  backgroundBlendMode: 1,
  backgroundAttachment: 1,
  background: 1,
  clipPath: 1,
  caretColor: 1,
  transformStyle: 1,
  mask: 1,
  maskImage: 1,
  textEmphasis: 1,
  borderImage: 1,
  float: 1,
  content: 1,
  overflowBlock: 1,
  overflowInline: 1,
  maskBorder: 1,
  maskBorderMode: 1,
  maskBorderOutset: 1,
  maskBorderRepeat: 1,
  maskBorderSlice: 1,
  maskBorderSource: 1,
  maskBorderWidth: 1,
  maskClip: 1,
  maskComposite: 1,
  maskMode: 1,
  maskOrigin: 1,
  maskPosition: 1,
  maskRepeat: 1,
  maskSize: 1,
  maskType: 1
};
var skipProps = {
  untilMeasured: 1,
  animation: 1,
  space: 1,
  animateOnly: 1,
  disableClassName: 1,
  debug: 1,
  componentName: 1,
  disableOptimization: 1,
  tag: 1,
  style: 1,
  // handled after loop so pseudos set usedKeys and override it if necessary
  group: 1,
  themeInverse: 1,
  animatePresence: 1
};
skipProps["data-test-renders"] = 1;
Object.assign(skipProps, webPropsToSkip);
function _type_of$7(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var propMapper = function(key, value, styleState, disabled, map) {
  if (disabled) return map(key, value);
  if (lastFontFamilyToken = null, !(!isAndroid && key === "elevationAndroid")) {
    var {
      conf: conf2,
      styleProps: styleProps2,
      staticConfig
    } = styleState;
    if (value === "unset") {
      var _conf_unset, unsetVal = (_conf_unset = conf2.unset) === null || _conf_unset === void 0 ? void 0 : _conf_unset[key];
      if (unsetVal != null) value = unsetVal;
      else return;
    }
    var {
      variants: variants2
    } = staticConfig;
    if (!styleProps2.noExpand && variants2 && key in variants2) {
      var variantValue = resolveVariants(key, value, styleProps2, styleState, "");
      if (variantValue) {
        variantValue.forEach(function(param) {
          var [_$key, _$value] = param;
          return map(_$key, _$value);
        });
        return;
      }
    }
    styleProps2.disableExpandShorthands || key in conf2.shorthands && (key = conf2.shorthands[key]);
    var originalValue = value;
    if (value != null && (value[0] === "$" ? value = getTokenForKey(key, value, styleProps2, styleState) : isVariable(value) && (value = resolveVariableValue(key, value, styleProps2.resolveValues))), value != null) {
      key === "fontFamily" && lastFontFamilyToken && (styleState.fontFamily = lastFontFamilyToken);
      var expanded = styleProps2.noExpand ? null : expandStyle(key, value);
      if (expanded) for (var max2 = expanded.length, i = 0; i < max2; i++) {
        var [nkey, nvalue] = expanded[i];
        map(nkey, nvalue, originalValue);
      }
      else map(key, value, originalValue);
    }
  }
}, resolveVariants = function(key, value, styleProps2, styleState, parentVariantKey) {
  var {
    staticConfig,
    conf: conf2,
    debug
  } = styleState, {
    variants: variants2
  } = staticConfig;
  if (variants2) {
    var variantValue = getVariantDefinition(variants2[key], value, conf2);
    if (!variantValue) {
      if (process.env.TAMAGUI_WARN_ON_MISSING_VARIANT === "1" && typeof value != "boolean") {
        var name = staticConfig.componentName || "[UnnamedComponent]";
        console.warn(`No variant found: ${name} has variant "${key}", but no matching value "${value}"`);
      }
      return;
    }
    if (typeof variantValue == "function") {
      var fn = variantValue, extras = getVariantExtras(styleState);
      variantValue = fn(value, extras);
    }
    var fontFamilyResult;
    if (isObj(variantValue)) {
      var fontFamilyUpdate = variantValue.fontFamily || variantValue[conf2.inverseShorthands.fontFamily];
      fontFamilyUpdate && (fontFamilyResult = getFontFamilyFromNameOrVariable(fontFamilyUpdate, conf2), styleState.fontFamily = fontFamilyResult, false), variantValue = resolveTokensAndVariants(key, variantValue, styleProps2, styleState, parentVariantKey);
    }
    if (variantValue) {
      var expanded = normalizeStyle$1(variantValue, !!styleProps2.noNormalize);
      var next = Object.entries(expanded);
      return fontFamilyResult && fontFamilyResult[0] === "$" && (lastFontFamilyToken = getVariableValue(fontFamilyResult)), next;
    }
  }
};
function getFontFamilyFromNameOrVariable(input, conf2) {
  if (isVariable(input)) {
    var val = variableToFontNameCache.get(input);
    if (val) return val;
    for (var key in conf2.fontsParsed) {
      var familyVariable = conf2.fontsParsed[key].family;
      if (isVariable(familyVariable) && (variableToFontNameCache.set(familyVariable, key), familyVariable === input)) return key;
    }
  } else if (typeof input == "string" && input[0] === "$") return input;
}
var variableToFontNameCache = /* @__PURE__ */ new WeakMap(), resolveTokensAndVariants = function(key, value, styleProps2, styleState, parentVariantKey) {
  var {
    conf: conf2,
    staticConfig,
    debug,
    theme
  } = styleState, {
    variants: variants2
  } = staticConfig, res = {};
  for (var _key in value) {
    var subKey = conf2.shorthands[_key] || _key, val = value[_key];
    if (!(!styleProps2.noSkip && subKey in skipProps)) {
      if (staticConfig) {
        var _staticConfig_context, _staticConfig_parentStaticConfig_context, _staticConfig_parentStaticConfig, contextProps = ((_staticConfig_context = staticConfig.context) === null || _staticConfig_context === void 0 ? void 0 : _staticConfig_context.props) || ((_staticConfig_parentStaticConfig = staticConfig.parentStaticConfig) === null || _staticConfig_parentStaticConfig === void 0 || (_staticConfig_parentStaticConfig_context = _staticConfig_parentStaticConfig.context) === null || _staticConfig_parentStaticConfig_context === void 0 ? void 0 : _staticConfig_parentStaticConfig_context.props);
        if (contextProps && subKey in contextProps) {
          var _styleState, _styleState1;
          (_styleState = styleState).overriddenContextProps || (_styleState.overriddenContextProps = {}), styleState.overriddenContextProps[subKey] = val, (_styleState1 = styleState).originalContextPropValues || (_styleState1.originalContextPropValues = {}), styleState.originalContextPropValues[subKey] = val;
        }
      }
      if (styleProps2.noExpand) res[subKey] = val;
      else if (variants2 && subKey in variants2) {
        if (parentVariantKey && parentVariantKey === key) res[subKey] = // SYNC WITH *1
        val[0] === "$" ? getTokenForKey(subKey, val, styleProps2, styleState) : val;
        else {
          var variantOut = resolveVariants(subKey, val, styleProps2, styleState, key);
          if (variantOut) {
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
            try {
              for (var _iterator = variantOut[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var [_$key, val1] = _step.value;
                if (val1 != null) if (_$key in pseudoDescriptors) {
                  var _res, _key1, _;
                  (_ = (_res = res)[_key1 = _$key]) !== null && _ !== void 0 || (_res[_key1] = {}), Object.assign(res[_$key], val1);
                } else res[_$key] = val1;
              }
            } catch (err) {
              _didIteratorError = true, _iteratorError = err;
            } finally {
              try {
                !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError) throw _iteratorError;
              }
            }
          }
        }
        continue;
      }
      if (isVariable(val)) {
        res[subKey] = resolveVariableValue(subKey, val, styleProps2.resolveValues);
        continue;
      }
      if (typeof val == "string") {
        var fVal = (
          // SYNC WITH *1
          val[0] === "$" ? getTokenForKey(subKey, val, styleProps2, styleState) : val
        );
        res[subKey] = fVal;
        continue;
      }
      if (isObj(val)) {
        var _res1, _subKey, subObject = resolveTokensAndVariants(subKey, val, styleProps2, styleState, key);
        var _1;
        (_1 = (_res1 = res)[_subKey = subKey]) !== null && _1 !== void 0 || (_res1[_subKey] = {}), Object.assign(res[subKey], subObject);
      } else res[subKey] = val;
    }
  }
  return res;
}, tokenCats = ["size", "color", "radius", "space", "zIndex"].map(function(name) {
  return {
    name,
    spreadName: `...${name}`
  };
});
function getVariantDefinition(variant, value, conf2) {
  if (variant) {
    if (typeof variant == "function") return variant;
    var exact = variant[value];
    if (exact) return exact;
    if (value != null) {
      var {
        tokensParsed
      } = conf2, _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = tokenCats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var {
            name,
            spreadName
          } = _step.value;
          if (spreadName in variant && name in tokensParsed && value in tokensParsed[name]) return variant[spreadName];
        }
      } catch (err) {
        _didIteratorError = true, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError) throw _iteratorError;
        }
      }
      var fontSizeVariant = variant["...fontSize"];
      if (fontSizeVariant && conf2.fontSizeTokens.has(value)) return fontSizeVariant;
    }
    return variant[`:${typeof value > "u" ? "undefined" : _type_of$7(value)}`] || variant["..."];
  }
}
var fontShorthand = {
  fontSize: "size",
  fontWeight: "weight"
}, lastFontFamilyToken = null, getTokenForKey = function(key, value, styleProps2, styleState) {
  var _staticConfig_accept, resolveAs = styleProps2.resolveValues || "none";
  if (resolveAs === "none") return value;
  var {
    theme,
    conf: conf2 = getConfig(),
    context: context2,
    fontFamily,
    staticConfig
  } = styleState, themeValue = theme ? theme[value] || theme[value.slice(1)] : void 0, tokensParsed = conf2.tokensParsed, valOrVar, hasSet = false, customTokenAccept = staticConfig == null || (_staticConfig_accept = staticConfig.accept) === null || _staticConfig_accept === void 0 ? void 0 : _staticConfig_accept[key];
  if (customTokenAccept) {
    var val = themeValue != null ? themeValue : tokensParsed[customTokenAccept][value];
    val != null && (resolveAs = "value", valOrVar = val, hasSet = true);
  }
  if (themeValue) {
    if (resolveAs === "except-theme") return value;
    valOrVar = themeValue, hasSet = true;
  } else {
    if (value in conf2.specificTokens) hasSet = true, valOrVar = conf2.specificTokens[value];
    else {
      switch (key) {
        case "fontFamily": {
          var _fontsParsed_value, fontsParsed = (context2 == null ? void 0 : context2.language) ? getFontsForLanguage(conf2.fontsParsed, context2.language) : conf2.fontsParsed;
          valOrVar = ((_fontsParsed_value = fontsParsed[value]) === null || _fontsParsed_value === void 0 ? void 0 : _fontsParsed_value.family) || value, lastFontFamilyToken = value, hasSet = true;
          break;
        }
        case "fontSize":
        case "lineHeight":
        case "letterSpacing":
        case "fontWeight": {
          var fam = fontFamily || conf2.defaultFontToken;
          if (fam) {
            var _font_, fontsParsed1 = (context2 == null ? void 0 : context2.language) ? getFontsForLanguage(conf2.fontsParsed, context2.language) : conf2.fontsParsed, font = fontsParsed1[fam] || fontsParsed1[conf2.defaultFontToken];
            valOrVar = (font == null || (_font_ = font[fontShorthand[key] || key]) === null || _font_ === void 0 ? void 0 : _font_[value]) || value, hasSet = true;
          }
          break;
        }
      }
      for (var cat in tokenCategories) if (key in tokenCategories[cat]) {
        var _tokensParsed_cat, res = (_tokensParsed_cat = tokensParsed[cat]) === null || _tokensParsed_cat === void 0 ? void 0 : _tokensParsed_cat[value];
        res != null ? (valOrVar = res, hasSet = true) : false;
      }
    }
    if (!hasSet) {
      var spaceVar = tokensParsed.space[value];
      spaceVar != null && (valOrVar = spaceVar, hasSet = true);
    }
  }
  if (hasSet) {
    var out = resolveVariableValue(key, valOrVar, resolveAs);
    return out;
  }
};
function resolveVariableValue(key, valOrVar, resolveValues) {
  if (resolveValues === "none") return valOrVar;
  if (isVariable(valOrVar)) {
    if (resolveValues === "value") return valOrVar.val;
    var get = valOrVar == null ? void 0 : valOrVar.get;
    if (key !== "shadowColor" && typeof get == "function") {
      var resolveDynamicFor = resolveValues === "web" ? "web" : void 0;
      return get(resolveDynamicFor);
    }
    return valOrVar.val;
  }
  return valOrVar;
}
var sortString = function(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
};
function _type_of$6(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var conf, styleOriginalValues = /* @__PURE__ */ new WeakMap();
function normalizeGroupKey(key, groupContext) {
  var parts = key.split("-"), plen = parts.length;
  if (
    // check if its actually a simple group selector to avoid breaking selectors
    plen === 2 || plen === 3 && pseudoPriorities[parts[parts.length - 1]]
  ) {
    var name = parts[1];
    if (groupContext && !groupContext[name]) return key.replace("$group-", "$group-true-");
  }
  return key;
}
function isValidStyleKey(key, validStyles2, accept) {
  return key in validStyles2 ? true : accept && key in accept;
}
var getSplitStyles = function(props, staticConfig, theme, themeName, componentState, styleProps2, parentSplitStyles, componentContext, groupContext, elementType, startedUnhydrated, debug) {
  var _loop2 = function(keyOg2) {
    var keyInit = keyOg2, valInit = props[keyInit];
    if (keyInit === "children") return viewProps[keyInit] = valInit, "continue";
    if (keyInit === "jestAnimatedStyle") return "continue";
    if (accept) {
      var accepted = accept[keyInit];
      if ((accepted === "style" || accepted === "textStyle") && valInit && (typeof valInit > "u" ? "undefined" : _type_of$6(valInit)) === "object") return viewProps[keyInit] = getSubStyle(styleState, keyInit, valInit, styleProps2.noClass), "continue";
    }
    if (disableExpandShorthands || keyInit in shorthands && (keyInit = shorthands[keyInit]), keyInit === "className") return "continue";
    if (keyInit in skipProps && !noSkip && !isHOC) {
      return "continue";
    }
    var isValidStyleKeyInit = isValidStyleKey(keyInit, validStyles$1, accept);
    if (!isValidStyleKeyInit) {
      if (!isAndroid && keyInit === "elevationAndroid") return "continue";
      if (keyInit === "userSelect") keyInit = "selectable", valInit = valInit !== "none";
      else if (keyInit.startsWith("data-")) return "continue";
    }
    if (keyInit === "dataSet") {
      for (var keyInit1 in valInit) viewProps[`data-${hyphenate(keyInit1)}`] = valInit[keyInit1];
      return "continue";
    }
    var isVariant = !isValidStyleKeyInit && variants2 && keyInit in variants2, isStyleLikeKey = isValidStyleKeyInit || isVariant, isPseudo = keyInit in validPseudoKeys, isMedia = !isStyleLikeKey && !isPseudo ? getMediaKey(keyInit) : false, isMediaOrPseudo = !!(isMedia || isPseudo);
    isMediaOrPseudo && isMedia === "group" && (keyInit = normalizeGroupKey(keyInit, groupContext));
    var isStyleProp = isValidStyleKeyInit || isMediaOrPseudo || isVariant && !noExpand;
    if (isStyleProp && (asChild === "except-style" || asChild === "except-style-web")) return "continue";
    var shouldPassProp = !isStyleProp && isHOC || // is in parent variants
    isHOC && parentVariants && keyInit in parentVariants || (inlineProps == null ? void 0 : inlineProps.has(keyInit)), parentVariant = parentVariants == null ? void 0 : parentVariants[keyInit], isHOCShouldPassThrough = !!(isHOC && (isValidStyleKeyInit || isMediaOrPseudo || parentVariant || keyInit in skipProps)), shouldPassThrough = shouldPassProp || isHOCShouldPassThrough;
    if (shouldPassThrough && (passDownProp(viewProps, keyInit, valInit, isMediaOrPseudo), !isVariant)) return "continue";
    if (!noSkip && keyInit in skipProps) return "continue";
    (isText || isInput) && valInit && (keyInit === "fontFamily" || keyInit === shorthands.fontFamily) && valInit in conf.fontsParsed && (styleState.fontFamily = valInit);
    var disablePropMap = isMediaOrPseudo || !isStyleLikeKey;
    if (propMapper(keyInit, valInit, styleState, disablePropMap, function(key4, val2, originalVal) {
      var _parentStaticConfig_variants, isStyledContextProp = styledContext && key4 in styledContext;
      if (!isHOC && disablePropMap && !isStyledContextProp && !isMediaOrPseudo) {
        viewProps[key4] = val2;
        return;
      }
      if (val2 != null) {
        if (key4 === "pointerEvents") {
          viewProps[key4] = val2;
          return;
        }
        if (!isHOC && isValidStyleKey(key4, validStyles$1, accept) || isAndroid && key4 === "elevation") {
          mergeStyle(styleState, key4, val2, 1, false, originalVal);
          return;
        }
        if (isPseudo = key4 in validPseudoKeys, isMedia = isPseudo ? false : getMediaKey(key4), isMediaOrPseudo = !!(isMedia || isPseudo), isVariant = variants2 && key4 in variants2, isMedia === "group" && (key4 = normalizeGroupKey(key4, groupContext)), (inlineProps == null ? void 0 : inlineProps.has(key4)) || process.env.IS_STATIC === "is_static" && (inlineWhenUnflattened == null ? void 0 : inlineWhenUnflattened.has(key4))) {
          var _props_key;
          viewProps[key4] = (_props_key = props[key4]) !== null && _props_key !== void 0 ? _props_key : val2;
        }
        var shouldPassThrough2 = styleProps2.noExpand && isPseudo || isHOC && (isMediaOrPseudo || (parentStaticConfig == null || (_parentStaticConfig_variants = parentStaticConfig.variants) === null || _parentStaticConfig_variants === void 0 ? void 0 : _parentStaticConfig_variants[keyInit]));
        if (shouldPassThrough2) {
          passDownProp(viewProps, key4, val2, isMediaOrPseudo);
          return;
        }
        if (isPseudo) {
          if (!val2) return;
          var pseudoStyleObject = getSubStyle(styleState, key4, val2, styleProps2.noClass && process.env.IS_STATIC !== "is_static");
          {
            var _pseudos, _key;
            if (pseudos || (pseudos = {}), (_pseudos = pseudos)[_key = key4] || (_pseudos[_key] = {}), process.env.IS_STATIC === "is_static") {
              Object.assign(pseudos[key4], pseudoStyleObject);
              return;
            }
          }
          var descriptor = pseudoDescriptors[key4], isEnter = key4 === "enterStyle", isExit = key4 === "exitStyle";
          if (!descriptor) return;
          {
            var descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = componentState[descriptorKey] === false;
            isExit && (isDisabled2 = !styleProps2.isExiting), isEnter && componentState.unmounted === false && (isDisabled2 = true);
            var importance = descriptor.priority, pseudoOriginalValues = styleOriginalValues.get(pseudoStyleObject);
            for (var pkey in pseudoStyleObject) {
              var _$val = pseudoStyleObject[pkey];
              if (isDisabled2) applyDefaultStyle(pkey, styleState);
              else {
                var curImportance = styleState.usedKeys[pkey] || 0, shouldMerge = importance >= curImportance;
                if (shouldMerge) {
                  if (process.env.IS_STATIC === "is_static") {
                    var _pseudos1, _key1;
                    pseudos || (pseudos = {}), (_pseudos1 = pseudos)[_key1 = key4] || (_pseudos1[_key1] = {}), pseudos[key4][pkey] = _$val;
                  }
                  mergeStyle(styleState, pkey, _$val, importance, false, pseudoOriginalValues == null ? void 0 : pseudoOriginalValues[pkey]);
                }
              }
            }
            if (!isDisabled2) for (var _$key in val2) {
              var k = shorthands[_$key] || _$key;
              styleState.usedKeys[k] = Math.max(importance, styleState.usedKeys[k] || 0);
            }
          }
          return;
        }
        if (isMedia) {
          if (!val2) return;
          val2.space;
          var mediaKeyShort = key4.slice(isMedia == "theme" ? 7 : 1);
          if (hasMedia || (hasMedia = true), (!hasMedia || typeof hasMedia == "boolean") && (hasMedia = /* @__PURE__ */ new Set()), hasMedia.add(mediaKeyShort), isMedia === "platform" && !isActivePlatform(key4)) return;
          var priority = mediaStylesSeen;
          if (mediaStylesSeen += 1, shouldDoClasses) ;
          else {
            let mergeMediaStyle2 = function(key5, val3, originalVal2) {
              var _styleState4;
              (_styleState4 = styleState).style || (_styleState4.style = {});
              var didMerge = mergeMediaByImportance(styleState, mediaKeyShort, key5, val3, mediaState[mediaKeyShort], importanceBump, debug, originalVal2);
              didMerge && key5 === "fontFamily" && (styleState.fontFamily = mediaStyle1.fontFamily);
            };
            var isThemeMedia = isMedia === "theme", isGroupMedia = isMedia === "group", isPlatformMedia = isMedia === "platform";
            if (!isThemeMedia && !isPlatformMedia && !isGroupMedia) {
              if (!mediaState[mediaKeyShort]) {
                return;
              }
            }
            var mediaStyle1 = getSubStyle(styleState, key4, val2, true), importanceBump = 0;
            if (isThemeMedia) {
              if (dynamicThemeAccess = true, isIos && getSetting("fastSchemeChange")) {
                var _styleState3;
                (_styleState3 = styleState).style || (_styleState3.style = {});
                var scheme = mediaKeyShort, oppositeScheme = getOppositeScheme(mediaKeyShort), themeOriginalValues = styleOriginalValues.get(mediaStyle1);
                for (var subKey1 in mediaStyle1) {
                  var _$val1 = extractValueFromDynamic(mediaStyle1[subKey1], scheme), oppositeVal = extractValueFromDynamic(styleState.style[subKey1], oppositeScheme);
                  mediaStyle1[subKey1] = getDynamicVal({
                    scheme,
                    val: _$val1,
                    oppositeVal
                  }), mergeStyle(styleState, subKey1, mediaStyle1[subKey1], priority, false, themeOriginalValues == null ? void 0 : themeOriginalValues[subKey1]);
                }
              } else if (!(themeName === mediaKeyShort || themeName.startsWith(mediaKeyShort))) return;
            } else if (isGroupMedia) {
              var _groupContext_groupName, _componentState_group, groupInfo = getGroupPropParts(mediaKeyShort), groupName = groupInfo.name, groupState = groupContext == null || (_groupContext_groupName = groupContext[groupName]) === null || _groupContext_groupName === void 0 ? void 0 : _groupContext_groupName.state, groupPseudoKey = groupInfo.pseudo, groupMediaKey = groupInfo.media;
              if (!groupState) {
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set());
                return;
              }
              var componentGroupState = (_componentState_group = componentState.group) === null || _componentState_group === void 0 ? void 0 : _componentState_group[groupName];
              if (groupMediaKey) {
                mediaGroups || (mediaGroups = /* @__PURE__ */ new Set()), mediaGroups.add(groupMediaKey);
                var mediaState1 = componentGroupState == null ? void 0 : componentGroupState.media, isActive = mediaState1 == null ? void 0 : mediaState1[groupMediaKey];
                if (!mediaState1 && groupState.layout && (isActive = mediaKeyMatch(groupMediaKey, groupState.layout)), !isActive) {
                  for (var pkey1 in mediaStyle1) applyDefaultStyle(pkey1, styleState);
                  return;
                }
                importanceBump = 2;
              }
              if (groupPseudoKey) {
                var _this;
                pseudoGroups || (pseudoGroups = /* @__PURE__ */ new Set()), pseudoGroups.add(groupName);
                var componentGroupPseudoState = (_this = componentGroupState || (groupContext == null ? void 0 : groupContext[groupName].state)) === null || _this === void 0 ? void 0 : _this.pseudo, isActive1 = componentGroupPseudoState == null ? void 0 : componentGroupPseudoState[groupPseudoKey], priority1 = pseudoPriorities[groupPseudoKey];
                if (!isActive1) {
                  for (var pkey2 in mediaStyle1) applyDefaultStyle(pkey2, styleState);
                  return;
                }
                importanceBump = priority1;
              }
            }
            var mediaOriginalValues = styleOriginalValues.get(mediaStyle1);
            for (var subKey2 in mediaStyle1) {
              if (subKey2 === "space") {
                space = valInit.space;
                continue;
              }
              if (subKey2[0] === "$") {
                if (!isActivePlatform(subKey2) || !isActiveTheme(subKey2, themeName)) continue;
                var subOriginalValues = styleOriginalValues.get(mediaStyle1[subKey2]);
                for (var subSubKey in mediaStyle1[subKey2]) mergeMediaStyle2(subSubKey, mediaStyle1[subKey2][subSubKey], subOriginalValues == null ? void 0 : subOriginalValues[subSubKey]);
              } else mergeMediaStyle2(subKey2, mediaStyle1[subKey2], mediaOriginalValues == null ? void 0 : mediaOriginalValues[subKey2]);
            }
          }
          return;
        }
        if (!isVariant) {
          if (isStyledContextProp) return;
          viewProps[key4] = val2;
        }
      }
    }), false) ;
  };
  conf = conf || getConfig();
  (componentContext == null ? void 0 : componentContext.animationDriver) || conf.animations;
  if (props.passThrough) return null;
  var {
    shorthands
  } = conf, {
    isHOC,
    isText,
    isInput,
    variants: variants2,
    isReactNative,
    inlineProps,
    inlineWhenUnflattened,
    parentStaticConfig,
    acceptsClassName
  } = staticConfig, viewProps = {}, mediaState = styleProps2.mediaState || exports.mediaState, shouldDoClasses = acceptsClassName && isWeb, rulesToInsert = void 0, classNames = {}, pseudos = null, space = props.space, hasMedia = false, dynamicThemeAccess, pseudoGroups, mediaGroups;
  props.className || "";
  var mediaStylesSeen = 0, validStyles$1 = staticConfig.validStyles || (staticConfig.isText || staticConfig.isInput ? stylePropsText : validStyles);
  var styleState = {
    classNames,
    conf,
    props,
    styleProps: styleProps2,
    componentState,
    staticConfig,
    style: null,
    theme,
    usedKeys: {},
    viewProps,
    context: componentContext,
    debug
  };
  if (process.env.IS_STATIC === "is_static") {
    var {
      fallbackProps
    } = styleProps2;
    fallbackProps && (styleState.props = new Proxy(props, {
      get(_, key4, val2) {
        return Reflect.has(props, key4) ? Reflect.get(props, key4) : Reflect.get(fallbackProps, key4);
      }
    }));
  }
  var {
    asChild
  } = props, {
    accept
  } = staticConfig, {
    noSkip,
    disableExpandShorthands,
    noExpand,
    styledContext
  } = styleProps2, {
    webContainerType
  } = conf.settings, parentVariants = parentStaticConfig == null ? void 0 : parentStaticConfig.variants;
  for (var keyOg in props) _loop2(keyOg);
  var avoidNormalize = styleProps2.noNormalize === false;
  if (!avoidNormalize) {
    if (styleState.style && (fixStyles(styleState.style), !styleProps2.noExpand && !styleProps2.noMergeStyle && isWeb), styleState.flatTransforms) {
      var _styleState;
      (_styleState = styleState).style || (_styleState.style = {}), mergeFlatTransforms(styleState.style, styleState.flatTransforms);
    }
  }
  var styleProp = props.style;
  if (!styleProps2.noMergeStyle && styleProp) if (isHOC) viewProps.style = normalizeStyle(styleProp);
  else for (var isArray2 = Array.isArray(styleProp), len = isArray2 ? styleProp.length : 1, i = 0; i < len; i++) {
    var style = isArray2 ? styleProp[i] : styleProp;
    if (style) if (style.$$css) Object.assign(styleState.classNames, style);
    else {
      var _styleState2;
      (_styleState2 = styleState).style || (_styleState2.style = {}), Object.assign(styleState.style, normalizeStyle(style));
    }
  }
  if (viewProps.tabIndex === 0) {
    var _viewProps1, _accessible1;
    (_accessible1 = (_viewProps1 = viewProps).accessible) !== null && _accessible1 !== void 0 || (_viewProps1.accessible = true);
  }
  var style1 = styleState.style;
  if (style1 == null ? void 0 : style1.fontFamily) {
    var _getFont, faceInfo = (_getFont = getFont(style1.fontFamily)) === null || _getFont === void 0 ? void 0 : _getFont.face;
    if (faceInfo) {
      var _faceInfo_style_fontWeight_, _faceInfo_style_fontWeight, overrideFace = (_faceInfo_style_fontWeight = faceInfo[style1.fontWeight]) === null || _faceInfo_style_fontWeight === void 0 || (_faceInfo_style_fontWeight_ = _faceInfo_style_fontWeight[style1.fontStyle || "normal"]) === null || _faceInfo_style_fontWeight_ === void 0 ? void 0 : _faceInfo_style_fontWeight_.val;
      overrideFace && (style1.fontFamily = overrideFace, styleState.fontFamily = overrideFace, delete style1.fontWeight, delete style1.fontStyle);
    }
  }
  var result = {
    space,
    hasMedia,
    fontFamily: styleState.fontFamily,
    viewProps,
    style: styleState.style,
    pseudos,
    classNames,
    rulesToInsert,
    dynamicThemeAccess,
    pseudoGroups,
    mediaGroups,
    overriddenContextProps: styleState.overriddenContextProps
  }, asChildExceptStyleLike = asChild === "except-style" || asChild === "except-style-web";
  if (!styleProps2.noMergeStyle && !asChildExceptStyleLike) {
    var style2 = styleState.style;
    style2 && (viewProps.style = style2);
  }
  return result;
};
function mergeFlatTransforms(target, flatTransforms) {
  Object.entries(flatTransforms).sort(function(param, param1) {
    var [a] = param, [b2] = param1;
    return sortString(a, b2);
  }).forEach(function(param) {
    var [key, val] = param;
    mergeTransform(target, key, val, true);
  });
}
function mergeStyle(styleState, key, val, importance) {
  var originalVal = arguments.length > 5 ? arguments[5] : void 0, _staticConfig_context, _staticConfig_parentStaticConfig_context, _staticConfig_parentStaticConfig, {
    viewProps,
    styleProps: styleProps2,
    staticConfig,
    usedKeys
  } = styleState, existingImportance = usedKeys[key] || 0;
  if (!(existingImportance > importance)) {
    var contextProps = ((_staticConfig_context = staticConfig.context) === null || _staticConfig_context === void 0 ? void 0 : _staticConfig_context.props) || ((_staticConfig_parentStaticConfig = staticConfig.parentStaticConfig) === null || _staticConfig_parentStaticConfig === void 0 || (_staticConfig_parentStaticConfig_context = _staticConfig_parentStaticConfig.context) === null || _staticConfig_parentStaticConfig_context === void 0 ? void 0 : _staticConfig_parentStaticConfig_context.props);
    if (contextProps && key in contextProps) {
      var _styleState_originalContextPropValues, _styleState;
      (_styleState = styleState).overriddenContextProps || (_styleState.overriddenContextProps = {});
      var originalFromState = (_styleState_originalContextPropValues = styleState.originalContextPropValues) === null || _styleState_originalContextPropValues === void 0 ? void 0 : _styleState_originalContextPropValues[key], _ref;
      styleState.overriddenContextProps[key] = (_ref = originalVal != null ? originalVal : originalFromState) !== null && _ref !== void 0 ? _ref : val;
    }
    if (key in stylePropsTransform) {
      var _styleState1;
      (_styleState1 = styleState).flatTransforms || (_styleState1.flatTransforms = {}), usedKeys[key] = importance, styleState.flatTransforms[key] = val;
    } else {
      var shouldNormalize = isWeb, out = shouldNormalize ? normalizeValueWithProperty$1(val) : val;
      if (
        // accept is for props not styles
        staticConfig.accept && key in staticConfig.accept
      ) viewProps[key] = out;
      else {
        var _styleState2;
        (_styleState2 = styleState).style || (_styleState2.style = {}), usedKeys[key] = importance, styleState.style[key] = // if you dont do this you'll be passing props.transform arrays directly here and then mutating them
        // if theres any flatTransforms later, causing issues (mutating props is bad, in strict mode styles get borked)
        key === "transform" && Array.isArray(out) ? [...out] : out;
      }
    }
  }
}
var getSubStyle = function(styleState, subKey, styleIn, avoidMergeTransform) {
  var _loop2 = function(key1) {
    var val = styleIn[key1];
    key1 = conf2.shorthands[key1] || key1;
    var shouldSkip = !staticConfig.isHOC && key1 in skipProps && !styleProps2.noSkip;
    if (shouldSkip) return key = key1, "continue";
    propMapper(key1, val, styleState, false, function(skey, sval, originalVal) {
      originalVal !== void 0 && (originalValues || (originalValues = {}), originalValues[skey] = originalVal), skey in validPseudoKeys && (sval = getSubStyle(styleState, skey, sval, avoidMergeTransform)), !avoidMergeTransform && skey in stylePropsTransform ? mergeTransform(styleOut, skey, sval) : styleOut[skey] = styleProps2.noNormalize ? sval : normalizeValueWithProperty$1(sval);
    }), key = key1;
  }, {
    staticConfig,
    conf: conf2,
    styleProps: styleProps2
  } = styleState, styleOut = {}, originalValues;
  for (var key in styleIn) _loop2(key);
  if (!avoidMergeTransform) {
    if (Array.isArray(styleOut.transform)) {
      var _styleState_style, parentTransform = (_styleState_style = styleState.style) === null || _styleState_style === void 0 ? void 0 : _styleState_style.transform;
      parentTransform && (styleOut.transform = [...parentTransform, ...styleOut.transform]);
    }
    styleState.flatTransforms && mergeFlatTransforms(styleOut, styleState.flatTransforms);
  }
  return styleProps2.noNormalize || fixStyles(styleOut), originalValues && styleOriginalValues.set(styleOut, originalValues), styleOut;
}, useSplitStyles = function(a, b2, c, d, e2, f, g, h2, i, j, k, l) {
  var res = getSplitStyles(a, b2, c, d, e2, f, g, h2, i, j, k, l);
  return res;
};
var defaultColor = process.env.TAMAGUI_DEFAULT_COLOR || "rgba(0,0,0,0)", animatableDefaults = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(tokenCategories.color).map(function(param) {
  var [k, v] = param;
  return [k, defaultColor];
}))), {
  opacity: 1,
  scale: 1,
  rotate: "0deg",
  rotateY: "0deg",
  rotateX: "0deg",
  x: 0,
  y: 0,
  borderRadius: 0
}), lowercaseHyphenate = function(match) {
  return `-${match.toLowerCase()}`;
}, hyphenate = function(str) {
  return str.replace(/[A-Z]/g, lowercaseHyphenate);
}, mergeTransform = function(obj, key, val) {
  var backwards = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, _obj;
  typeof obj.transform != "string" && ((_obj = obj).transform || (_obj.transform = []), obj.transform[backwards ? "unshift" : "push"]({
    [mapTransformKeys[key] || key]: val
  }));
}, mapTransformKeys = {
  x: "translateX",
  y: "translateY"
};
function passDownProp(viewProps, key, val) {
  var shouldMergeObject = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (shouldMergeObject) {
    var next = __spreadValues(__spreadValues({}, viewProps[key]), val);
    delete viewProps[key], viewProps[key] = next;
  } else viewProps[key] = val;
}
function mergeMediaByImportance(styleState, mediaKey, key, value, isSizeMedia, importanceBump, debugProp, originalVal) {
  styleState.usedKeys;
  var importance = getMediaImportanceIfMoreImportant(mediaKey, key, styleState, isSizeMedia);
  if (importanceBump && (importance = (importance || 0) + importanceBump), importance === null) return false;
  if (key in pseudoDescriptors) {
    var descriptor = pseudoDescriptors[key], descriptorKey = descriptor.stateKey || descriptor.name, isDisabled2 = styleState.componentState[descriptorKey] === false;
    if (isDisabled2) return false;
    var pseudoOriginalValues = styleOriginalValues.get(value);
    for (var subKey in value) mergeStyle(styleState, subKey, value[subKey], importance, false, pseudoOriginalValues == null ? void 0 : pseudoOriginalValues[subKey]);
  } else mergeStyle(styleState, key, value, importance, false, originalVal);
  return true;
}
function normalizeStyle(style) {
  var out = {};
  for (var key in style) {
    var val = style[key];
    key in stylePropsTransform ? mergeTransform(out, key, val) : out[key] = normalizeValueWithProperty$1(val);
  }
  return fixStyles(out), out;
}
function applyDefaultStyle(pkey, styleState) {
  var defaultValues = animatableDefaults[pkey];
  defaultValues != null && !(pkey in styleState.usedKeys) && (!styleState.style || !(pkey in styleState.style)) && mergeStyle(styleState, pkey, defaultValues, 1);
}
function setElementProps(element) {
  element && !element.getBoundingClientRect && (element.getBoundingClientRect = function() {
    if (element.unstable_getBoundingClientRect != null) return element.unstable_getBoundingClientRect();
  });
}
var subscribeToContextGroup = function(props) {
  var {
    pseudoGroups,
    mediaGroups,
    groupContext
  } = props;
  if (pseudoGroups || mediaGroups) {
    var disposables = /* @__PURE__ */ new Set();
    if (pseudoGroups) for (var _i = 0, _iter = [...pseudoGroups]; _i < _iter.length; _i++) {
      var name = _iter[_i];
      disposables.add(createGroupListener(name, props));
    }
    if (mediaGroups) for (var _i1 = 0, _iter1 = [...mediaGroups]; _i1 < _iter1.length; _i1++) {
      var name1 = _iter1[_i1];
      disposables.add(createGroupListener(name1, props));
    }
    return function() {
      disposables.forEach(function(d) {
        return d();
      });
    };
  }
}, createGroupListener = function(name, param) {
  var {
    setStateShallow,
    pseudoGroups,
    mediaGroups,
    groupContext
  } = param, parent = groupContext == null ? void 0 : groupContext[name];
  if (!parent) return function() {
  };
  var dispose2 = parent.subscribe(function(param2) {
    var {
      layout,
      pseudo
    } = param2;
    setStateShallow(function(prev) {
      var _prev_group, didChange = false, group = ((_prev_group = prev.group) === null || _prev_group === void 0 ? void 0 : _prev_group[name]) || {
        pseudo: {},
        media: {}
      };
      if (pseudo && (pseudoGroups == null ? void 0 : pseudoGroups.has(name))) {
        var _group;
        (_group = group).pseudo || (_group.pseudo = {});
        var next = mergeIfNotShallowEqual(group.pseudo, pseudo);
        next !== group.pseudo && (Object.assign(group.pseudo, pseudo), didChange = true);
      } else if (layout && mediaGroups) {
        var _group1;
        (_group1 = group).media || (_group1.media = {});
        var mediaState = getMediaState(mediaGroups, layout), next1 = mergeIfNotShallowEqual(group.media, mediaState);
        next1 !== group.media && (Object.assign(group.media, next1), didChange = true);
      }
      return didChange ? {
        group: __spreadProps(__spreadValues({}, prev.group), {
          [name]: group
        })
      } : prev;
    });
  });
  return function() {
    dispose2(), setStateShallow({
      group: {}
    });
  };
};
var Theme = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  if (props.disable) return props.children;
  var {
    passThrough
  } = props, isRoot = !!props._isRoot, [_, themeState] = useThemeWithState(props, isRoot), disableDirectChildTheme = props["disable-child-theme"], finalChildren = disableDirectChildTheme ? React.Children.map(props.children, function(child) {
    return passThrough ? child : /* @__PURE__ */ React.cloneElement(child, {
      "data-disable-theme": true
    });
  }) : props.children;
  if (ref) try {
    React.Children.only(finalChildren), finalChildren = /* @__PURE__ */ React.cloneElement(finalChildren, {
      ref
    });
  } catch (e2) {
  }
  var stateRef = React.useRef({
    hasEverThemed: false
  });
  return getThemedChildren(themeState, finalChildren, props, isRoot, stateRef, passThrough);
});
Theme.avoidForwardRef = true;
function getThemedChildren(themeState, children, props) {
  var isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, stateRef = arguments.length > 4 ? arguments[4] : void 0, passThrough = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false, {
    shallow,
    forceClassName
  } = props, state = stateRef.current, hasEverThemed = state.hasEverThemed, shouldRenderChildrenWithTheme = hasEverThemed || themeState.isNew || isRoot || hasThemeUpdatingProps(props);
  if (!shouldRenderChildrenWithTheme) return children;
  children = /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeStateContext.Provider, {
    value: themeState.id,
    children
  });
  var {
    isInverse,
    name
  } = themeState, requiresExtraWrapper = isInverse || forceClassName;
  if (state.hasEverThemed || (state.hasEverThemed = true), (requiresExtraWrapper || // if the theme is exactly dark or light, its likely to change between dark/light
  // and that would require wrapping which would re-parent, so to avoid re-parenting do this
  themeState.name === "dark" || themeState.name === "light") && (state.hasEverThemed = "wrapped"), shallow && themeState.parentId) {
    var parentState = getThemeState(themeState.isNew ? themeState.id : themeState.parentId);
    if (!parentState) throw new Error("010");
    children = React.Children.toArray(children).map(function(child) {
      return /* @__PURE__ */ React.isValidElement(child) ? passThrough ? child : /* @__PURE__ */ React.cloneElement(child, void 0, /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
        name: parentState.name,
        children: child.props.children
      })) : child;
    });
  }
  if (forceClassName === false) return children;
  return children;
}
function themeable(Component, staticConfig) {
  var optimize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, withThemeComponent = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var _a = props, {
      themeInverse,
      theme,
      componentName,
      themeReset
    } = _a, rest = __objRest(_a, [
      "themeInverse",
      "theme",
      "componentName",
      "themeReset"
    ]), overriddenContextProps, context2 = staticConfig == null ? void 0 : staticConfig.context;
    if (context2) for (var key in context2.props) {
      var val = props[key];
      val !== void 0 && (overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = val);
    }
    var element = (
      // @ts-expect-error its ok
      /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadProps(__spreadValues({
        ref
      }, rest), {
        "data-disable-theme": true
      }))
    ), filteredProps = null, compName = componentName || (staticConfig == null ? void 0 : staticConfig.componentName);
    if (compName && (filteredProps || (filteredProps = {}), filteredProps.componentName = compName), "debug" in props && (filteredProps || (filteredProps = {}), filteredProps.debug = props.debug), "theme" in props && (filteredProps || (filteredProps = {}), filteredProps.name = props.theme), "themeInverse" in props && (filteredProps || (filteredProps = {}), filteredProps.inverse = props.themeInverse), "themeReset" in props && (filteredProps || (filteredProps = {}), filteredProps.reset = themeReset), optimize && !filteredProps) return element;
    var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, __spreadProps(__spreadValues({
      "disable-child-theme": true
    }, filteredProps), {
      children: element
    }));
    if (context2) {
      var Provider = context2.Provider, contextValue = React.useContext(context2);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues(__spreadValues({}, contextValue), overriddenContextProps), {
        children: contents
      }));
    }
    return contents;
  }), withTheme = withThemeComponent;
  return withTheme.displayName = `Themed(${(Component == null ? void 0 : Component.displayName) || (Component == null ? void 0 : Component.name) || "Anonymous"})`, withTheme;
}
function getStyleTags(styles2) {
}
var ClientOnlyContext = /* @__PURE__ */ React.createContext(false), ClientOnly = function(param) {
  var {
    children,
    enabled
  } = param, existingValue = React.useContext(ClientOnlyContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnlyContext.Provider, {
    value: enabled != null ? enabled : existingValue,
    children
  });
};
var useIsClientOnly = function() {
  return React__namespace.useContext(ClientOnlyContext);
};
function useDidFinishSSR() {
  React__namespace.useContext(ClientOnlyContext);
  return true;
}
function _type_of$5(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var useComponentState = function(props, animationDriver, staticConfig, config) {
  var _animationDriver_usePresence, isHydrated = useDidFinishSSR(), needsHydration = !useIsClientOnly(), useAnimations = (animationDriver == null ? void 0 : animationDriver.isStub) ? void 0 : animationDriver == null ? void 0 : animationDriver.useAnimations, {
    isHOC
  } = staticConfig, stateRef = React.useRef(
    // performance: avoid creating object every render
    void 0
  );
  stateRef.current || (stateRef.current = {
    startedUnhydrated: needsHydration && !isHydrated
  });
  var hasAnimationProp = !!(!isHOC && "animation" in props || props.style && hasAnimatedStyleValue(props.style)), supportsCSS = animationDriver == null ? void 0 : animationDriver.supportsCSS, curStateRef = stateRef.current;
  !needsHydration && hasAnimationProp && (curStateRef.hasAnimated = true);
  var willBeAnimatedClient = (function() {
    var next = !!(hasAnimationProp && !isHOC && useAnimations);
    return !!(next || curStateRef.hasAnimated);
  })(), willBeAnimated = willBeAnimatedClient;
  willBeAnimated && !curStateRef.hasAnimated && (curStateRef.hasAnimated = true);
  var {
    disableClassName
  } = props, presence = !isHOC && willBeAnimated && props.animatePresence !== false && (animationDriver == null || (_animationDriver_usePresence = animationDriver.usePresence) === null || _animationDriver_usePresence === void 0 ? void 0 : _animationDriver_usePresence.call(animationDriver)) || null, presenceState = presence == null ? void 0 : presence[2], isExiting = (presenceState == null ? void 0 : presenceState.isPresent) === false, isEntering = (presenceState == null ? void 0 : presenceState.isPresent) === true && presenceState.initial !== false, hasEnterStyle = !!props.enterStyle, hasAnimationThatNeedsHydrate = hasAnimationProp && !isHydrated, canImmediatelyEnter = hasEnterStyle || isEntering, shouldEnter = !isHOC && (hasEnterStyle || isEntering || hasAnimationThatNeedsHydrate || // disableClassName doesnt work server side, only client, so needs hydrate
  // this is just for a better ux, supports css variables for light/dark, media queries, etc
  disableClassName), initialState = shouldEnter ? (
    // on the very first render we switch all spring animation drivers to css rendering
    // this is because we need to use css variables, which they don't support to do proper SSR
    // without flickers of the wrong colors.
    // but once we do that initial hydration and we are in client side rendering mode,
    // we can avoid the extra re-render on mount
    canImmediatelyEnter ? defaultComponentStateShouldEnter : defaultComponentState
  ) : defaultComponentStateMounted, disabled = isDisabled(props);
  disabled != null && (initialState.disabled = disabled);
  var states2 = React.useState(initialState), state = props.forceStyle ? __spreadProps(__spreadValues({}, states2[0]), {
    [props.forceStyle]: true
  }) : states2[0], setState = states2[1], isAnimated = willBeAnimated;
  disabled !== state.disabled && (disabled && Object.assign(state, defaultComponentStateMounted), state.disabled = disabled, setState(function(_) {
    return __spreadValues({}, state);
  }));
  var groupName = props.group, setStateShallow = useCreateShallowSetState(setState, props.debug);
  if (presenceState && isAnimated && isHydrated && staticConfig.variants) {
    var {
      enterVariant,
      exitVariant,
      enterExitVariant,
      custom
    } = presenceState;
    isObj(custom) && Object.assign(props, custom);
    var exv = exitVariant != null ? exitVariant : enterExitVariant, env = enterVariant != null ? enterVariant : enterExitVariant;
    state.unmounted && env && staticConfig.variants[env] ? props[env] = true : isExiting && exv && (props[exv] = exitVariant !== enterExitVariant);
  }
  var noClass = !isWeb;
  return {
    startedUnhydrated: curStateRef.startedUnhydrated,
    curStateRef,
    disabled,
    groupName,
    hasAnimationProp,
    hasEnterStyle,
    isAnimated,
    isExiting,
    isHydrated,
    presence,
    presenceState,
    setState,
    setStateShallow,
    noClass,
    state,
    stateRef,
    supportsCSS,
    willBeAnimated,
    willBeAnimatedClient
  };
};
function hasAnimatedStyleValue(style) {
  return Object.keys(style).some(function(k) {
    var val = style[k];
    return val && (typeof val > "u" ? "undefined" : _type_of$5(val)) === "object" && "_animation" in val;
  });
}
var isDisabled = function(props) {
  var _props_accessibilityState;
  return props.disabled || props.passThrough || ((_props_accessibilityState = props.accessibilityState) === null || _props_accessibilityState === void 0 ? void 0 : _props_accessibilityState.disabled) || props["aria-disabled"] || props.accessibilityDisabled || false;
};
var hooks = {};
function setupHooks(next) {
  Object.assign(hooks, next);
}
var is19 = React.version.startsWith("19."), Slot = /* @__PURE__ */ React.memo(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    children
  } = _a, slotProps = __objRest(_a, [
    "children"
  ]);
  if (/* @__PURE__ */ React.isValidElement(children)) {
    var mergedProps = mergeSlotProps(children, slotProps);
    return /* @__PURE__ */ React.cloneElement(children, children.type.avoidForwardRef ? mergedProps : __spreadProps(__spreadValues({}, mergedProps), {
      ref: composeRefs(forwardedRef, is19 ? children.props.ref : children.ref)
    }));
  }
  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
})), Slottable = function(param) {
  var {
    children
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
};
Slottable.displayName = "Slottable";
var pressMap = {};
function mergeSlotProps(child, slotProps) {
  var childProps = child.props, overrideProps = __spreadValues({}, childProps), isHTMLChild = typeof child.type == "string";
  if (isHTMLChild) for (var key in pressMap) key in slotProps && (slotProps[pressMap[key]] = slotProps[key], delete slotProps[key]);
  for (var propName in childProps) {
    var slotPropValue = slotProps[propName], childPropValue = childProps[propName];
    isHTMLChild && propName in pressMap && (propName = pressMap[propName], delete overrideProps[propName]);
    var isHandler = handleRegex.test(propName);
    isHandler ? overrideProps[propName] = composeEventHandlers(childPropValue, slotPropValue) : propName === "style" ? overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue) : propName === "className" && (overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" "));
  }
  return __spreadValues(__spreadValues({}, slotProps), overrideProps);
}
var handleRegex = /^on[A-Z]/;
var componentSetStates = /* @__PURE__ */ new Set(), avoidReRenderKeys = /* @__PURE__ */ new Set(["hover", "press", "pressIn", "group", "focus", "focusWithin", "media", "group"]);
var BaseText, BaseView, hasSetupBaseViews = false, lastInteractionWasKeyboard = {
  value: false
};
function createComponent(staticConfig) {
  var {
    componentName
  } = staticConfig, config = null, defaultProps2 = staticConfig.defaultProps;
  onConfiguredOnce(function(conf2) {
    if (config = conf2, componentName) {
      var _conf_defaultProps, defaultForComponent = (_conf_defaultProps = conf2.defaultProps) === null || _conf_defaultProps === void 0 ? void 0 : _conf_defaultProps[componentName];
      defaultForComponent && (defaultProps2 = __spreadValues(__spreadValues({}, defaultForComponent), defaultProps2));
    }
  });
  var {
    Component,
    isText,
    isZStack,
    isHOC
  } = staticConfig;
  var component = /* @__PURE__ */ React.forwardRef(function(propsIn, forwardedRef) {
    var _hooks_usePropsTransform, _hooks_useEvents, _config_animations;
    if (!hasSetupBaseViews) {
      var _hooks_getBaseViews;
      hasSetupBaseViews = true;
      var baseViews = (_hooks_getBaseViews = hooks.getBaseViews) === null || _hooks_getBaseViews === void 0 ? void 0 : _hooks_getBaseViews.call(hooks);
      baseViews && (BaseText = baseViews.Text, BaseView = baseViews.View);
    }
    if (propsIn["data-test-renders"]) {
      var _propsIn_datatestrenders, _current, _;
      (_ = (_propsIn_datatestrenders = propsIn["data-test-renders"])[_current = "current"]) !== null && _ !== void 0 || (_propsIn_datatestrenders[_current] = 0), propsIn["data-test-renders"].current += 1;
    }
    var {
      context: context2,
      isReactNative
    } = staticConfig, debugProp = propsIn.debug, styledContextValue = context2 ? React.useContext(context2) : void 0, overriddenContextProps = null;
    var props = propsIn;
    if (styledContextValue || defaultProps2) {
      var [nextProps, overrides] = mergeComponentProps(defaultProps2, styledContextValue, propsIn);
      nextProps && (props = nextProps), overriddenContextProps = overrides;
    }
    var componentName2 = props.componentName || staticConfig.componentName;
    var componentContext = React.useContext(ComponentContext), groupContextParent = React.useContext(GroupContext), animationDriver = componentContext.animationDriver, useAnimations = animationDriver == null ? void 0 : animationDriver.useAnimations, componentState = useComponentState(props, (animationDriver == null ? void 0 : animationDriver.isStub) ? null : animationDriver, staticConfig), {
      disabled,
      groupName,
      hasAnimationProp,
      hasEnterStyle,
      isAnimated,
      isExiting,
      isHydrated,
      presence,
      presenceState,
      setState,
      noClass,
      state,
      stateRef,
      supportsCSS,
      willBeAnimated,
      willBeAnimatedClient,
      startedUnhydrated
    } = componentState;
    hasAnimationProp && (animationDriver == null ? void 0 : animationDriver.avoidReRenders) && useIsomorphicLayoutEffect(function() {
      var pendingState = stateRef.current.nextState;
      pendingState && (stateRef.current.nextState = void 0, componentState.setStateShallow(pendingState));
    });
    var allGroupContexts = React.useMemo(function() {
      var _stateRef_current_group_listeners, _stateRef_current_group;
      if (!groupName || props.passThrough) return groupContextParent;
      var listeners2 = /* @__PURE__ */ new Set();
      return (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || (_stateRef_current_group_listeners = _stateRef_current_group.listeners) === null || _stateRef_current_group_listeners === void 0 || _stateRef_current_group_listeners.clear(), stateRef.current.group = {
        listeners: listeners2,
        emit(state2) {
          listeners2.forEach(function(l) {
            return l(state2);
          });
        },
        subscribe(cb) {
          return listeners2.add(cb), listeners2.size === 1 && setStateShallow({
            hasDynGroupChildren: true
          }), function() {
            listeners2.delete(cb), listeners2.size === 0 && setStateShallow({
              hasDynGroupChildren: false
            });
          };
        }
      }, __spreadProps(__spreadValues({}, groupContextParent), {
        [groupName]: {
          state: {
            pseudo: defaultComponentStateMounted
          },
          subscribe: function(listener) {
            var _stateRef_current_group2, dispose2 = (_stateRef_current_group2 = stateRef.current.group) === null || _stateRef_current_group2 === void 0 ? void 0 : _stateRef_current_group2.subscribe(listener);
            return function() {
              dispose2 == null ? void 0 : dispose2();
            };
          }
        }
      });
    }, [stateRef, groupName, groupContextParent]), setStateShallow = componentState.setStateShallow;
    var isTaggable = !Component || typeof Component == "string", tagProp = props.tag, element = Component, BaseTextComponent = BaseText || element || "span", BaseViewComponent = BaseView || element || "div", elementType = isText ? BaseTextComponent : BaseViewComponent;
    animationDriver && isAnimated && // this should really be behind another prop as it's not really related to
    // "needsWebStyles" basically with motion we just animate a plain div, but
    // we still have animated.View/Text for Sheet which wants to control
    // things declaratively
    !animationDriver.needsWebStyles && (elementType = animationDriver[isText ? "Text" : "View"] || elementType);
    var disableTheme = isHOC;
    props.themeShallow && (stateRef.current.themeShallow = true);
    var themeStateProps = {
      componentName: componentName2,
      disable: disableTheme,
      shallow: stateRef.current.themeShallow,
      debug: debugProp
    };
    if ("themeInverse" in props && (themeStateProps.inverse = props.themeInverse), "theme" in props && (themeStateProps.name = props.theme), typeof stateRef.current.isListeningToTheme == "boolean" && (themeStateProps.needsUpdate = function() {
      return !!stateRef.current.isListeningToTheme;
    }), themeStateProps.deopt = willBeAnimated, false) ;
    var [theme, themeState] = useThemeWithState(themeStateProps);
    elementType = Component || elementType;
    var mediaState = useMedia(componentContext);
    setDidGetVariableValue(false);
    var resolveValues = (
      // if HOC + mounted + has animation prop, resolve as value so it passes non-variable to child
      isAnimated && !supportsCSS || isHOC && state.unmounted == false && hasAnimationProp ? "value" : "auto"
    ), styleProps2 = {
      mediaState,
      noClass,
      resolveValues,
      isExiting,
      isAnimated,
      willBeAnimated,
      styledContext: styledContextValue
    }, themeName = (themeState == null ? void 0 : themeState.name) || "";
    var splitStyles = useSplitStyles(props, staticConfig, theme, themeName, state, styleProps2, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), isPassthrough = !splitStyles, contextForOverride = staticConfig.context;
    if (splitStyles == null ? void 0 : splitStyles.overriddenContextProps) {
      var _staticConfig_parentStaticConfig, contextForProps = staticConfig.context || ((_staticConfig_parentStaticConfig = staticConfig.parentStaticConfig) === null || _staticConfig_parentStaticConfig === void 0 ? void 0 : _staticConfig_parentStaticConfig.context);
      if (contextForProps) {
        for (var key in splitStyles.overriddenContextProps) overriddenContextProps || (overriddenContextProps = {}), overriddenContextProps[key] = splitStyles.overriddenContextProps[key];
        staticConfig.context || (contextForOverride = contextForProps);
      }
    }
    var groupContext = groupName && (allGroupContexts == null ? void 0 : allGroupContexts[groupName]) || null;
    if (!isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal") {
      var groupState = groupContext == null ? void 0 : groupContext.state;
      if (groupState && groupState.layout === void 0) {
        var _splitStyles_style, _splitStyles_style1;
        (!((_splitStyles_style = splitStyles.style) === null || _splitStyles_style === void 0) && _splitStyles_style.width || !((_splitStyles_style1 = splitStyles.style) === null || _splitStyles_style1 === void 0) && _splitStyles_style1.height) && (groupState.layout = {
          width: fromPx(splitStyles.style.width),
          height: fromPx(splitStyles.style.height)
        });
      }
    }
    if (!isPassthrough && (hasAnimationProp || groupName) && (animationDriver == null ? void 0 : animationDriver.avoidReRenders)) {
      let updateGroupListeners2 = function() {
        var updatedState = stateRef.current.nextState;
        if (groupContext) {
          var _a2 = updatedState, {
            group,
            hasDynGroupChildren,
            unmounted,
            animation
          } = _a2, childrenGroupState = __objRest(_a2, [
            "group",
            "hasDynGroupChildren",
            "unmounted",
            "animation"
          ]);
          notifyGroupSubscribers(groupContext, stateRef.current.group || null, childrenGroupState);
        }
      };
      var _componentContext, ogSetStateShallow = setStateShallow;
      stateRef.current.updateStyleListener = function() {
        var updatedState = stateRef.current.nextState || state, mediaState2 = stateRef.current.nextMedia, nextStyles = getSplitStyles(props, staticConfig, theme, themeName, updatedState, mediaState2 ? __spreadProps(__spreadValues({}, styleProps2), {
          mediaState: mediaState2
        }) : styleProps2, null, componentContext, allGroupContexts, elementType, startedUnhydrated, debugProp), useStyleListener = stateRef.current.useStyleListener;
        useStyleListener == null ? void 0 : useStyleListener((nextStyles == null ? void 0 : nextStyles.style) || {});
      }, (_componentContext = componentContext).mediaEmit || (_componentContext.mediaEmit = function(next) {
        var _stateRef_current_updateStyleListener, _stateRef_current;
        stateRef.current.nextMedia = next, (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
      }), stateRef.current.setStateShallow = function(nextOrGetNext) {
        var prev = stateRef.current.nextState || state, next = typeof nextOrGetNext == "function" ? nextOrGetNext(prev) : nextOrGetNext;
        if (!(next === prev || isEqualShallow(prev, next))) {
          var canAvoidReRender = Object.keys(next).every(function(key3) {
            return avoidReRenderKeys.has(key3);
          }), updatedState = __spreadValues(__spreadValues({}, prev), next);
          if (stateRef.current.nextState = updatedState, canAvoidReRender) {
            var _stateRef_current_updateStyleListener, _stateRef_current;
            updateGroupListeners2(), (_stateRef_current_updateStyleListener = (_stateRef_current = stateRef.current).updateStyleListener) === null || _stateRef_current_updateStyleListener === void 0 || _stateRef_current_updateStyleListener.call(_stateRef_current);
          } else ogSetStateShallow(next);
        }
      }, setStateShallow = function(state2) {
        var _stateRef_current_setStateShallow, _stateRef_current;
        (_stateRef_current_setStateShallow = (_stateRef_current = stateRef.current).setStateShallow) === null || _stateRef_current_setStateShallow === void 0 || _stateRef_current_setStateShallow.call(_stateRef_current, state2);
      };
    }
    if (splitStyles) {
      if (props.group && props.untilMeasured === "hide" && !stateRef.current.hasMeasured) {
        var _splitStyles;
        (_splitStyles = splitStyles).style || (_splitStyles.style = {}), splitStyles.style.opacity = 0;
      }
      splitStyles.dynamicThemeAccess != null && (stateRef.current.isListeningToTheme = splitStyles.dynamicThemeAccess);
    }
    var hasRuntimeMediaKeys = (splitStyles == null ? void 0 : splitStyles.hasMedia) && splitStyles.hasMedia !== true, shouldListenForMedia = didGetVariableValue() || hasRuntimeMediaKeys || noClass && (splitStyles == null ? void 0 : splitStyles.hasMedia) === true, mediaListeningKeys = hasRuntimeMediaKeys ? splitStyles.hasMedia : null;
    setMediaShouldUpdate(componentContext, shouldListenForMedia, mediaListeningKeys);
    var {
      viewProps: viewPropsIn,
      pseudos,
      style: splitStylesStyle,
      classNames,
      space,
      pseudoGroups,
      mediaGroups
    } = splitStyles || {}, propsWithAnimation = props, _a = viewPropsIn || {}, {
      asChild,
      children,
      themeShallow,
      spaceDirection: _spaceDirection,
      onPress,
      onLongPress,
      onPressIn,
      onPressOut,
      onHoverIn,
      onHoverOut,
      onMouseUp,
      onMouseDown,
      onMouseEnter,
      onMouseLeave,
      onFocus,
      onBlur,
      separator,
      passThrough: passThrough,
      forceStyle: _forceStyle,
      onClick: onClick,
      theme: _themeProp
    } = _a, nonTamaguiProps = __objRest(_a, [
      "asChild",
      "children",
      "themeShallow",
      "spaceDirection",
      "onPress",
      "onLongPress",
      "onPressIn",
      "onPressOut",
      "onHoverIn",
      "onHoverOut",
      "onMouseUp",
      "onMouseDown",
      "onMouseEnter",
      "onMouseLeave",
      "onFocus",
      "onBlur",
      "separator",
      // ignore from here on out
      "passThrough",
      "forceStyle",
      // @ts-ignore  for next/link compat etc
      "onClick",
      "theme"
    ]), viewProps = nonTamaguiProps;
    !isTaggable && props.forceStyle && (viewProps.forceStyle = props.forceStyle), isHOC && (typeof _themeProp < "u" && (viewProps.theme = _themeProp), typeof passThrough < "u" && (viewProps.passThrough = passThrough)), tagProp && elementType.acceptTagProp && (viewProps.tag = tagProp);
    var animationStyles, shouldUseAnimation = (
      // if it supports css vars we run it on server too to get matching initial style
      (supportsCSS ? willBeAnimatedClient : willBeAnimated) && useAnimations && !isHOC
    ), animatedRef;
    if (shouldUseAnimation) {
      var useStyleEmitter = (animationDriver == null ? void 0 : animationDriver.avoidReRenders) ? function(listener) {
        stateRef.current.useStyleListener = listener;
      } : void 0, animations = useAnimations({
        props: propsWithAnimation,
        // if hydrating, send empty style
        style: splitStylesStyle || {},
        // @ts-ignore
        styleState: splitStyles,
        useStyleEmitter,
        presence,
        componentState: state,
        styleProps: styleProps2,
        theme,
        pseudos: pseudos || null,
        staticConfig,
        stateRef
      });
      animations && (animations.ref && (animatedRef = animations.ref), isHydrated && animations && (animationStyles = animations.style, viewProps.style = animationStyles, animations.className && (viewProps.className = `${state.unmounted === "should-enter" ? "t_unmounted " : ""}${viewProps.className || ""} ${animations.className}`)));
    }
    !isPassthrough && groupContext && // avoids onLayout if we don't need it
    props.containerType !== "normal" && (nonTamaguiProps.onLayout = composeEventHandlers(nonTamaguiProps.onLayout, function(e2) {
      var _stateRef_current_group, layout = e2.nativeEvent.layout;
      groupContext.state.layout = layout, (_stateRef_current_group = stateRef.current.group) === null || _stateRef_current_group === void 0 || _stateRef_current_group.emit({
        layout
      }), !stateRef.current.hasMeasured && props.untilMeasured === "hide" && setState(function(prev) {
        return __spreadValues({}, prev);
      }), stateRef.current.hasMeasured = true;
    })), viewProps = ((_hooks_usePropsTransform = hooks.usePropsTransform) === null || _hooks_usePropsTransform === void 0 ? void 0 : _hooks_usePropsTransform.call(hooks, elementType, nonTamaguiProps, stateRef, stateRef.current.willHydrate)) || nonTamaguiProps, stateRef.current.composedRef || (stateRef.current.composedRef = composeRefs(function(x) {
      return stateRef.current.host = x;
    }, forwardedRef, setElementProps, animatedRef)), viewProps.ref = stateRef.current.composedRef;
    var unPress = function() {
      setStateShallow({
        press: false,
        pressIn: false
      });
    };
    useIsomorphicLayoutEffect(function() {
      if (state.unmounted === true && hasEnterStyle) {
        setStateShallow({
          unmounted: "should-enter"
        });
        return;
      }
      var tm;
      if (state.unmounted) {
        if ((animationDriver == null ? void 0 : animationDriver.supportsCSS) || isAndroid) return tm = setTimeout(function() {
          setStateShallow({
            unmounted: false
          });
        }), function() {
          return clearTimeout(tm);
        };
        setStateShallow({
          unmounted: false
        });
        return;
      }
      return function() {
        componentSetStates.delete(setState);
      };
    }, [state.unmounted, disabled]), useIsomorphicLayoutEffect(function() {
      if (!disabled && !(!pseudoGroups && !mediaGroups) && allGroupContexts) return subscribeToContextGroup({
        groupContext: allGroupContexts,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }, [allGroupContexts, disabled, pseudoGroups ? objectIdentityKey(pseudoGroups) : 0, mediaGroups ? objectIdentityKey(mediaGroups) : 0]);
    var groupEmitter = stateRef.current.group;
    useIsomorphicLayoutEffect(function() {
      !groupContext || !groupEmitter || notifyGroupSubscribers(groupContext, groupEmitter, state);
    }, [groupContext, groupEmitter, state]);
    var runtimePressStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.pressStyle), runtimeFocusStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusStyle), runtimeFocusVisibleStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.focusVisibleStyle), attachFocus = !!(runtimePressStyle || runtimeFocusStyle || runtimeFocusVisibleStyle || onFocus || onBlur || componentContext.setParentFocusState), hasDynamicGroupChildren = !!(groupName && state.hasDynGroupChildren), attachPress = !!(hasDynamicGroupChildren || runtimePressStyle || onPress || onPressOut || onPressIn || onMouseDown || onMouseUp || onLongPress || onClick || (pseudos == null ? void 0 : pseudos.focusVisibleStyle)), runtimeHoverStyle = !disabled && noClass && (pseudos == null ? void 0 : pseudos.hoverStyle), needsHoverState = !!(hasDynamicGroupChildren || runtimeHoverStyle), attachHover = isWeb, shouldAttach = !disabled && !props.asChild && !!(attachFocus || attachPress || attachHover || runtimePressStyle || runtimeHoverStyle || runtimeFocusStyle), needsPressState = !!(hasDynamicGroupChildren || runtimePressStyle);
    var events = shouldAttach ? __spreadValues(__spreadValues(__spreadProps(__spreadValues({
      onPressOut: attachPress ? function(e2) {
        unPress(), onPressOut == null ? void 0 : onPressOut(e2), onMouseUp == null ? void 0 : onMouseUp(e2);
      } : void 0
    }, attachPress && {
      onMouseEnter: function(e2) {
        var next = {};
        needsHoverState && (next.hover = true), needsPressState && state.pressIn && (next.press = true), setStateShallow(next), onHoverIn == null ? void 0 : onHoverIn(e2), onMouseEnter == null ? void 0 : onMouseEnter(e2);
      },
      onMouseLeave: function(e2) {
        var next = {};
        needsHoverState && (next.hover = false), needsPressState && (next.press = false, next.pressIn = false), setStateShallow(next), onHoverOut == null ? void 0 : onHoverOut(e2), onMouseLeave == null ? void 0 : onMouseLeave(e2);
      }
    }), {
      onPressIn: attachPress ? function(e2) {
        needsPressState && setStateShallow({
          press: true,
          pressIn: true
        }), onPressIn == null ? void 0 : onPressIn(e2), onMouseDown == null ? void 0 : onMouseDown(e2);
      } : void 0,
      onPress: attachPress ? function(e2) {
        unPress(), onPress == null ? void 0 : onPress(e2);
      } : void 0
    }), attachPress && onLongPress && {
      onLongPress: function(e2) {
        unPress(), onLongPress == null ? void 0 : onLongPress(e2);
      }
    }), attachFocus && {
      onFocus: function(e2) {
        var next = {};
        componentContext.setParentFocusState && (next.focusWithin = true), (pseudos == null ? void 0 : pseudos.focusVisibleStyle) && lastInteractionWasKeyboard.value ? next.focusVisible = true : next.focus = true, setStateShallow(next), onFocus == null ? void 0 : onFocus(e2);
      },
      onBlur: function(e2) {
        componentContext.setParentFocusState && componentContext.setParentFocusState({
          focusWithin: false
        }), setStateShallow({
          focus: false,
          focusVisible: false,
          focusWithin: false
        }), onBlur == null ? void 0 : onBlur(e2);
      }
    }) : null;
    if (events && !asChild) {
      var _viewProps_focusable;
      Object.assign(events, {
        cancelable: !viewProps.rejectResponderTermination,
        disabled,
        hitSlop: viewProps.hitSlop,
        delayLongPress: viewProps.delayLongPress,
        delayPressIn: viewProps.delayPressIn,
        delayPressOut: viewProps.delayPressOut,
        focusable: (_viewProps_focusable = viewProps.focusable) !== null && _viewProps_focusable !== void 0 ? _viewProps_focusable : true,
        minPressDuration: 0
      });
    }
    (_hooks_useEvents = hooks.useEvents) === null || _hooks_useEvents === void 0 || _hooks_useEvents.call(hooks, viewProps, events, splitStyles, setStateShallow, staticConfig);
    var direction = props.spaceDirection || "both";
    var content = !children || asChild || !splitStyles ? children : spacedChildren({
      separator,
      children,
      space,
      direction,
      isZStack
    });
    if (asChild) if (elementType = Slot, 0) ;
    else Object.assign(viewProps, {
      onPress,
      onLongPress
    });
    isPassthrough && (content = propsIn.children, elementType = BaseViewComponent, viewProps = {
      style: {
        display: "contents"
      }
    });
    var useChildrenResult;
    hooks.useChildren && (useChildrenResult = hooks.useChildren(elementType, content, viewProps)), useChildrenResult ? content = useChildrenResult : content = /* @__PURE__ */ React.createElement(elementType, viewProps, content);
    var ResetPresence2 = config == null || (_config_animations = config.animations) === null || _config_animations === void 0 ? void 0 : _config_animations.ResetPresence, needsReset = !!// not when passing down to child
    (!asChild && // not when passThrough
    splitStyles && // not when HOC
    !isHOC && ResetPresence2 && willBeAnimated && (hasEnterStyle || presenceState)), hasEverReset = stateRef.current.hasEverResetPresence;
    needsReset && !hasEverReset && (stateRef.current.hasEverResetPresence = true);
    var renderReset = needsReset || hasEverReset;
    if (renderReset && ResetPresence2 && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence2, {
      disabled: !needsReset,
      children: content
    })), "focusWithinStyle" in propsIn && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, componentContext), {
      setParentFocusState: setStateShallow,
      children: content
    }))), "group" in props && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(GroupContext.Provider, {
      value: allGroupContexts,
      children: content
    })), content = disableTheme || !splitStyles ? content : getThemedChildren(themeState, content, themeStateProps, false, stateRef), overriddenContextProps && contextForOverride) {
      var Provider = contextForOverride.Provider;
      for (var key1 in styledContextValue) key1 in overriddenContextProps || (overriddenContextProps[key1] = styledContextValue[key1]);
      debugProp && console.info("overriddenContextProps", overriddenContextProps), content = /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, __spreadProps(__spreadValues({
        __disableMergeDefaultValues: true
      }, overriddenContextProps), {
        children: content
      }));
    }
    return content;
  });
  function notifyGroupSubscribers(groupContext, groupEmitter, pseudo) {
    if (!(!groupContext || !groupEmitter)) {
      var nextState = __spreadProps(__spreadValues({}, groupContext.state), {
        pseudo
      });
      groupEmitter.emit(nextState), groupContext.state = nextState;
    }
  }
  staticConfig.componentName && (component.displayName = staticConfig.componentName);
  var res = component;
  (process.env.TAMAGUI_FORCE_MEMO || staticConfig.memo) && (res = /* @__PURE__ */ React.memo(res)), res.staticConfig = staticConfig;
  function extendStyledConfig(extended) {
    return __spreadProps(__spreadValues(__spreadValues({}, staticConfig), extended), {
      neverFlatten: true,
      isHOC: true,
      isStyledHOC: false
    });
  }
  function extractable(Component2, extended) {
    return Component2.staticConfig = extendStyledConfig(extended), Component2.styleable = styleable, Component2;
  }
  function styleable(Component2, options) {
    var _Component_render, skipForwardRef = IS_REACT_19 && typeof Component2 == "function" && Component2.length === 1 || ((_Component_render = Component2.render) === null || _Component_render === void 0 ? void 0 : _Component_render.length) === 2, out = skipForwardRef ? Component2 : /* @__PURE__ */ React.forwardRef(Component2), extendedConfig = extendStyledConfig(options == null ? void 0 : options.staticConfig);
    return out = (options == null ? void 0 : options.disableTheme) ? out : themeable(out, extendedConfig, true), (extendedConfig.memo || process.env.TAMAGUI_MEMOIZE_STYLEABLE) && (out = /* @__PURE__ */ React.memo(out)), out.staticConfig = extendedConfig, out.styleable = styleable, out;
  }
  return res.extractable = extractable, res.styleable = styleable, res;
}
function Unspaced(props) {
  return props.children;
}
Unspaced.isUnspaced = true;
var getSpacerSize = function(size, param) {
  var {
    tokens
  } = param;
  size = size === false ? 0 : size === true ? "$true" : size;
  var _tokens_space_size, sizePx = (_tokens_space_size = tokens.space[size]) !== null && _tokens_space_size !== void 0 ? _tokens_space_size : size;
  return {
    width: sizePx,
    height: sizePx,
    minWidth: sizePx,
    minHeight: sizePx
  };
}, Spacer = createComponent({
  acceptsClassName: true,
  memo: true,
  componentName: "Spacer",
  validStyles,
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    // avoid nesting issues
    tag: "span",
    size: true,
    pointerEvents: "none"
  }),
  variants: {
    size: {
      "...": getSpacerSize
    },
    flex: {
      true: {
        flexGrow: 1
      }
    },
    direction: {
      horizontal: {
        height: 0,
        minHeight: 0
      },
      vertical: {
        width: 0,
        minWidth: 0
      },
      both: {}
    }
  }
});
function spacedChildren(props) {
  var _childrenList__type, _childrenList_, {
    isZStack,
    children,
    space,
    direction,
    spaceFlex,
    separator,
    ensureKeys
  } = props, hasSpace = !!(space || spaceFlex), hasSeparator = separator != null, areChildrenArray = Array.isArray(children);
  if (!ensureKeys && !(hasSpace || hasSeparator || isZStack)) return children;
  var childrenList = areChildrenArray ? children : React.Children.toArray(children), len = childrenList.length;
  if (len <= 1 && !isZStack && !(!((_childrenList_ = childrenList[0]) === null || _childrenList_ === void 0 || (_childrenList__type = _childrenList_.type) === null || _childrenList__type === void 0) && _childrenList__type.shouldForwardSpace)) return children;
  var final = [], _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = childrenList.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var [index2, child] = _step.value, _child_type, isEmpty = child == null || Array.isArray(child) && child.length === 0;
      if (!isEmpty && /* @__PURE__ */ React.isValidElement(child) && !((_child_type = child.type) === null || _child_type === void 0) && _child_type.shouldForwardSpace && (child = /* @__PURE__ */ React.cloneElement(child, {
        // @ts-expect-error we explicitly know with shouldForwardSpace
        space,
        spaceFlex,
        separator,
        key: child.key
      })), isEmpty || !child || child.key && !isZStack ? final.push(child) : final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
        children: isZStack ? /* @__PURE__ */ jsxRuntimeExports.jsx(AbsoluteFill, {
          children: child
        }) : child
      }, `${index2}0t`)), !(isUnspaced(child) && index2 === 0) && !isZStack) {
        var next = childrenList[index2 + 1];
        next && !isEmpty && !isUnspaced(next) && (separator ? (hasSpace && final.push(createSpacer({
          key: `_${index2}_00t`,
          direction,
          space,
          spaceFlex
        })), final.push(/* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
          children: separator
        }, `${index2}03t`)), hasSpace && final.push(createSpacer({
          key: `_${index2}01t`,
          direction,
          space,
          spaceFlex
        }))) : final.push(createSpacer({
          key: `_${index2}02t`,
          direction,
          space,
          spaceFlex
        })));
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return final;
}
function createSpacer(param) {
  var {
    key,
    direction,
    space,
    spaceFlex
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, __spreadValues({
    size: space,
    direction
  }, typeof spaceFlex < "u" && {
    flex: spaceFlex === true ? 1 : spaceFlex === false ? 0 : spaceFlex
  }), key);
}
function isUnspaced(child) {
  var t2 = child == null ? void 0 : child.type;
  return (t2 == null ? void 0 : t2.isVisuallyHidden) || (t2 == null ? void 0 : t2.isUnspaced);
}
var AbsoluteFill = createComponent({
  defaultProps: __spreadProps(__spreadValues({}, stackDefaultStyles), {
    flexDirection: "column",
    position: "absolute",
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    pointerEvents: "box-none"
  })
}), fromPx = function(val) {
  return typeof val == "number" ? val : typeof val == "string" ? +val.replace("px", "") : 0;
};
function getExpandedShorthand(propKey, props) {
  var shorthands = getConfig().inverseShorthands, _props_propKey;
  return (_props_propKey = props[propKey]) !== null && _props_propKey !== void 0 ? _props_propKey : props[shorthands[propKey]];
}
var inverseShorthands = null, getShorthandValue = function(props, key) {
  inverseShorthands || (inverseShorthands = getConfig().inverseShorthands);
  var _props_key;
  return (_props_key = props[key]) !== null && _props_key !== void 0 ? _props_key : inverseShorthands ? props[inverseShorthands[key]] : void 0;
};
function isTamaguiComponent(comp, name) {
  var config = comp == null ? void 0 : comp.staticConfig;
  return !!(config && (!name || name === config.componentName));
}
var isTamaguiElement = function(child, name) {
  return /* @__PURE__ */ React.isValidElement(child) && isTamaguiComponent(child.type, name);
};
var themesRaw = {};
function proxyThemesToParents(dedupedThemes) {
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = dedupedThemes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var {
        names,
        theme
      } = _step.value, _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
      try {
        for (var _iterator1 = names[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
          var name = _step1.value;
          themesRaw[name] = theme;
        }
      } catch (err) {
        _didIteratorError1 = true, _iteratorError1 = err;
      } finally {
        try {
          !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError1) throw _iteratorError1;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  var themes2 = {}, _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
  try {
    for (var _iterator2 = dedupedThemes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var {
        names: names1,
        theme: theme1
      } = _step2.value, _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = void 0;
      try {
        for (var _iterator3 = names1[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var themeName = _step3.value, proxiedTheme = proxyThemeToParents(themeName, theme1);
          themes2[themeName] = proxiedTheme;
        }
      } catch (err) {
        _didIteratorError3 = true, _iteratorError3 = err;
      } finally {
        try {
          !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
        } finally {
          if (_didIteratorError3) throw _iteratorError3;
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true, _iteratorError2 = err;
  } finally {
    try {
      !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
    } finally {
      if (_didIteratorError2) throw _iteratorError2;
    }
  }
  return themes2;
}
function proxyThemeToParents(themeName, theme) {
  var out = {}, cur = [], parents = themeName.split("_").slice(0, -1).map(function(part) {
    return cur.push(part), cur.join("_");
  }), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = parents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var parent = _step.value;
      Object.assign(out, themesRaw[parent]);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return Object.assign(out, theme), out;
}
function ensureThemeVariable(theme, key) {
  var val = theme[key];
  isVariable(val) ? val.name !== key && (theme[key] = createVariable({
    key: val.name,
    name: key,
    val: val.val
  })) : theme[key] = createVariable({
    key,
    name: key,
    val
  });
}
var fontWeights = ["100", "200", "300", "400", "500", "600", "700", "800", "900"], processSection = function(section, keys, defaultValue2) {
  if (typeof section == "string") return section;
  var sectionKeys = Object.keys(section), fillValue = section[sectionKeys[0]];
  return Object.fromEntries([.../* @__PURE__ */ new Set([...keys, ...sectionKeys])].map(function(key) {
    var _section_key, _ref, value = (_ref = (_section_key = section[key]) !== null && _section_key !== void 0 ? _section_key : defaultValue2) !== null && _ref !== void 0 ? _ref : fillValue;
    return fillValue = value, defaultValue2 = value, [key, value];
  }));
}, createFont = function(font) {
  var sizeKeys = Object.keys(font.size || {}), processedFont = Object.fromEntries(Object.entries(font).map(function(param) {
    var [key, section] = param;
    return [key, processSection(section, key === "face" ? fontWeights : sizeKeys, key === "face" ? {
      normal: font.family
    } : void 0)];
  }));
  return Object.freeze(processedFont);
};
function createShorthands(shorthands) {
  return Object.freeze(shorthands);
}
function _type_of$4(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var cache$1 = /* @__PURE__ */ new WeakMap(), createVariables = function(tokens) {
  var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (cache$1.has(tokens)) return tokens;
  var res = {};
  for (var keyIn in tokens) {
    var val = tokens[keyIn], isPrefixed = keyIn[0] === "$", keyWithPrefix = isPrefixed ? keyIn : `$${keyIn}`, key = isPrefixed ? keyWithPrefix.slice(1) : keyIn;
    if (isVariable(val)) {
      res[key] = val;
      continue;
    }
    var niceKey = simpleHash(key, 1e3), name = parentPath && parentPath !== "t-color" ? `${parentPath}-${niceKey}` : `c-${niceKey}`;
    if (val && (typeof val > "u" ? "undefined" : _type_of$4(val)) === "object" && "needsPx" in val && "val" in val) {
      var finalValue = createVariable({
        val: val.val,
        name,
        key: keyWithPrefix
      });
      res[key] = finalValue;
      continue;
    }
    if (val && (typeof val > "u" ? "undefined" : _type_of$4(val)) === "object") {
      res[key] = createVariables(tokens[key], name, false);
      continue;
    }
    var finalValue1 = isVariable(val) ? val : createVariable({
      val,
      name,
      key: keyWithPrefix
    });
    res[key] = finalValue1;
  }
  return cache$1.set(res, true), res;
};
var noAnimationDriver = function(method) {
  console.warn(`No animation driver configured. To use ${method}, you must pass \`animations\` to createTamagui. See: https://tamagui.dev/docs/core/animations`);
}, createEmptyAnimationDriver = function() {
  return {
    isReactNative: false,
    supportsCSS: true,
    classNameAnimation: true,
    isStub: true,
    animations: {},
    useAnimations: function() {
      return noAnimationDriver("animations");
    },
    usePresence: function() {
      return noAnimationDriver("usePresence");
    },
    ResetPresence: function() {
      return noAnimationDriver("ResetPresence");
    },
    useAnimatedNumber: function() {
      return noAnimationDriver("useAnimatedNumber");
    },
    useAnimatedNumberStyle: function() {
      return noAnimationDriver("useAnimatedNumberStyle");
    },
    useAnimatedNumberReaction: function() {
      return noAnimationDriver("useAnimatedNumberReaction");
    }
  };
}, defaultAnimationDriver = createEmptyAnimationDriver();
var registerCSSVariable = function(v) {
  tokensValueToVariable.set(getVariableValue(v), v);
}, variableToCSS = function(v) {
  var unitless = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return `--${process.env.TAMAGUI_CSS_VARIABLE_PREFIX || ""}${createCSSVariable(v.name, false)}:${!unitless && typeof v.val == "number" ? `${v.val}px` : v.val}`;
}, tokensValueToVariable = /* @__PURE__ */ new Map();
function insertFont(name, fontIn) {
  var font = createFont(fontIn), tokened = createVariables(font, name), parsed = parseFont(tokened);
  return setConfigFont(name, tokened, parsed), parsed;
}
function parseFont(definition) {
  var parsed = {};
  for (var attrKey in definition) {
    var attr = definition[attrKey];
    if (attrKey === "family" || attrKey === "face") parsed[attrKey] = attr;
    else {
      parsed[attrKey] = {};
      for (var key in attr) {
        var _val_val, val = attr[key];
        ((_val_val = val.val) === null || _val_val === void 0 ? void 0 : _val_val[0]) === "$" && (val = val.val), parsed[attrKey][`$${key}`] = val;
      }
    }
  }
  return parsed;
}
function shouldTokenCategoryHaveUnits(category) {
  var UNIT_CATEGORIES = /* @__PURE__ */ new Set(["size", "space", "radius"]);
  return UNIT_CATEGORIES.has(category);
}
function createTamagui$2(configIn) {
  var _configIn_settings, existingConfig = getConfigMaybe();
  existingConfig && (configIn = __spreadValues(__spreadValues({}, existingConfig), configIn));
  var tokensParsed = {}, tokens = createVariables(configIn.tokens || {});
  if (configIn.tokens) {
    var tokensMerged2 = {};
    for (var cat in tokens) {
      tokensParsed[cat] = {}, tokensMerged2[cat] = {};
      var tokenCat = tokens[cat];
      for (var key in tokenCat) {
        var val = tokenCat[key], prefixedKey = `$${key}`;
        tokensParsed[cat][prefixedKey] = val, tokensMerged2[cat][prefixedKey] = val, tokensMerged2[cat][key] = val;
      }
    }
    setTokens(tokensMerged2);
  }
  var foundThemes;
  if (configIn.themes) {
    var noThemes = Object.keys(configIn.themes).length === 0;
    noThemes && (foundThemes = scanAllSheets());
  }
  var fontSizeTokens = null, fontsParsed;
  if (configIn.fonts) {
    var fontTokens = Object.fromEntries(Object.entries(configIn.fonts).map(function(param) {
      var [k, v] = param;
      return [k, createVariables(v, "f", true)];
    }));
    fontsParsed = (function() {
      var res = {};
      for (var familyName in fontTokens) {
        var font = fontTokens[familyName], fontParsed = parseFont(font);
        res[`$${familyName}`] = fontParsed, !fontSizeTokens && fontParsed.size && (fontSizeTokens = new Set(Object.keys(fontParsed.size)));
      }
      return res;
    })();
  }
  var specificTokens = {}, themeConfig = (function() {
    var cssRuleSets = [], declarations = [], sortedTokenKeys = Object.keys(tokens).sort(), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = sortedTokenKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key2 = _step.value, sortedSubKeys = Object.keys(tokens[key2]).sort(), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
        try {
          for (var _iterator1 = sortedSubKeys[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
            var skey = _step1.value, variable = tokens[key2][skey];
            if (specificTokens[`$${key2}.${skey}`] = variable, false) ;
            var variableNeedsPx, categoryNeedsPx, shouldBeUnitless;
            if (isWeb) ;
          }
        } catch (err) {
          _didIteratorError1 = true, _iteratorError1 = err;
        } finally {
          try {
            !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
          } finally {
            if (_didIteratorError1) throw _iteratorError1;
          }
        }
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    var themesIn = configIn.themes, dedupedThemes = foundThemes != null ? foundThemes : getThemesDeduped(themesIn, tokens.color), themes2 = proxyThemesToParents(dedupedThemes);
    return {
      themes: themes2,
      cssRuleSets,
      getThemeRulesSets() {
        var themeRuleSets = [];
        return themeRuleSets;
      }
    };
  })(), userShorthands = configIn.shorthands || {}, shorthands = __spreadValues(__spreadValues({}, builtinShorthands), userShorthands), getCSS = function() {
    return "";
  }, getNewCSS = function(opts2) {
    return getCSS(__spreadValues({}, opts2));
  }, _configIn_settings_defaultFont, defaultFontSetting = (_configIn_settings_defaultFont = (_configIn_settings = configIn.settings) === null || _configIn_settings === void 0 ? void 0 : _configIn_settings.defaultFont) !== null && _configIn_settings_defaultFont !== void 0 ? _configIn_settings_defaultFont : configIn.defaultFont, defaultFont = (function() {
    var val2 = defaultFontSetting;
    return (val2 == null ? void 0 : val2[0]) === "$" && (val2 = val2.slice(1)), val2;
  })(), defaultFontToken = defaultFont ? `$${defaultFont}` : "", unset = __spreadValues({}, configIn.unset);
  !unset.fontFamily && defaultFont && (unset.fontFamily = defaultFontToken);
  var config = __spreadProps(__spreadValues({
    fonts: {},
    onlyAllowShorthands: false,
    fontLanguages: [],
    animations: defaultAnimationDriver,
    media: {}
  }, configIn), {
    unset,
    settings: __spreadValues({
      // move deprecated settings here so we can reference them all using `getSetting`
      // TODO remove this on v2
      disableSSR: configIn.disableSSR,
      defaultFont: configIn.defaultFont,
      disableRootThemeClass: configIn.disableRootThemeClass,
      onlyAllowShorthands: configIn.onlyAllowShorthands,
      mediaQueryDefaultActive: configIn.mediaQueryDefaultActive,
      themeClassNameOnRoot: configIn.themeClassNameOnRoot,
      cssStyleSeparator: configIn.cssStyleSeparator,
      webContainerType: "inline-size"
    }, configIn.settings),
    tokens,
    // vite made this into a function if it wasn't set
    shorthands,
    userShorthands,
    inverseShorthands: shorthands ? Object.fromEntries(Object.entries(shorthands).map(function(param) {
      var [k, v] = param;
      return [v, k];
    })) : {},
    themes: themeConfig.themes,
    fontsParsed: fontsParsed || {},
    themeConfig,
    tokensParsed,
    parsed: true,
    getNewCSS,
    getCSS,
    defaultFont,
    fontSizeTokens: fontSizeTokens || /* @__PURE__ */ new Set(),
    specificTokens,
    defaultFontToken
  });
  if (setConfig(config), configureMedia(config), configListeners.size && (configListeners.forEach(function(cb) {
    return cb(config);
  }), configListeners.clear()), false) ;
  return config;
}
function getThemesDeduped(themes2, colorTokens) {
  var dedupedThemes = [], existing = /* @__PURE__ */ new Map(), sortedThemeNames = Object.keys(themes2).sort(), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = sortedThemeNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var themeName = _step.value, darkOrLightSpecificPrefix = themeName.startsWith("dark") ? "dark" : themeName.startsWith("light") ? "light" : "", rawTheme = themes2[themeName], key = darkOrLightSpecificPrefix + JSON.stringify(rawTheme);
      if (existing.has(key)) {
        var e2 = existing.get(key);
        e2.names.push(themeName);
        continue;
      }
      var theme = __spreadValues(__spreadValues({}, colorTokens), rawTheme);
      for (var key1 in theme) ensureThemeVariable(theme, key1);
      var deduped = {
        names: [themeName],
        theme
      };
      dedupedThemes.push(deduped), existing.set(key, deduped);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  return dedupedThemes;
}
var builtinShorthands = {
  fd: "flexDirection",
  fb: "flexBasis",
  bblr: "borderBottomLeftRadius",
  bbrr: "borderBottomRightRadius",
  fwr: "flexWrap",
  col: "color",
  ff: "fontFamily",
  fst: "fontStyle",
  tr: "transform",
  tt: "textTransform",
  td: "textDecorationLine",
  va: "verticalAlign",
  ws: "whiteSpace",
  wb: "wordBreak",
  ww: "wordWrap",
  brc: "borderRightColor",
  brw: "borderRightWidth",
  bs: "borderStyle",
  btc: "borderTopColor",
  btlr: "borderTopLeftRadius",
  btrr: "borderTopRightRadius",
  btw: "borderTopWidth",
  bw: "borderWidth",
  o: "opacity",
  cur: "cursor",
  pe: "pointerEvents",
  ov: "overflow",
  pos: "position",
  dsp: "display",
  fw: "fontWeight",
  fs: "fontSize",
  ls: "letterSpacing",
  lh: "lineHeight",
  bxs: "boxSizing",
  bxsh: "boxShadow",
  ox: "overflowX",
  oy: "overflowY"
};
var createTheme = function(theme) {
  return theme;
};
function createTokens(tokens) {
  var _process_env_TAMAGUI_TOKEN_PREFIX;
  return createVariables(tokens, (_process_env_TAMAGUI_TOKEN_PREFIX = process.env.TAMAGUI_TOKEN_PREFIX) !== null && _process_env_TAMAGUI_TOKEN_PREFIX !== void 0 ? _process_env_TAMAGUI_TOKEN_PREFIX : "t");
}
function getReactNativeConfig(Component) {
  if (Component) {
    var _Component_propTypes, _Component_propTypes1, _Component_propTypes2;
    return !((_Component_propTypes = Component.propTypes) === null || _Component_propTypes === void 0) && _Component_propTypes.onTextInput || !((_Component_propTypes1 = Component.propTypes) === null || _Component_propTypes1 === void 0) && _Component_propTypes1.onChangeText ? RNConfigs.TextInput : Component.getSizeWithHeaders ? RNConfigs.Image : !((_Component_propTypes2 = Component.propTypes) === null || _Component_propTypes2 === void 0) && _Component_propTypes2.textBreakStrategy ? RNConfigs.Text : RNConfigs.default;
  }
}
var RNConfigs = {
  Image: {
    isReactNative: true,
    inlineProps: /* @__PURE__ */ new Set(["src", "width", "height"])
  },
  Text: {
    isReactNative: true,
    isText: true
  },
  TextInput: {
    isReactNative: true,
    isInput: true,
    isText: true
  },
  default: {
    isReactNative: true
  }
};
function setupReactNative(rnExports) {
}
var mergeVariants = function(parentVariants, ourVariants) {
  var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, variants2 = {};
  for (var key in ourVariants) {
    var parentVariant = parentVariants == null ? void 0 : parentVariants[key], ourVariant = ourVariants[key];
    !parentVariant || typeof ourVariant == "function" ? variants2[key] = ourVariant : parentVariant && !ourVariant ? variants2[key] = parentVariant[key] : level === 0 ? variants2[key] = mergeVariants(parentVariant, ourVariant, level + 1) : variants2[key] = __spreadValues(__spreadValues({}, parentVariant), ourVariant);
  }
  return __spreadValues(__spreadValues({}, parentVariants), variants2);
};
function styled(ComponentIn, options, config) {
  if (!ComponentIn) throw new Error("No component given to styled()");
  var parentStaticConfig = ComponentIn.staticConfig, isPlainStyledComponent = !!parentStaticConfig && !(parentStaticConfig.isReactNative || parentStaticConfig.isHOC), isNonStyledHOC = (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && !(parentStaticConfig == null ? void 0 : parentStaticConfig.isStyledHOC), Component = isNonStyledHOC || isPlainStyledComponent ? ComponentIn : (parentStaticConfig == null ? void 0 : parentStaticConfig.Component) || ComponentIn, reactNativeConfig = parentStaticConfig ? void 0 : getReactNativeConfig(Component), isReactNative = !!(reactNativeConfig || (config == null ? void 0 : config.isReactNative) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isReactNative)), staticConfigProps = (function() {
    var _a = options || {}, {
      variants: variants2,
      name,
      defaultVariants,
      acceptsClassName: acceptsClassNameProp,
      context: context2
    } = _a, defaultProps2 = __objRest(_a, [
      "variants",
      "name",
      "defaultVariants",
      "acceptsClassName",
      "context"
    ]), parentDefaultVariants, parentDefaultProps;
    if (parentStaticConfig) {
      var avoid = parentStaticConfig.isHOC && !parentStaticConfig.isStyledHOC;
      if (!avoid) {
        var pdp = parentStaticConfig.defaultProps;
        for (var key2 in pdp) {
          var val = pdp[key2];
          parentStaticConfig.defaultVariants && key2 in parentStaticConfig.defaultVariants && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultVariants || (parentDefaultVariants = {}), parentDefaultVariants[key2] = val), !(key2 in defaultProps2) && (!defaultVariants || !(key2 in defaultVariants)) && (parentDefaultProps || (parentDefaultProps = {}), parentDefaultProps[key2] = pdp[key2]);
        }
        parentStaticConfig.variants && (variants2 = mergeVariants(parentStaticConfig.variants, variants2));
      }
    }
    (parentDefaultProps || defaultVariants || parentDefaultVariants) && (defaultProps2 = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, parentDefaultProps), parentDefaultVariants), defaultProps2), defaultVariants)), (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && name && (defaultProps2.componentName = name);
    var isText = !!((config == null ? void 0 : config.isText) || (parentStaticConfig == null ? void 0 : parentStaticConfig.isText)), _config_acceptsClassName, _ref, acceptsClassName = (_ref = (_config_acceptsClassName = config == null ? void 0 : config.acceptsClassName) !== null && _config_acceptsClassName !== void 0 ? _config_acceptsClassName : acceptsClassNameProp) !== null && _ref !== void 0 ? _ref : isPlainStyledComponent || isReactNative || (parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC) && (parentStaticConfig == null ? void 0 : parentStaticConfig.acceptsClassName), conf2 = __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, parentStaticConfig), config), !isPlainStyledComponent && {
      Component
    }), {
      // @ts-expect-error
      variants: variants2,
      defaultProps: defaultProps2,
      defaultVariants,
      componentName: name || (parentStaticConfig == null ? void 0 : parentStaticConfig.componentName),
      isReactNative,
      isText,
      acceptsClassName,
      context: context2
    }), reactNativeConfig), {
      isStyledHOC: !!(parentStaticConfig == null ? void 0 : parentStaticConfig.isHOC),
      parentStaticConfig
    });
    return (defaultProps2.children || !acceptsClassName || context2) && (conf2.neverFlatten = true), conf2;
  })(), component = createComponent(staticConfigProps || {});
  for (var key in ComponentIn) key !== "propTypes" && (key in component || (component[key] = ComponentIn[key]));
  return component;
}
var useIsTouchDevice = function() {
  return true;
};
var Stack$1 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
Stack$1.displayName = "Stack";
function useProps(props, opts2) {
  var [propsOut, styleOut] = usePropsAndStyle(props, __spreadProps(__spreadValues({}, opts2), {
    noExpand: true,
    noNormalize: true,
    resolveValues: "none"
  }));
  return __spreadValues(__spreadValues({}, propsOut), styleOut);
}
function useStyle(props, opts2) {
  return usePropsAndStyle(props, opts2)[1] || {};
}
function usePropsAndStyle(props, opts2) {
  var _opts_forComponent, _opts_forComponent_staticConfig, staticConfig = (_opts_forComponent_staticConfig = opts2 == null || (_opts_forComponent = opts2.forComponent) === null || _opts_forComponent === void 0 ? void 0 : _opts_forComponent.staticConfig) !== null && _opts_forComponent_staticConfig !== void 0 ? _opts_forComponent_staticConfig : Stack$1.staticConfig, [theme, themeState] = useThemeWithState({
    componentName: staticConfig.componentName,
    name: "theme" in props ? props.theme : void 0,
    inverse: "themeInverse" in props ? props.themeInverse : void 0,
    needsUpdate() {
      return true;
    }
  }), componentContext = React.useContext(ComponentContext), groupContext = React.useContext(GroupContext), {
    state,
    disabled,
    setStateShallow
  } = useComponentState(props, componentContext.animationDriver, staticConfig, getConfig()), mediaStateNow = (opts2 == null ? void 0 : opts2.noMedia) ? (
    // not safe to use mediaState but really marginal to hit this
    exports.mediaState
  ) : useMedia(), splitStyles = useSplitStyles(props, staticConfig, theme, (themeState == null ? void 0 : themeState.name) || "", state, __spreadValues({
    isAnimated: false,
    mediaState: mediaStateNow,
    noSkip: true,
    noMergeStyle: true,
    noClass: true,
    resolveValues: "auto"
  }, opts2), null, componentContext, groupContext), {
    mediaGroups,
    pseudoGroups
  } = splitStyles || {};
  return useIsomorphicLayoutEffect(function() {
    if (!disabled) {
      if (state.unmounted) {
        setStateShallow({
          unmounted: false
        });
        return;
      }
      if (groupContext) return subscribeToContextGroup({
        groupContext,
        setStateShallow,
        mediaGroups,
        pseudoGroups
      });
    }
  }, [disabled, groupContext, pseudoGroups ? Object.keys([...pseudoGroups]).join("") : 0, mediaGroups ? Object.keys([...mediaGroups]).join("") : 0]), [(splitStyles == null ? void 0 : splitStyles.viewProps) || {}, (splitStyles == null ? void 0 : splitStyles.style) || {}, theme, exports.mediaState];
}
var forceUpdateState = {
  forceClassName: true,
  deopt: true,
  needsUpdate: function() {
    return true;
  }
}, forceKeys = {
  current: /* @__PURE__ */ new Set([""])
};
function useThemeName() {
  var _useThemeState;
  return ((_useThemeState = useThemeState(forceUpdateState, false, forceKeys)) === null || _useThemeState === void 0 ? void 0 : _useThemeState.name) || "";
}
var Configuration = function(props) {
  var current = React.useContext(ComponentContext), _props_disableSSR;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: (_props_disableSSR = props.disableSSR) !== null && _props_disableSSR !== void 0 ? _props_disableSSR : current.disableSSR,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadValues(__spreadValues({}, current), props))
  });
};
function FontLanguage(param) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]), parentProps = React.useContext(ComponentContext), language = React.useMemo(function() {
    return props;
  }, [JSON.stringify(props)]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, __spreadProps(__spreadValues({}, parentProps), {
    language,
    children
  }));
}
var ThemeProvider = function(props) {
  var _props_disableRootThemeClass, disableRootThemeClass = (_props_disableRootThemeClass = props.disableRootThemeClass) !== null && _props_disableRootThemeClass !== void 0 ? _props_disableRootThemeClass : getSetting("disableRootThemeClass"), _props_themeClassNameOnRoot, themeClassNameOnRoot = (_props_themeClassNameOnRoot = props.themeClassNameOnRoot) !== null && _props_themeClassNameOnRoot !== void 0 ? _props_themeClassNameOnRoot : getSetting("themeClassNameOnRoot");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
    className: props.className,
    name: props.defaultTheme,
    // if root class disabled, force class here
    forceClassName: !disableRootThemeClass && !themeClassNameOnRoot,
    // @ts-expect-error
    _isRoot: React.useId,
    children: props.children
  });
};
function TamaguiProvider$2(param) {
  var {
    children,
    disableInjectCSS,
    config,
    className,
    defaultTheme,
    disableRootThemeClass,
    reset,
    themeClassNameOnRoot
  } = param;
  useIsomorphicLayoutEffect(function() {
    updateMediaListeners();
  }, []);
  var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(UnmountedClassName, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ComponentContext.Provider, {
      animationDriver: config == null ? void 0 : config.animations,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, {
        themeClassNameOnRoot: themeClassNameOnRoot != null ? themeClassNameOnRoot : getSetting("themeClassNameOnRoot"),
        disableRootThemeClass: disableRootThemeClass != null ? disableRootThemeClass : getSetting("disableRootThemeClass"),
        defaultTheme: defaultTheme != null ? defaultTheme : config ? Object.keys(config.themes)[0] : "",
        reset,
        className,
        children
      })
    })
  });
  return getSetting("disableSSR") && (contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ClientOnly, {
    enabled: true,
    children: contents
  })), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [contents, false]
  });
}
function UnmountedClassName(props) {
  var [mounted, setMounted] = React.useState(false);
  return React.useEffect(function() {
    setMounted(true);
  }, []), props.children;
}
TamaguiProvider$2.displayName = "TamaguiProvider";
var ellipsisStyle = {
  numberOfLines: 1,
  lineBreakMode: "clip"
}, Text$4 = createComponent({
  acceptsClassName: true,
  isText: true,
  defaultProps: {
    fontFamily: "unset",
    suppressHighlighting: true
  },
  inlineWhenUnflattened: /* @__PURE__ */ new Set(["fontFamily"]),
  variants: {
    /**
    * @deprecated Use ellipsis instead
    */
    ellipse: {
      true: ellipsisStyle
    },
    ellipsis: {
      true: ellipsisStyle
    }
  },
  validStyles: __spreadValues(__spreadValues({}, validStyles), stylePropsTextOnly)
});
Text$4.displayName = "Text";
var View$3 = createComponent({
  acceptsClassName: true,
  defaultProps: stackDefaultStyles,
  validStyles
});
function useGet(currentValue, initialValue2, forwardToFunction) {
  var curRef = React__namespace.useRef(initialValue2 != null ? initialValue2 : currentValue);
  return useIsomorphicLayoutEffect(function() {
    curRef.current = currentValue;
  }), React__namespace.useCallback(forwardToFunction ? function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
    var _curRef_current;
    return (_curRef_current = curRef.current) === null || _curRef_current === void 0 ? void 0 : _curRef_current.apply(null, args);
  } : function() {
    return curRef.current;
  }, []);
}
function useEvent$1(callback) {
  return useGet(callback, defaultValue, true);
}
var defaultValue = function() {
  throw new Error("Cannot call an event handler while rendering.");
};
const emptyObject$4 = {}, hasOwnProperty = Object.prototype.hasOwnProperty, isArray = Array.isArray, uppercasePattern = /[A-Z]/g;
function toHyphenLower(match) {
  return "-" + match.toLowerCase();
}
function hyphenateString(str) {
  return str.replace(uppercasePattern, toHyphenLower);
}
function processIDRefList(idRefList) {
  return isArray(idRefList) ? idRefList.join(" ") : idRefList;
}
function flattenStyle$1(style) {
  if (style === null || typeof style != "object") return;
  if (!isArray(style)) return style;
  const result = {};
  for (let i = 0, styleLength = style.length; i < styleLength; ++i) {
    const computedStyle = flattenStyle$1(style[i]);
    if (computedStyle) for (const key in computedStyle) hasOwnProperty.call(computedStyle, key) && (result[key] = computedStyle[key]);
  }
  return result;
}
const stylesFromProps = /* @__PURE__ */ new WeakMap(), createDOMProps = (elementType, props, options) => {
  props || (props = emptyObject$4);
  const _a = props, {
    accessibilityActiveDescendant,
    accessibilityAtomic,
    accessibilityAutoComplete,
    accessibilityBusy,
    accessibilityChecked,
    accessibilityColumnCount,
    accessibilityColumnIndex,
    accessibilityColumnSpan,
    accessibilityControls,
    accessibilityCurrent,
    accessibilityDescribedBy,
    accessibilityDetails,
    accessibilityDisabled,
    accessibilityErrorMessage,
    accessibilityExpanded,
    accessibilityFlowTo,
    accessibilityHasPopup,
    accessibilityHidden,
    accessibilityInvalid,
    accessibilityKeyShortcuts,
    accessibilityLabel,
    accessibilityLabelledBy,
    accessibilityLevel,
    accessibilityLiveRegion,
    accessibilityModal,
    accessibilityMultiline,
    accessibilityMultiSelectable,
    accessibilityOrientation,
    accessibilityOwns,
    accessibilityPlaceholder,
    accessibilityPosInSet,
    accessibilityPressed,
    accessibilityReadOnly,
    accessibilityRequired,
    accessibilityRole: accessibilityRole,
    accessibilityRoleDescription: accessibilityRoleDescription,
    accessibilityRowCount,
    accessibilityRowIndex,
    accessibilityRowSpan,
    accessibilitySelected,
    accessibilitySetSize,
    accessibilitySort,
    accessibilityValueMax,
    accessibilityValueMin,
    accessibilityValueNow,
    accessibilityValueText,
    dataSet,
    focusable,
    nativeID,
    pointerEvents,
    style,
    testID,
    id: id2
  } = _a, domProps = __objRest(_a, [
    "accessibilityActiveDescendant",
    "accessibilityAtomic",
    "accessibilityAutoComplete",
    "accessibilityBusy",
    "accessibilityChecked",
    "accessibilityColumnCount",
    "accessibilityColumnIndex",
    "accessibilityColumnSpan",
    "accessibilityControls",
    "accessibilityCurrent",
    "accessibilityDescribedBy",
    "accessibilityDetails",
    "accessibilityDisabled",
    "accessibilityErrorMessage",
    "accessibilityExpanded",
    "accessibilityFlowTo",
    "accessibilityHasPopup",
    "accessibilityHidden",
    "accessibilityInvalid",
    "accessibilityKeyShortcuts",
    "accessibilityLabel",
    "accessibilityLabelledBy",
    "accessibilityLevel",
    "accessibilityLiveRegion",
    "accessibilityModal",
    "accessibilityMultiline",
    "accessibilityMultiSelectable",
    "accessibilityOrientation",
    "accessibilityOwns",
    "accessibilityPlaceholder",
    "accessibilityPosInSet",
    "accessibilityPressed",
    "accessibilityReadOnly",
    "accessibilityRequired",
    /* eslint-disable */
    "accessibilityRole",
    /* eslint-enable */
    "accessibilityRoleDescription",
    "accessibilityRowCount",
    "accessibilityRowIndex",
    "accessibilityRowSpan",
    "accessibilitySelected",
    "accessibilitySetSize",
    "accessibilitySort",
    "accessibilityValueMax",
    "accessibilityValueMin",
    "accessibilityValueNow",
    "accessibilityValueText",
    "dataSet",
    "focusable",
    "nativeID",
    "pointerEvents",
    "style",
    "testID",
    "id"
  ]), disabled = accessibilityDisabled, role = AccessibilityUtil.propsToAriaRole(props);
  accessibilityActiveDescendant != null && (domProps["aria-activedescendant"] = accessibilityActiveDescendant), accessibilityAtomic != null && (domProps["aria-atomic"] = accessibilityAtomic), accessibilityAutoComplete != null && (domProps["aria-autocomplete"] = accessibilityAutoComplete), accessibilityBusy != null && (domProps["aria-busy"] = accessibilityBusy), accessibilityChecked != null && (domProps["aria-checked"] = accessibilityChecked), accessibilityColumnCount != null && (domProps["aria-colcount"] = accessibilityColumnCount), accessibilityColumnIndex != null && (domProps["aria-colindex"] = accessibilityColumnIndex), accessibilityColumnSpan != null && (domProps["aria-colspan"] = accessibilityColumnSpan), accessibilityControls != null && (domProps["aria-controls"] = processIDRefList(accessibilityControls)), accessibilityCurrent != null && (domProps["aria-current"] = accessibilityCurrent), accessibilityDescribedBy != null && (domProps["aria-describedby"] = processIDRefList(accessibilityDescribedBy)), accessibilityDetails != null && (domProps["aria-details"] = accessibilityDetails), disabled === true && (domProps["aria-disabled"] = true, (elementType === "button" || elementType === "form" || elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.disabled = true)), accessibilityErrorMessage != null && (domProps["aria-errormessage"] = accessibilityErrorMessage), accessibilityExpanded != null && (domProps["aria-expanded"] = accessibilityExpanded), accessibilityFlowTo != null && (domProps["aria-flowto"] = processIDRefList(accessibilityFlowTo)), accessibilityHasPopup != null && (domProps["aria-haspopup"] = accessibilityHasPopup), accessibilityHidden === true && (domProps["aria-hidden"] = accessibilityHidden), accessibilityInvalid != null && (domProps["aria-invalid"] = accessibilityInvalid), accessibilityKeyShortcuts != null && Array.isArray(accessibilityKeyShortcuts) && (domProps["aria-keyshortcuts"] = accessibilityKeyShortcuts.join(" ")), accessibilityLabel != null && (domProps["aria-label"] = accessibilityLabel), accessibilityLabelledBy != null && (domProps["aria-labelledby"] = processIDRefList(accessibilityLabelledBy)), accessibilityLevel != null && (domProps["aria-level"] = accessibilityLevel), accessibilityLiveRegion != null && (domProps["aria-live"] = accessibilityLiveRegion === "none" ? "off" : accessibilityLiveRegion), accessibilityModal != null && (domProps["aria-modal"] = accessibilityModal), accessibilityMultiline != null && (domProps["aria-multiline"] = accessibilityMultiline), accessibilityMultiSelectable != null && (domProps["aria-multiselectable"] = accessibilityMultiSelectable), accessibilityOrientation != null && (domProps["aria-orientation"] = accessibilityOrientation), accessibilityOwns != null && (domProps["aria-owns"] = processIDRefList(accessibilityOwns)), accessibilityPlaceholder != null && (domProps["aria-placeholder"] = accessibilityPlaceholder), accessibilityPosInSet != null && (domProps["aria-posinset"] = accessibilityPosInSet), accessibilityPressed != null && (domProps["aria-pressed"] = accessibilityPressed), accessibilityReadOnly != null && (domProps["aria-readonly"] = accessibilityReadOnly, (elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.readOnly = true)), accessibilityRequired != null && (domProps["aria-required"] = accessibilityRequired, (elementType === "input" || elementType === "select" || elementType === "textarea") && (domProps.required = true)), role != null && (domProps.role = role === "none" ? "presentation" : role), accessibilityRoleDescription != null && (domProps["aria-roledescription"] = accessibilityRoleDescription), accessibilityRowCount != null && (domProps["aria-rowcount"] = accessibilityRowCount), accessibilityRowIndex != null && (domProps["aria-rowindex"] = accessibilityRowIndex), accessibilityRowSpan != null && (domProps["aria-rowspan"] = accessibilityRowSpan), accessibilitySelected != null && (domProps["aria-selected"] = accessibilitySelected), accessibilitySetSize != null && (domProps["aria-setsize"] = accessibilitySetSize), accessibilitySort != null && (domProps["aria-sort"] = accessibilitySort), accessibilityValueMax != null && (domProps["aria-valuemax"] = accessibilityValueMax), accessibilityValueMin != null && (domProps["aria-valuemin"] = accessibilityValueMin), accessibilityValueNow != null && (domProps["aria-valuenow"] = accessibilityValueNow), accessibilityValueText != null && (domProps["aria-valuetext"] = accessibilityValueText);
  const tmgCN = dataSet ? dataSet.className : void 0, tmgID = dataSet ? dataSet.id : void 0;
  if (dataSet != null) {
    for (const dataProp in dataSet) if (!(dataProp === "className" || dataProp === "id") && hasOwnProperty.call(dataSet, dataProp)) {
      const dataName = hyphenateString(dataProp), dataValue = dataSet[dataProp];
      dataValue != null && (domProps[`data-${dataName}`] = dataValue);
    }
  }
  focusable === false && (domProps.tabIndex = "-1"), // These native elements are keyboard focusable by default
  elementType === "a" || elementType === "button" || elementType === "input" || elementType === "select" || elementType === "textarea" ? (focusable === false || accessibilityDisabled === true) && (domProps.tabIndex = "-1") : (
    /* These roles are made keyboard focusable by default */
    role === "button" || role === "checkbox" || role === "link" || role === "radio" || role === "textbox" || role === "switch" ? focusable !== false && (domProps.tabIndex = "0") : focusable === true && (domProps.tabIndex = "0")
  );
  flattenStyle$1(style);
  let className = tmgCN || "";
  props.className && (className += ` ${props.className}`);
  const stylesAtomic = getCSSStylesAtomic();
  stylesFromProps.set(domProps, stylesAtomic), domProps.style = stylesAtomic.reduce((acc, [key, value]) => key[0] === "_" || key.startsWith("is_") || key.startsWith("font_") ? (className += ` ${key}`, acc) : (key === "$$css" || key === "" || (acc[key] = value), acc), {}), className && (domProps.className = className);
  const _id = tmgID || id2 || nativeID;
  return _id && (domProps.id = _id), testID != null && (domProps["data-testid"] = testID), domProps;
};
const isWebColor$1 = (color) => color === "currentcolor" || color === "currentColor" || color === "inherit" || color.startsWith("var(");
const processColor$1 = (color) => {
  if (color == null)
    return color;
  let int32Color = index_default(color);
  if (int32Color != null)
    return int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0, int32Color;
};
const normalizeColor$1 = (color, opacity = 1) => {
  if (color == null) return;
  if (typeof color == "string" && isWebColor$1(color)) return color;
  const colorInt = processColor$1(color);
  if (colorInt != null) {
    const r = colorInt >> 16 & 255, g = colorInt >> 8 & 255, b2 = colorInt & 255, alpha = ((colorInt >> 24 & 255) / 255 * opacity).toFixed(2);
    return `rgba(${r},${g},${b2},${alpha})`;
  }
  if (typeof color == "string") return color;
};
function normalizeValueWithProperty(value, property) {
  let returnValue = value;
  return typeof value == "number" ? returnValue = `${value}px` : property != null, returnValue;
}
const focusableElements$1 = {
  A: true,
  INPUT: true,
  SELECT: true,
  TEXTAREA: true
}, UIManager$1 = {
  blur(node) {
    try {
      node.blur();
    } catch (e2) {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements$1[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch (e2) {
    }
  },
  measure(node, callback) {
    return measure(node, callback);
  },
  measureInWindow(node, callback) {
    return measureInWindow(node, callback);
  },
  // note its flipped fail and success on purpose lol
  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    return __async(this, null, function* () {
      return measureLayout(node, relativeToNativeNode, onSuccess);
    });
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
const TextInputState = {
  /**
   * Internal state
   */
  _currentlyFocusedNode: null,
  /**
   * Returns the ID of the currently focused text field, if one exists
   * If no text field is focused it returns null
   */
  currentlyFocusedField() {
    return document.activeElement !== this._currentlyFocusedNode && (this._currentlyFocusedNode = null), this._currentlyFocusedNode;
  },
  /**
   * @param {Object} TextInputID id of the text field to focus
   * Focuses the specified text field
   * noop if the text field was already focused
   */
  focusTextInput(textFieldNode) {
    textFieldNode !== null && (this._currentlyFocusedNode = textFieldNode, document.activeElement !== textFieldNode && UIManager$1.focus(textFieldNode));
  },
  /**
   * @param {Object} textFieldNode id of the text field to focus
   * Unfocuses the specified text field
   * noop if it wasn't focused
   */
  blurTextInput(textFieldNode) {
    textFieldNode !== null && (this._currentlyFocusedNode = null, document.activeElement === textFieldNode && UIManager$1.blur(textFieldNode));
  }
};
const dismissKeyboard = () => {
  TextInputState.blurTextInput(TextInputState.currentlyFocusedField());
};
const dataUriPattern = /^data:/;
const _ImageUriCache = class _ImageUriCache {
  static has(uri) {
    const entries = _ImageUriCache._entries;
    return dataUriPattern.test(uri) || !!entries[uri];
  }
  static add(uri) {
    const entries = _ImageUriCache._entries, lastUsedTimestamp = Date.now();
    entries[uri] ? (entries[uri].lastUsedTimestamp = lastUsedTimestamp, entries[uri].refCount += 1) : entries[uri] = {
      lastUsedTimestamp,
      refCount: 1
    };
  }
  static remove(uri) {
    const entries = _ImageUriCache._entries;
    entries[uri] && (entries[uri].refCount -= 1), _ImageUriCache._cleanUpIfNeeded();
  }
  static _cleanUpIfNeeded() {
    const entries = _ImageUriCache._entries, imageUris = Object.keys(entries);
    if (imageUris.length + 1 > _ImageUriCache._maximumEntries) {
      let leastRecentlyUsedKey, leastRecentlyUsedEntry;
      imageUris.forEach((uri) => {
        const entry = entries[uri];
        (!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0 && (leastRecentlyUsedKey = uri, leastRecentlyUsedEntry = entry);
      }), leastRecentlyUsedKey && delete entries[leastRecentlyUsedKey];
    }
  }
};
__publicField(_ImageUriCache, "_maximumEntries", 256);
__publicField(_ImageUriCache, "_entries", {});
let ImageUriCache = _ImageUriCache;
let id = 0;
const requests = {}, ImageLoader = {
  abort(requestId) {
    let image = requests[`${requestId}`];
    image && (image.onerror = null, image.onload = null, image = null, delete requests[`${requestId}`]);
  },
  getSize(uri, success, failure) {
    let complete = false;
    const interval = setInterval(callback, 16), requestId = ImageLoader.load(uri, callback, errorCallback);
    function callback() {
      const image = requests[`${requestId}`];
      if (image) {
        const {
          naturalHeight,
          naturalWidth
        } = image;
        naturalHeight && naturalWidth && (success(naturalWidth, naturalHeight), complete = true);
      }
      complete && (ImageLoader.abort(requestId), clearInterval(interval));
    }
    function errorCallback() {
      typeof failure == "function" && failure(), ImageLoader.abort(requestId), clearInterval(interval);
    }
  },
  has(uri) {
    return ImageUriCache.has(uri);
  },
  load(uri, onLoad, onError) {
    id += 1;
    const image = new window.Image();
    return image.onerror = onError, image.onload = (e2) => {
      const onDecode = () => onLoad({
        nativeEvent: e2
      });
      typeof image.decode == "function" ? image.decode().then(onDecode, onDecode) : setTimeout(onDecode, 0);
    }, image.src = uri, requests[`${id}`] = image, id;
  },
  prefetch(uri) {
    return new Promise((resolve, reject) => {
      ImageLoader.load(uri, () => {
        ImageUriCache.add(uri), ImageUriCache.remove(uri), resolve();
      }, reject);
    });
  },
  queryCache(uris) {
    const result = {};
    return uris.forEach((u) => {
      ImageUriCache.has(u) && (result[u] = "disk/memory");
    }), Promise.resolve(result);
  }
};
const isWebColor = (color) => color === "currentcolor" || color === "currentColor" || color === "inherit" || color.startsWith("var(");
const processColor = (color) => {
  if (color == null) return color;
  let int32Color = index_default(color);
  if (int32Color != null) return int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0, int32Color;
};
const normalizeColor = (color, opacity = 1) => {
  if (color == null) return;
  if (typeof color == "string" && isWebColor(color)) return color;
  const colorInt = processColor(color);
  if (colorInt != null) {
    const r = colorInt >> 16 & 255, g = colorInt >> 8 & 255, b2 = colorInt & 255, alpha = ((colorInt >> 24 & 255) / 255 * opacity).toFixed(2);
    return `rgba(${r},${g},${b2},${alpha})`;
  }
};
function pick(obj, list) {
  const nextObj = {};
  for (const key in obj) obj.hasOwnProperty(key) && list[key] === true && (nextObj[key] = obj[key]);
  return nextObj;
}
const Platform = {
  OS: "web"
};
const defaultOffset = {
  height: 0,
  width: 0
}, createBoxShadowValue = (style) => {
  const {
    shadowColor,
    shadowOffset,
    shadowOpacity,
    shadowRadius
  } = style, {
    height,
    width
  } = shadowOffset || defaultOffset, offsetX = normalizeValueWithProperty(width), offsetY = normalizeValueWithProperty(height), blurRadius = normalizeValueWithProperty(shadowRadius || 0), color = normalizeColor$1(shadowColor || "black", shadowOpacity);
  if (color != null && offsetX != null && offsetY != null && blurRadius != null) return `${offsetX} ${offsetY} ${blurRadius} ${color}`;
};
const absoluteFillObject = {
  position: "absolute",
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
}, absoluteFill = absoluteFillObject;
function create(styles2) {
  return styles2;
}
function compose(style1, style2) {
  return flatten(style1, style2);
}
function flatten(...styles2) {
  return styles2.flat().flat().flat().flat().reduce((acc, cur) => (cur && Object.assign(acc, cur), acc), {});
}
function getSheet() {
  return {
    id: "",
    textContent: sheet.getTextContent()
  };
}
function StyleSheet(styles2, options) {
}
StyleSheet.absoluteFill = absoluteFill;
StyleSheet.absoluteFillObject = absoluteFillObject;
StyleSheet.create = create;
StyleSheet.compose = compose;
StyleSheet.flatten = flatten;
StyleSheet.getSheet = getSheet;
StyleSheet.hairlineWidth = 1;
const _requestIdleCallback = function(cb, options) {
  return setTimeout(() => {
    const start = Date.now();
    cb({
      didTimeout: false,
      timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
}, isSupported = canUseDOM$1 && typeof window.requestIdleCallback < "u", requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;
const focusableElements = {
  A: true,
  INPUT: true,
  SELECT: true,
  TEXTAREA: true
}, UIManager = {
  blur(node) {
    try {
      node.blur();
    } catch (e2) {
    }
  },
  focus(node) {
    try {
      const name = node.nodeName;
      node.getAttribute("tabIndex") == null && focusableElements[name] == null && node.setAttribute("tabIndex", "-1"), node.focus();
    } catch (e2) {
    }
  },
  measure(node, callback) {
    return measure(node, callback);
  },
  measureInWindow(node, callback) {
    return measureInWindow(node, callback);
  },
  // note its flipped fail and success on purpose lol
  measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
    return __async(this, null, function* () {
      return measureLayout(node, relativeToNativeNode, onSuccess);
    });
  },
  configureNextLayoutAnimation(config, onAnimationDidEnd) {
    onAnimationDidEnd();
  },
  // mocks
  setLayoutAnimationEnabledExperimental() {
  }
};
function useElementLayout(ref, onLayout) {
  const wrappedRef = React.useMemo(() => ({
    current: {
      get host() {
        return ref.current;
      }
    }
  }), [ref]);
  return React.useEffect(() => {
    enable();
  }, []), useElementLayout$1(wrappedRef, onLayout);
}
const useLayoutEffectImpl = canUseDOM$1 ? React.useLayoutEffect : React.useEffect;
function useEvent(event, options) {
  const targetListeners = useStable(() => /* @__PURE__ */ new Map()), addListener = useStable(() => {
    const addEventListener = createEventHandle(event, options);
    return (target, callback) => {
      const removeTargetListener = targetListeners.get(target);
      removeTargetListener == null ? void 0 : removeTargetListener(), callback == null && targetListeners.delete(target);
      const removeEventListener = addEventListener(target, callback);
      return targetListeners.set(target, removeEventListener), removeEventListener;
    };
  });
  return useLayoutEffectImpl(() => () => {
    targetListeners.forEach((removeListener) => {
      removeListener();
    }), targetListeners.clear();
  }, [targetListeners]), addListener;
}
const emptyObject$3 = {}, opts = {
  passive: true
}, lockEventType = "react-gui:hover:lock", unlockEventType = "react-gui:hover:unlock", supportsPointerEvent = () => typeof window < "u" && window.PointerEvent != null;
function dispatchCustomEvent(target, type, payload) {
  const event = document.createEvent("CustomEvent"), {
    bubbles = true,
    cancelable = true,
    detail
  } = emptyObject$3;
  event.initCustomEvent(type, bubbles, cancelable, detail), target.dispatchEvent(event);
}
function getPointerType(event) {
  const {
    pointerType
  } = event;
  return pointerType != null ? pointerType : getModality();
}
function useHover(targetRef, config) {
  const {
    contain,
    disabled,
    onHoverStart,
    onHoverChange,
    onHoverUpdate,
    onHoverEnd
  } = config, canUsePE = supportsPointerEvent(), addMoveListener = useEvent(canUsePE ? "pointermove" : "mousemove", opts), addEnterListener = useEvent(canUsePE ? "pointerenter" : "mouseenter", opts), addLeaveListener = useEvent(canUsePE ? "pointerleave" : "mouseleave", opts), addLockListener = useEvent(lockEventType, opts), addUnlockListener = useEvent(unlockEventType, opts);
  useLayoutEffectImpl(() => {
    const target = targetRef.current;
    if (target !== null) {
      const hoverEnd = function(e2) {
        onHoverEnd == null ? void 0 : onHoverEnd(e2), onHoverChange == null ? void 0 : onHoverChange(false), addMoveListener(target, null), addLeaveListener(target, null);
      }, leaveListener = function(e2) {
        const target2 = targetRef.current;
        target2 != null && getPointerType(e2) !== "touch" && (contain && dispatchCustomEvent(target2, unlockEventType), hoverEnd(e2));
      }, moveListener = function(e2) {
        getPointerType(e2) !== "touch" && onHoverUpdate != null && (e2.x == null && (e2.x = e2.clientX), e2.y == null && (e2.y = e2.clientY), onHoverUpdate(e2));
      }, hoverStart = function(e2) {
        onHoverStart == null ? void 0 : onHoverStart(e2), onHoverChange == null ? void 0 : onHoverChange(true), onHoverUpdate != null && addMoveListener(target, disabled ? null : moveListener), addLeaveListener(target, disabled ? null : leaveListener);
      };
      addEnterListener(target, disabled ? null : function(e2) {
        const target2 = targetRef.current;
        if (target2 != null && getPointerType(e2) !== "touch") {
          contain && dispatchCustomEvent(target2, lockEventType), hoverStart(e2);
          const lockListener = function(lockEvent) {
            lockEvent.target !== target2 && hoverEnd(e2);
          }, unlockListener = function(lockEvent) {
            lockEvent.target !== target2 && hoverStart(e2);
          };
          addLockListener(target2, disabled ? null : lockListener), addUnlockListener(target2, disabled ? null : unlockListener);
        }
      });
    }
  }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);
}
function invariant(condition, log, ...logVars) {
  if (!condition) throw new Error(log);
}
function warning(condition, log, ...logVars) {
}
let EventEmitter$1 = class EventEmitter {
  constructor() {
    __publicField(this, "_registry", {});
  }
  addListener(eventType, listener, context2) {
    const registrations = this._allocate(eventType), registration = {
      context: context2,
      listener,
      remove: () => {
        registrations.delete(registration);
      }
    };
    return registrations.add(registration), registration;
  }
  emit(eventType, ...args) {
    const registrations = this._registry[eventType];
    if (registrations != null) for (const registration of Array.from(registrations)) registration.listener.apply(registration.context, args);
  }
  _allocate(eventType) {
    let registrations = this._registry[eventType];
    return registrations == null && (registrations = /* @__PURE__ */ new Set(), this._registry[eventType] = registrations), registrations;
  }
};
class TaskQueue {
  constructor({
    onMoreTasks
  }) {
    __publicField(this, "_queueStack");
    __publicField(this, "_onMoreTasks");
    this._onMoreTasks = onMoreTasks, this._queueStack = [{
      tasks: [],
      popable: true
    }];
  }
  enqueueTasks(tasks) {
    tasks.forEach((task) => this._enqueue(task));
  }
  cancelTasks(tasksToCancel) {
    this._queueStack = this._queueStack.map((queue2) => __spreadProps(__spreadValues({}, queue2), {
      tasks: queue2.tasks.filter((task) => !tasksToCancel.includes(task))
    })).filter((queue2, idx) => queue2.tasks.length > 0 || idx === 0);
  }
  hasTasksToProcess() {
    return this._getCurrentQueue().length > 0;
  }
  processNext() {
    const queue2 = this._getCurrentQueue();
    if (queue2.length) {
      const task = queue2.shift();
      try {
        typeof task == "object" && task && "gen" in task ? this._genPromise(task) : typeof task == "object" && task && "run" in task ? task.run() : (invariant(typeof task == "function", `Expected Function, SimpleTask, or PromiseTask, but got:
` + JSON.stringify(task, null, 2)), task());
      } catch (e2) {
        if (e2 instanceof Error) {
          const taskName = task && typeof task == "object" && "name" in task ? task.name : "";
          e2.message = "TaskQueue: Error with task " + taskName + ": " + e2.message;
        }
        throw e2;
      }
    }
  }
  _enqueue(task) {
    this._getCurrentQueue().push(task);
  }
  _getCurrentQueue() {
    const stackIdx = this._queueStack.length - 1, queue2 = this._queueStack[stackIdx];
    return queue2.popable && queue2.tasks.length === 0 && stackIdx > 0 ? (this._queueStack.pop(), this._getCurrentQueue()) : queue2.tasks;
  }
  _genPromise(task) {
    const stackIdx = this._queueStack.push({
      tasks: [],
      popable: false
    }) - 1, stackItem = this._queueStack[stackIdx];
    task.gen().then(() => {
      stackItem.popable = true, this.hasTasksToProcess() && this._onMoreTasks();
    }).catch((ex) => {
      setTimeout(() => {
        throw ex instanceof Error && (ex.message = `TaskQueue: Error resolving Promise in task ${task.name}: ${ex.message}`), ex;
      }, 0);
    });
  }
}
const _emitter = new EventEmitter$1(), InteractionManager = {
  Events: {
    interactionStart: "interactionStart",
    interactionComplete: "interactionComplete"
  },
  /**
   * Schedule a function to run after all interactions have completed.
   */
  runAfterInteractions(task) {
    const tasks = [], promise = new Promise((resolve) => {
      _scheduleUpdate(), task && tasks.push(task), tasks.push({
        run: resolve,
        name: "resolve " + (task && typeof task == "object" && "name" in task && task.name || "?")
      }), _taskQueue.enqueueTasks(tasks);
    });
    return {
      then: promise.then.bind(promise),
      done: promise.then.bind(promise),
      cancel: () => {
        _taskQueue.cancelTasks(tasks);
      }
    };
  },
  /**
   * Notify manager that an interaction has started.
   */
  createInteractionHandle() {
    _scheduleUpdate();
    const handle = ++_inc;
    return _addInteractionSet.add(handle), handle;
  },
  /**
   * Notify manager that an interaction has completed.
   */
  clearInteractionHandle(handle) {
    invariant(!!handle, "Must provide a handle to clear."), _scheduleUpdate(), _addInteractionSet.delete(handle), _deleteInteractionSet.add(handle);
  },
  addListener: _emitter.addListener.bind(_emitter),
  /**
   * Set deadline for task processing
   */
  setDeadline(deadline) {
    _deadline = deadline;
  }
}, _interactionSet = /* @__PURE__ */ new Set(), _addInteractionSet = /* @__PURE__ */ new Set(), _deleteInteractionSet = /* @__PURE__ */ new Set(), _taskQueue = new TaskQueue({
  onMoreTasks: _scheduleUpdate
});
let _nextUpdateHandle = null, _inc = 0, _deadline = -1;
function _scheduleUpdate() {
  _nextUpdateHandle || (_deadline > 0 ? _nextUpdateHandle = setTimeout(_processUpdate) : _nextUpdateHandle = requestIdleCallback(_processUpdate));
}
function _processUpdate() {
  _nextUpdateHandle = null;
  const interactionCount = _interactionSet.size;
  _addInteractionSet.forEach((handle) => _interactionSet.add(handle)), _deleteInteractionSet.forEach((handle) => _interactionSet.delete(handle));
  const nextInteractionCount = _interactionSet.size;
  if (interactionCount !== 0 && nextInteractionCount === 0 ? _emitter.emit("interactionComplete") : interactionCount === 0 && nextInteractionCount !== 0 && _emitter.emit("interactionStart"), nextInteractionCount === 0) {
    const begin = Date.now();
    for (; _taskQueue.hasTasksToProcess(); ) if (_taskQueue.processNext(), _deadline > 0 && Date.now() - begin >= _deadline) {
      _scheduleUpdate();
      break;
    }
  }
  _addInteractionSet.clear(), _deleteInteractionSet.clear();
}
function useMergeRefs$1(...args) {
  return React__namespace.useMemo(
    () => mergeRefs(...args),
    // eslint-disable-next-line
    [...args]
  );
}
const useCreateElement$1 = (component, props, options) => {
  const {
    element,
    styles: styles2
  } = createElementAndStyles$1(component, props);
  useDidFinishSSR();
  const styleTags = React.useMemo(() => null, [
    // never changes
  ]);
  return React.useInsertionEffect(() => {
    if (!styles2) return;
    const styleObj = {};
    for (const style of styles2) styleObj[style[0]] = style;
  }, [styles2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [element, styleTags]
  });
}, createElement$1 = (component, props, options) => {
  const {
    element,
    styles: styles2
  } = createElementAndStyles$1(component, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [element, styles2 ? getStyleTags() : null]
  });
}, createElementAndStyles$1 = (component, props, options) => {
  let accessibilityComponent;
  component && component.constructor === String && (accessibilityComponent = AccessibilityUtil.propsToAccessibilityComponent(props));
  const Component = accessibilityComponent || component, domProps = createDOMProps(Component, props), styles2 = stylesFromProps.get(domProps);
  let element = React.createElement(Component, domProps);
  return {
    element: domProps.dir ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleProvider, {
      direction: domProps.dir,
      locale: domProps.lang,
      children: element
    }) : element,
    styles: styles2
  };
};
const spec = {
  createAnimatedNode: (tag, config) => {
  },
  getValue: (tag, saveValueCallback) => {
  },
  startListeningToAnimatedNodeValue: (tag) => {
  },
  stopListeningToAnimatedNodeValue: (tag) => {
  },
  connectAnimatedNodes: (parentTag, childTag) => {
  },
  disconnectAnimatedNodes: (parentTag, childTag) => {
  },
  startAnimatingNode: (animationId, nodeTag, config, endCallback) => {
  },
  stopAnimation: (animationId) => {
  },
  setAnimatedNodeValue: (nodeTag, value) => {
  },
  setAnimatedNodeOffset: (nodeTag, offset2) => {
  },
  flattenAnimatedNodeOffset: (nodeTag) => {
  },
  extractAnimatedNodeOffset: (nodeTag) => {
  },
  connectAnimatedNodeToView: (nodeTag, viewTag) => {
  },
  disconnectAnimatedNodeFromView: (nodeTag, viewTag) => {
  },
  restoreDefaultValues: (nodeTag) => {
  },
  dropAnimatedNode: (tag) => {
  },
  addAnimatedEventToView: (viewTag, eventName, eventMapping) => {
  },
  removeAnimatedEventFromView: (viewTag, eventName, animatedNodeTag) => {
  }
}, NativeAnimatedNonTurboModule = spec;
class _EventSubscription {
  /**
   * @param {EventSubscriptionVendor} subscriber the subscriber that controls
   *   this subscription.
   */
  constructor(subscriber) {
    this.subscriber = subscriber;
  }
  /**
   * Removes this subscription from the subscriber that controls it.
   */
  remove() {
    this.subscriber.removeSubscription(this);
  }
}
class EmitterSubscription extends _EventSubscription {
  /**
   * @param {EventEmitter} emitter - The event emitter that registered this
   *   subscription
   * @param {EventSubscriptionVendor} subscriber - The subscriber that controls
   *   this subscription
   * @param {function} listener - Function to invoke when the specified event is
   *   emitted
   * @param {*} context - Optional context object to use when invoking the
   *   listener
   */
  constructor(emitter, subscriber, listener, context2) {
    super(subscriber), this.emitter = emitter, this.listener = listener, this.context = context2;
  }
  /**
   * Removes this subscription from the emitter that registered it.
   * Note: we're overriding the `remove()` method of _EventSubscription here
   * but deliberately not calling `super.remove()` as the responsibility
   * for removing the subscription lies with the EventEmitter.
   */
  remove() {
    this.emitter.removeSubscription(this);
  }
}
class EventSubscriptionVendor {
  constructor() {
    this._subscriptionsForType = {};
  }
  /**
   * Adds a subscription keyed by an event type.
   *
   * @param {string} eventType
   * @param {EventSubscription} subscription
   */
  addSubscription(eventType, subscription) {
    invariant(subscription.subscriber === this, "The subscriber of the subscription is incorrectly set."), this._subscriptionsForType[eventType] || (this._subscriptionsForType[eventType] = []);
    var key = this._subscriptionsForType[eventType].length;
    return this._subscriptionsForType[eventType].push(subscription), subscription.eventType = eventType, subscription.key = key, subscription;
  }
  /**
   * Removes a bulk set of the subscriptions.
   *
   * @param {?string} eventType - Optional name of the event type whose
   *   registered supscriptions to remove, if null remove all subscriptions.
   */
  removeAllSubscriptions(eventType) {
    eventType == null ? this._subscriptionsForType = {} : delete this._subscriptionsForType[eventType];
  }
  /**
   * Removes a specific subscription. Instead of calling this function, call
   * `subscription.remove()` directly.
   *
   * @param {object} subscription
   */
  removeSubscription(subscription) {
    var eventType = subscription.eventType, key = subscription.key, subscriptionsForType = this._subscriptionsForType[eventType];
    subscriptionsForType && delete subscriptionsForType[key];
  }
  /**
   * Returns the array of subscriptions that are currently registered for the
   * given event type.
   *
   * Note: This array can be potentially sparse as subscriptions are deleted
   * from it when they are removed.
   *
   * TODO: This returns a nullable array. wat?
   *
   * @param {string} eventType
   * @returns {?array}
   */
  getSubscriptionsForType(eventType) {
    return this._subscriptionsForType[eventType];
  }
}
var sparseFilterPredicate = () => true;
class EventEmitter2 {
  /**
   * @constructor
   *
   * @param {EventSubscriptionVendor} subscriber - Optional subscriber instance
   *   to use. If omitted, a new subscriber will be created for the emitter.
   */
  constructor(subscriber = new EventSubscriptionVendor()) {
    this._subscriber = subscriber;
  }
  /**
   * Adds a listener to be invoked when events of the specified type are
   * emitted. An optional calling context may be provided. The data arguments
   * emitted will be passed to the listener function.
   *
   * TODO: Annotate the listener arg's type. This is tricky because listeners
   *       can be invoked with varargs.
   *
   * @param {string} eventType - Name of the event to listen to
   * @param {function} listener - Function to invoke when the specified event is
   *   emitted
   * @param {*} context - Optional context object to use when invoking the
   *   listener
   */
  addListener(eventType, listener, context2) {
    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this, this._subscriber, listener, context2));
  }
  /**
   * Removes all of the registered listeners, including those registered as
   * listener maps.
   *
   * @param {?string} eventType - Optional name of the event whose registered
   *   listeners to remove
   */
  removeAllListeners(eventType) {
    this._subscriber.removeAllSubscriptions(eventType);
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeSubscription(subscription) {
    invariant(subscription.emitter === this, "Subscription does not belong to this emitter."), this._subscriber.removeSubscription(subscription);
  }
  /**
   * Returns the number of listeners that are currently registered for the given
   * event.
   *
   * @param {string} eventType - Name of the event to query
   * @returns {number}
   */
  listenerCount(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    return subscriptions ? (
      // "callbackfn is called only for elements of the array which actually
      // exist; it is not called for missing elements of the array."
      // https://www.ecma-international.org/ecma-262/9.0/index.html#sec-array.prototype.filter
      subscriptions.filter(sparseFilterPredicate).length
    ) : 0;
  }
  /**
   * Emits an event of the given type with the given data. All handlers of that
   * particular type will be notified.
   *
   * @param {string} eventType - Name of the event to emit
   * @param {...*} Arbitrary arguments to be passed to each registered listener
   *
   * @example
   *   emitter.addListener('someEvent', function(message) {
   *     console.log(message);
   *   });
   *
   *   emitter.emit('someEvent', 'abc'); // logs 'abc'
   */
  emit(eventType) {
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    if (subscriptions) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
      for (var i = 0, l = subscriptions.length; i < l; i++) {
        var subscription = subscriptions[i];
        subscription && subscription.listener && subscription.listener.apply(subscription.context, args);
      }
    }
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeListener(eventType, listener) {
    console.error("EventEmitter.removeListener('" + eventType + "', ...): Method has been deprecated. Please instead use `remove()` on the subscription returned by `EventEmitter.addListener`.");
    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);
    if (subscriptions) for (var i = 0, l = subscriptions.length; i < l; i++) {
      var subscription = subscriptions[i];
      subscription && subscription.listener === listener && subscription.remove();
    }
  }
}
const RCTDeviceEventEmitter = new EventEmitter2();
class NativeEventEmitter {
  constructor(nativeModule) {
    __publicField(this, "_nativeModule");
  }
  addListener(eventType, listener, context2) {
    var _a;
    (_a = this._nativeModule) == null ? void 0 : _a.addListener(eventType);
    let subscription = RCTDeviceEventEmitter.addListener(eventType, listener, context2);
    return {
      remove: () => {
        var _a2;
        subscription != null && ((_a2 = this._nativeModule) == null ? void 0 : _a2.removeListeners(1), subscription.remove(), subscription = null);
      }
    };
  }
  /**
   * @deprecated Use `remove` on the EventSubscription from `addListener`.
   */
  removeListener(eventType, listener) {
    var _a;
    (_a = this._nativeModule) == null ? void 0 : _a.removeListeners(1), RCTDeviceEventEmitter.removeListener(eventType, listener);
  }
  emit(eventType, ...args) {
    RCTDeviceEventEmitter.emit(eventType, ...args);
  }
  removeAllListeners(eventType) {
    var _a;
    invariant(eventType != null, "`NativeEventEmitter.removeAllListener()` requires a non-null argument."), (_a = this._nativeModule) == null ? void 0 : _a.removeListeners(this.listenerCount(eventType)), RCTDeviceEventEmitter.removeAllListeners(eventType);
  }
  listenerCount(eventType) {
    return RCTDeviceEventEmitter.listenerCount(eventType);
  }
}
const ReactNativeFeatureFlags = {
  isLayoutAnimationEnabled: () => true,
  shouldEmitW3CPointerEvents: () => false,
  shouldPressibilityUseW3CPointerEventsForHover: () => false,
  animatedShouldDebounceQueueFlush: () => false,
  animatedShouldUseSingleOp: () => false
};
const NativeAnimatedModule = NativeAnimatedNonTurboModule;
let __nativeAnimatedNodeTagCount = 1, __nativeAnimationIdCount = 1, nativeEventEmitter, waitingForQueuedOperations = /* @__PURE__ */ new Set(), queueOperations = false, queue = [];
const nativeOps = NativeAnimatedModule, API = {
  getValue: function(tag, saveValueCallback) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.getValue, tag, saveValueCallback);
  },
  setWaitingForIdentifier: function(id2) {
    waitingForQueuedOperations.add(id2), queueOperations = true;
  },
  unsetWaitingForIdentifier: function(id2) {
    waitingForQueuedOperations.delete(id2), waitingForQueuedOperations.size === 0 && (queueOperations = false, API.disableQueue());
  },
  disableQueue: function() {
    if (invariant(nativeOps, "Native animated module is not available"), ReactNativeFeatureFlags.animatedShouldDebounceQueueFlush()) ;
  },
  flushQueue: function() {
  },
  queueOperation: (fn, ...args) => {
    queueOperations || queue.length !== 0 ? queue.push(() => fn(...args)) : fn(...args);
  },
  createAnimatedNode: function(tag, config) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.createAnimatedNode, tag, config);
  },
  updateAnimatedNodeConfig: function(tag, config) {
    invariant(nativeOps, "Native animated module is not available");
  },
  startListeningToAnimatedNodeValue: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.startListeningToAnimatedNodeValue, tag);
  },
  stopListeningToAnimatedNodeValue: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.stopListeningToAnimatedNodeValue, tag);
  },
  connectAnimatedNodes: function(parentTag, childTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.connectAnimatedNodes, parentTag, childTag);
  },
  disconnectAnimatedNodes: function(parentTag, childTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.disconnectAnimatedNodes, parentTag, childTag);
  },
  startAnimatingNode: function(animationId, nodeTag, config, endCallback) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config, endCallback);
  },
  stopAnimation: function(animationId) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.stopAnimation, animationId);
  },
  setAnimatedNodeValue: function(nodeTag, value) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.setAnimatedNodeValue, nodeTag, value);
  },
  setAnimatedNodeOffset: function(nodeTag, offset2) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.setAnimatedNodeOffset, nodeTag, offset2);
  },
  flattenAnimatedNodeOffset: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.flattenAnimatedNodeOffset, nodeTag);
  },
  extractAnimatedNodeOffset: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.extractAnimatedNodeOffset, nodeTag);
  },
  connectAnimatedNodeToView: function(nodeTag, viewTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.connectAnimatedNodeToView, nodeTag, viewTag);
  },
  disconnectAnimatedNodeFromView: function(nodeTag, viewTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.disconnectAnimatedNodeFromView, nodeTag, viewTag);
  },
  restoreDefaultValues: function(nodeTag) {
    invariant(nativeOps, "Native animated module is not available"), nativeOps.restoreDefaultValues != null && API.queueOperation(nativeOps.restoreDefaultValues, nodeTag);
  },
  dropAnimatedNode: function(tag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.dropAnimatedNode, tag);
  },
  addAnimatedEventToView: function(viewTag, eventName, eventMapping) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.addAnimatedEventToView, viewTag, eventName, eventMapping);
  },
  removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
    invariant(nativeOps, "Native animated module is not available"), API.queueOperation(nativeOps.removeAnimatedEventFromView, viewTag, eventName, animatedNodeTag);
  }
};
const SUPPORTED_COLOR_STYLES = {
  backgroundColor: true,
  borderBottomColor: true,
  borderColor: true,
  borderEndColor: true,
  borderLeftColor: true,
  borderRightColor: true,
  borderStartColor: true,
  borderTopColor: true,
  color: true,
  tintColor: true
}, SUPPORTED_STYLES = __spreadProps(__spreadValues({}, SUPPORTED_COLOR_STYLES), {
  borderBottomEndRadius: true,
  borderBottomLeftRadius: true,
  borderBottomRightRadius: true,
  borderBottomStartRadius: true,
  borderRadius: true,
  borderTopEndRadius: true,
  borderTopLeftRadius: true,
  borderTopRightRadius: true,
  borderTopStartRadius: true,
  elevation: true,
  opacity: true,
  transform: true,
  zIndex: true,
  /* ios styles */
  shadowOpacity: true,
  shadowRadius: true,
  /* legacy android transform properties */
  scaleX: true,
  scaleY: true,
  translateX: true,
  translateY: true
}), SUPPORTED_TRANSFORMS = {
  translateX: true,
  translateY: true,
  scale: true,
  scaleX: true,
  scaleY: true,
  rotate: true,
  rotateX: true,
  rotateY: true,
  rotateZ: true,
  perspective: true
}, SUPPORTED_INTERPOLATION_PARAMS = {
  inputRange: true,
  outputRange: true,
  extrapolate: true,
  extrapolateRight: true,
  extrapolateLeft: true
};
function addWhitelistedStyleProp(prop) {
  SUPPORTED_STYLES[prop] = true;
}
function addWhitelistedTransformProp(prop) {
  SUPPORTED_TRANSFORMS[prop] = true;
}
function addWhitelistedInterpolationParam(param) {
  SUPPORTED_INTERPOLATION_PARAMS[param] = true;
}
function isSupportedColorStyleProp(prop) {
  return SUPPORTED_COLOR_STYLES.hasOwnProperty(prop);
}
function isSupportedStyleProp(prop) {
  return SUPPORTED_STYLES.hasOwnProperty(prop);
}
function isSupportedTransformProp(prop) {
  return SUPPORTED_TRANSFORMS.hasOwnProperty(prop);
}
function isSupportedInterpolationParam(param) {
  return SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(param);
}
function validateTransform(configs) {
  configs.forEach((config) => {
    if (!isSupportedTransformProp(config.property)) throw new Error(`Property '${config.property}' is not supported by native animated module`);
  });
}
function validateStyles(styles2) {
  for (const key in styles2) if (!isSupportedStyleProp(key)) throw new Error(`Style property '${key}' is not supported by native animated module`);
}
function validateInterpolation(config) {
  for (const key in config) if (!isSupportedInterpolationParam(key)) throw new Error(`Interpolation property '${key}' is not supported by native animated module`);
}
function generateNewNodeTag() {
  return __nativeAnimatedNodeTagCount++;
}
function generateNewAnimationId() {
  return __nativeAnimationIdCount++;
}
function assertNativeAnimatedModule() {
  invariant(NativeAnimatedModule, "Native animated module is not available");
}
let _warnedMissingNativeAnimated = false;
function shouldUseNativeDriver(config) {
  return config.useNativeDriver == null && console.warn("Animated: `useNativeDriver` was not specified. This is a required option and must be explicitly set to `true` or `false`"), config.useNativeDriver === true && !NativeAnimatedModule ? (_warnedMissingNativeAnimated || (console.warn("Animated: `useNativeDriver` is not supported because the native animated module is missing. Falling back to JS-based animation. To resolve this, add `RCTAnimation` module to this app, or remove `useNativeDriver`. Make sure to run `bundle exec pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md"), _warnedMissingNativeAnimated = true), false) : config.useNativeDriver || false;
}
function transformDataType(value) {
  return typeof value != "string" ? value : /deg$/.test(value) ? (parseFloat(value) || 0) * Math.PI / 180 : value;
}
const NativeAnimatedHelper = {
  API,
  isSupportedColorStyleProp,
  isSupportedStyleProp,
  isSupportedTransformProp,
  isSupportedInterpolationParam,
  addWhitelistedStyleProp,
  addWhitelistedTransformProp,
  addWhitelistedInterpolationParam,
  validateStyles,
  validateTransform,
  validateInterpolation,
  generateNewNodeTag,
  generateNewAnimationId,
  assertNativeAnimatedModule,
  shouldUseNativeDriver,
  transformDataType,
  get nativeEventEmitter() {
    return nativeEventEmitter || (nativeEventEmitter = new NativeEventEmitter(
      // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior
      // If you want to use the native module on other platforms, please remove this condition and test its behavior
      null
    )), nativeEventEmitter;
  }
};
const NativeAnimatedAPI$1 = NativeAnimatedHelper.API;
let _uniqueId = 1;
class AnimatedNode {
  constructor() {
    __publicField(this, "_listeners");
    __publicField(this, "_platformConfig");
    __publicField(this, "__nativeAnimatedValueListener");
    /* Methods and props used by native Animated impl */
    __publicField(this, "__isNative");
    __publicField(this, "__nativeTag");
    __publicField(this, "__shouldUpdateListenersForNewNativeTag");
    this._listeners = {};
  }
  __attach() {
  }
  __detach() {
    this.__isNative && this.__nativeTag != null && (NativeAnimatedHelper.API.dropAnimatedNode(this.__nativeTag), this.__nativeTag = void 0);
  }
  __getValue() {
  }
  __getAnimatedValue() {
    return this.__getValue();
  }
  __addChild(child) {
  }
  __removeChild(child) {
  }
  __getChildren() {
    return [];
  }
  __makeNative(platformConfig) {
    if (!this.__isNative) throw new Error('This node cannot be made a "native" animated node');
    this._platformConfig = platformConfig, this.hasListeners() && this._startListeningToNativeValueUpdates();
  }
  /**
   * Adds an asynchronous listener to the value so you can observe updates from
   * animations.  This is useful because there is no way to
   * synchronously read the value because it might be driven natively.
   *
   * See https://reactnative.dev/docs/animatedvalue#addlistener
   */
  addListener(callback) {
    const id2 = String(_uniqueId++);
    return this._listeners[id2] = callback, this.__isNative && this._startListeningToNativeValueUpdates(), id2;
  }
  /**
   * Unregister a listener. The `id` param shall match the identifier
   * previously returned by `addListener()`.
   *
   * See https://reactnative.dev/docs/animatedvalue#removelistener
   */
  removeListener(id2) {
    delete this._listeners[id2], this.__isNative && !this.hasListeners() && this._stopListeningForNativeValueUpdates();
  }
  /**
   * Remove all registered listeners.
   *
   * See https://reactnative.dev/docs/animatedvalue#removealllisteners
   */
  removeAllListeners() {
    this._listeners = {}, this.__isNative && this._stopListeningForNativeValueUpdates();
  }
  hasListeners() {
    return !!Object.keys(this._listeners).length;
  }
  _startListeningToNativeValueUpdates() {
    this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag || (this.__shouldUpdateListenersForNewNativeTag && (this.__shouldUpdateListenersForNewNativeTag = false, this._stopListeningForNativeValueUpdates()), NativeAnimatedAPI$1.startListeningToAnimatedNodeValue(this.__getNativeTag()), this.__nativeAnimatedValueListener = NativeAnimatedHelper.nativeEventEmitter.addListener("onAnimatedValueUpdate", (data) => {
      data.tag === this.__getNativeTag() && this.__onAnimatedValueUpdateReceived(data.value);
    }));
  }
  __onAnimatedValueUpdateReceived(value) {
    this.__callListeners(value);
  }
  __callListeners(value) {
    for (const key in this._listeners) this._listeners[key]({
      value
    });
  }
  _stopListeningForNativeValueUpdates() {
    this.__nativeAnimatedValueListener && (this.__nativeAnimatedValueListener.remove(), this.__nativeAnimatedValueListener = null, NativeAnimatedAPI$1.stopListeningToAnimatedNodeValue(this.__getNativeTag()));
  }
  __getNativeTag() {
    var _a;
    NativeAnimatedHelper.assertNativeAnimatedModule(), invariant(this.__isNative, 'Attempt to get native tag from node not marked as "native"');
    const nativeTag = (_a = this.__nativeTag) != null ? _a : NativeAnimatedHelper.generateNewNodeTag();
    if (this.__nativeTag == null) {
      this.__nativeTag = nativeTag;
      const config = this.__getNativeConfig();
      this._platformConfig && (config.platformConfig = this._platformConfig), NativeAnimatedHelper.API.createAnimatedNode(nativeTag, config), this.__shouldUpdateListenersForNewNativeTag = true;
    }
    return nativeTag;
  }
  __getNativeConfig() {
    throw new Error("This JS animated node type cannot be used as native animated node");
  }
  toJSON() {
    return this.__getValue();
  }
  __getPlatformConfig() {
    return this._platformConfig;
  }
  __setPlatformConfig(platformConfig) {
    this._platformConfig = platformConfig;
  }
}
class AnimatedWithChildren extends AnimatedNode {
  constructor() {
    super();
    __publicField(this, "_children");
    this._children = [];
  }
  __makeNative(platformConfig) {
    if (!this.__isNative) {
      this.__isNative = true;
      for (const child of this._children) child.__makeNative(platformConfig), NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
    }
    super.__makeNative(platformConfig);
  }
  __addChild(child) {
    this._children.length === 0 && this.__attach(), this._children.push(child), this.__isNative && (child.__makeNative(this.__getPlatformConfig()), NativeAnimatedHelper.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag()));
  }
  __removeChild(child) {
    const index2 = this._children.indexOf(child);
    if (index2 === -1) {
      console.warn("Trying to remove a child that doesn't exist");
      return;
    }
    this.__isNative && child.__isNative && NativeAnimatedHelper.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag()), this._children.splice(index2, 1), this._children.length === 0 && this.__detach();
  }
  __getChildren() {
    return this._children;
  }
  __callListeners(value) {
    if (super.__callListeners(value), !this.__isNative) for (const child of this._children) child.__getValue && child.__callListeners(child.__getValue());
  }
}
const linear = (t2) => t2;
function createInterpolation(config) {
  if (config.outputRange && typeof config.outputRange[0] == "string") return createInterpolationFromStringOutputRange(config);
  const outputRange = config.outputRange, inputRange = config.inputRange;
  checkInfiniteRange("outputRange", outputRange), checkInfiniteRange("inputRange", inputRange), checkValidInputRange(inputRange), invariant(inputRange.length === outputRange.length, "inputRange (" + inputRange.length + ") and outputRange (" + outputRange.length + ") must have the same length");
  const easing = config.easing || linear;
  let extrapolateLeft = "extend";
  config.extrapolateLeft !== void 0 ? extrapolateLeft = config.extrapolateLeft : config.extrapolate !== void 0 && (extrapolateLeft = config.extrapolate);
  let extrapolateRight = "extend";
  return config.extrapolateRight !== void 0 ? extrapolateRight = config.extrapolateRight : config.extrapolate !== void 0 && (extrapolateRight = config.extrapolate), (input) => {
    invariant(typeof input == "number", "Cannot interpolation an input which is not a number");
    const range = findRange(input, inputRange);
    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
  };
}
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
  let result = input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity") return result;
    extrapolateLeft === "clamp" && (result = inputMin);
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity") return result;
    extrapolateRight === "clamp" && (result = inputMax);
  }
  return outputMin === outputMax ? outputMin : inputMin === inputMax ? input <= inputMin ? outputMin : outputMax : (inputMin === -1 / 0 ? result = -result : inputMax === 1 / 0 ? result = result - inputMin : result = (result - inputMin) / (inputMax - inputMin), result = easing(result), outputMin === -1 / 0 ? result = -result : outputMax === 1 / 0 ? result = result + outputMin : result = result * (outputMax - outputMin) + outputMin, result);
}
function colorToRgba(input) {
  let normalizedColor = normalizeColor(input);
  if (normalizedColor === null || typeof normalizedColor != "number") return input;
  normalizedColor = normalizedColor || 0;
  const r = (normalizedColor & 4278190080) >>> 24, g = (normalizedColor & 16711680) >>> 16, b2 = (normalizedColor & 65280) >>> 8, a = (normalizedColor & 255) / 255;
  return `rgba(${r}, ${g}, ${b2}, ${a})`;
}
const stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;
function createInterpolationFromStringOutputRange(config) {
  let outputRange = config.outputRange;
  invariant(outputRange.length >= 2, "Bad output range"), outputRange = outputRange.map(colorToRgba), checkPattern(outputRange);
  const outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
  outputRange.forEach((value) => {
    value.match(stringShapeRegex).forEach((number, i) => {
      outputRanges[i].push(+number);
    });
  });
  const interpolations = outputRange[0].match(stringShapeRegex).map((value, i) => createInterpolation(__spreadProps(__spreadValues({}, config), {
    outputRange: outputRanges[i]
  }))), shouldRound = isRgbOrRgba(outputRange[0]);
  return (input) => {
    let i = 0;
    return outputRange[0].replace(stringShapeRegex, () => {
      let val = +interpolations[i++](input);
      return shouldRound && (val = i < 4 ? Math.round(val) : Math.round(val * 1e3) / 1e3), String(val);
    });
  };
}
function isRgbOrRgba(range) {
  return typeof range == "string" && range.startsWith("rgb");
}
function checkPattern(arr) {
  const pattern = arr[0].replace(stringShapeRegex, "");
  for (let i = 1; i < arr.length; ++i) invariant(pattern === arr[i].replace(stringShapeRegex, ""), "invalid pattern " + arr[0] + " and " + arr[i]);
}
function findRange(input, inputRange) {
  let i;
  for (i = 1; i < inputRange.length - 1 && !(inputRange[i] >= input); ++i) ;
  return i - 1;
}
function checkValidInputRange(arr) {
  invariant(arr.length >= 2, "inputRange must have at least 2 elements");
  const message = "inputRange must be monotonically non-decreasing " + String(arr);
  for (let i = 1; i < arr.length; ++i) invariant(arr[i] >= arr[i - 1], message);
}
function checkInfiniteRange(name, arr) {
  invariant(arr.length >= 2, name + " must have at least 2 elements"), invariant(arr.length !== 2 || arr[0] !== -1 / 0 || arr[1] !== 1 / 0, name + "cannot be ]-infinity;+infinity[ " + arr);
}
const _AnimatedInterpolation = class _AnimatedInterpolation extends AnimatedWithChildren {
  constructor(parent, config) {
    super(), this._parent = parent, this._config = config, this._interpolation = createInterpolation(config);
  }
  __makeNative(platformConfig) {
    this._parent.__makeNative(platformConfig), super.__makeNative(platformConfig);
  }
  __getValue() {
    const parentValue = this._parent.__getValue();
    return invariant(typeof parentValue == "number", "Cannot interpolate an input which is not a number."), this._interpolation(parentValue);
  }
  interpolate(config) {
    return new _AnimatedInterpolation(this, config);
  }
  __attach() {
    this._parent.__addChild(this);
  }
  __detach() {
    this._parent.__removeChild(this), super.__detach();
  }
  __transformDataType(range) {
    return range.map(NativeAnimatedHelper.transformDataType);
  }
  __getNativeConfig() {
    return NativeAnimatedHelper.validateInterpolation(this._config), {
      inputRange: this._config.inputRange,
      // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here
      outputRange: this.__transformDataType(this._config.outputRange),
      extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || "extend",
      extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || "extend",
      type: "interpolation"
    };
  }
};
// Export for testing.
__publicField(_AnimatedInterpolation, "__createInterpolation", createInterpolation);
let AnimatedInterpolation = _AnimatedInterpolation;
const NativeAnimatedAPI = NativeAnimatedHelper.API;
function _flush(rootNode) {
  const animatedStyles = /* @__PURE__ */ new Set();
  function findAnimatedStyles(node) {
    typeof node.update == "function" ? animatedStyles.add(node) : node.__getChildren().forEach(findAnimatedStyles);
  }
  findAnimatedStyles(rootNode), animatedStyles.forEach((animatedStyle) => animatedStyle.update());
}
function _executeAsAnimatedBatch(id2, operation) {
  NativeAnimatedAPI.setWaitingForIdentifier(id2), operation(), NativeAnimatedAPI.unsetWaitingForIdentifier(id2);
}
class AnimatedValue extends AnimatedWithChildren {
  constructor(value, config) {
    super();
    __publicField(this, "_value");
    __publicField(this, "_startingValue");
    __publicField(this, "_offset");
    __publicField(this, "_animation");
    __publicField(this, "_tracking");
    if (typeof value != "number") throw new Error("AnimatedValue: Attempting to set value to undefined");
    this._startingValue = this._value = value, this._offset = 0, this._animation = null, config && config.useNativeDriver && this.__makeNative();
  }
  __detach() {
    this.__isNative && NativeAnimatedAPI.getValue(this.__getNativeTag(), (value) => {
      this._value = value - this._offset;
    }), this.stopAnimation(), super.__detach();
  }
  __getValue() {
    return this._value + this._offset;
  }
  /**
   * Directly set the value.  This will stop any animations running on the value
   * and update all the bound properties.
   *
   * See https://reactnative.dev/docs/animatedvalue#setvalue
   */
  setValue(value) {
    this._animation && (this._animation.stop(), this._animation = null), this._updateValue(
      value,
      !this.__isNative
      /* don't perform a flush for natively driven values */
    ), this.__isNative && _executeAsAnimatedBatch(this.__getNativeTag().toString(), () => NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value));
  }
  /**
   * Sets an offset that is applied on top of whatever value is set, whether via
   * `setValue`, an animation, or `Animated.event`.  Useful for compensating
   * things like the start of a pan gesture.
   *
   * See https://reactnative.dev/docs/animatedvalue#setoffset
   */
  setOffset(offset2) {
    this._offset = offset2, this.__isNative && NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset2);
  }
  /**
   * Merges the offset value into the base value and resets the offset to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue#flattenoffset
   */
  flattenOffset() {
    this._value += this._offset, this._offset = 0, this.__isNative && NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
  }
  /**
   * Sets the offset value to the base value, and resets the base value to zero.
   * The final output of the value is unchanged.
   *
   * See https://reactnative.dev/docs/animatedvalue#extractoffset
   */
  extractOffset() {
    this._offset += this._value, this._value = 0, this.__isNative && NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
  }
  /**
   * Stops any running animation or tracking. `callback` is invoked with the
   * final value after stopping the animation, which is useful for updating
   * state to match the animation position with layout.
   *
   * See https://reactnative.dev/docs/animatedvalue#stopanimation
   */
  stopAnimation(callback) {
    this.stopTracking(), this._animation && this._animation.stop(), this._animation = null, callback && (this.__isNative ? NativeAnimatedAPI.getValue(this.__getNativeTag(), callback) : callback(this.__getValue()));
  }
  /**
   * Stops any animation and resets the value to its original.
   *
   * See https://reactnative.dev/docs/animatedvalue#resetanimation
   */
  resetAnimation(callback) {
    this.stopAnimation(callback), this._value = this._startingValue, this.__isNative && NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
  }
  __onAnimatedValueUpdateReceived(value) {
    this._updateValue(
      value,
      false
      /*flush*/
    );
  }
  /**
   * Interpolates the value before updating the property, e.g. mapping 0-1 to
   * 0-10.
   */
  interpolate(config) {
    return new AnimatedInterpolation(this, config);
  }
  /**
   * Typically only used internally, but could be used by a custom Animation
   * class.
   *
   * See https://reactnative.dev/docs/animatedvalue#animate
   */
  animate(animation, callback) {
    let handle = null;
    animation.__isInteraction && (handle = InteractionManager.createInteractionHandle());
    const previousAnimation = this._animation;
    this._animation && this._animation.stop(), this._animation = animation, animation.start(this._value, (value) => {
      this._updateValue(
        value,
        true
        /* flush */
      );
    }, (result) => {
      this._animation = null, handle !== null && InteractionManager.clearInteractionHandle(handle), callback && callback(result);
    }, previousAnimation, this);
  }
  /**
   * Typically only used internally.
   */
  stopTracking() {
    this._tracking && this._tracking.__detach(), this._tracking = null;
  }
  /**
   * Typically only used internally.
   */
  track(tracking) {
    this.stopTracking(), this._tracking = tracking, this._tracking && this._tracking.update();
  }
  _updateValue(value, flush) {
    if (value === void 0) throw new Error("AnimatedValue: Attempting to set value to undefined");
    this._value = value, flush && _flush(this), super.__callListeners(this.__getValue());
  }
  __getNativeConfig() {
    return {
      type: "value",
      value: this._value,
      offset: this._offset
    };
  }
}
function attachNativeEvent(viewRef, eventName, argMapping) {
  const eventMappings = [], traverse = (value, path) => {
    if (value instanceof AnimatedValue) value.__makeNative(), eventMappings.push({
      nativeEventPath: path,
      animatedValueTag: value.__getNativeTag()
    });
    else if (typeof value == "object") for (const key in value) traverse(value[key], path.concat(key));
  };
  return invariant(argMapping[0] && argMapping[0].nativeEvent, "Native driven events only support animated values contained inside `nativeEvent`."), traverse(argMapping[0].nativeEvent, []), viewRef != null && eventMappings.forEach((mapping) => {
    NativeAnimatedHelper.API.addAnimatedEventToView(viewRef, eventName, mapping);
  }), {
    detach() {
      viewRef != null && eventMappings.forEach((mapping) => {
        NativeAnimatedHelper.API.removeAnimatedEventFromView(viewRef, eventName, mapping.animatedValueTag);
      });
    }
  };
}
function validateMapping(argMapping, args) {
  const validate = (recMapping, recEvt, key) => {
    if (recMapping instanceof AnimatedValue) {
      invariant(typeof recEvt == "number", "Bad mapping of event key " + key + ", should be number but got " + typeof recEvt);
      return;
    }
    if (typeof recEvt == "number") {
      invariant(recMapping instanceof AnimatedValue, "Bad mapping of type " + typeof recMapping + " for key " + key + ", event value must map to AnimatedValue");
      return;
    }
    invariant(typeof recMapping == "object", "Bad mapping of type " + typeof recMapping + " for key " + key), invariant(typeof recEvt == "object", "Bad event of type " + typeof recEvt + " for key " + key);
    for (const mappingKey in recMapping) validate(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
  };
  invariant(args.length >= argMapping.length, "Event has less arguments than mapping"), argMapping.forEach((mapping, idx) => {
    validate(mapping, args[idx], "arg" + idx);
  });
}
class AnimatedEvent {
  constructor(argMapping, config) {
    __publicField(this, "_argMapping");
    __publicField(this, "_listeners", []);
    __publicField(this, "_attachedEvent");
    __publicField(this, "__isNative");
    this._argMapping = argMapping, config == null && (console.warn("Animated.event now requires a second argument for options"), config = {
      useNativeDriver: false
    }), config.listener && this.__addListener(config.listener), this._callListeners = this._callListeners.bind(this), this._attachedEvent = null, this.__isNative = shouldUseNativeDriver(config);
  }
  __addListener(callback) {
    this._listeners.push(callback);
  }
  __removeListener(callback) {
    this._listeners = this._listeners.filter((listener) => listener !== callback);
  }
  __attach(viewRef, eventName) {
    invariant(this.__isNative, "Only native driven events need to be attached."), this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
  }
  __detach(viewTag, eventName) {
    invariant(this.__isNative, "Only native driven events need to be detached."), this._attachedEvent && this._attachedEvent.detach();
  }
  __getHandler() {
    if (this.__isNative) {
      let validatedMapping2 = false;
      return (...args) => {
        validatedMapping2 || (validateMapping(this._argMapping, args), validatedMapping2 = true), this._callListeners(...args);
      };
    }
    let validatedMapping = false;
    return (...args) => {
      !validatedMapping && (validateMapping(this._argMapping, args), validatedMapping = true);
      const traverse = (recMapping, recEvt, key) => {
        if (recMapping instanceof AnimatedValue) typeof recEvt == "number" && recMapping.setValue(recEvt);
        else if (typeof recMapping == "object") for (const mappingKey in recMapping) traverse(recMapping[mappingKey], recEvt[mappingKey]);
      };
      this._argMapping.forEach((mapping, idx) => {
        traverse(mapping, args[idx]);
      }), this._callListeners(...args);
    };
  }
  _callListeners(...args) {
    this._listeners.forEach((listener) => listener(...args));
  }
}
class AnimatedTransform extends AnimatedWithChildren {
  constructor(transforms) {
    super();
    __publicField(this, "_transforms");
    this._transforms = transforms;
  }
  __makeNative() {
    this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode && value.__makeNative();
      }
    }), super.__makeNative();
  }
  __getValue() {
    return this._transforms.map((transform) => {
      const result = {};
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode ? result[key] = value.__getValue() : result[key] = value;
      }
      return result;
    });
  }
  __getAnimatedValue() {
    return this._transforms.map((transform) => {
      const result = {};
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode ? result[key] = value.__getAnimatedValue() : result[key] = value;
      }
      return result;
    });
  }
  __attach() {
    this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode && value.__addChild(this);
      }
    });
  }
  __detach() {
    this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode && value.__removeChild(this);
      }
    }), super.__detach();
  }
  __getNativeConfig() {
    const transConfigs = [];
    return this._transforms.forEach((transform) => {
      for (const key in transform) {
        const value = transform[key];
        value instanceof AnimatedNode ? transConfigs.push({
          type: "animated",
          property: key,
          nodeTag: value.__getNativeTag()
        }) : transConfigs.push({
          type: "static",
          property: key,
          value: NativeAnimatedHelper.transformDataType(value)
        });
      }
    }), NativeAnimatedHelper.validateTransform(transConfigs), {
      type: "transform",
      transforms: transConfigs
    };
  }
}
const flattenStyle = StyleSheet.flatten;
function createAnimatedStyle(inputStyle) {
  const style = flattenStyle(inputStyle), animatedStyles = {};
  for (const key in style) {
    const value = style[key];
    key === "transform" && Array.isArray(value) ? animatedStyles[key] = new AnimatedTransform(value) : value instanceof AnimatedNode ? animatedStyles[key] = value : value && !Array.isArray(value) && typeof value == "object" && (animatedStyles[key] = createAnimatedStyle(value));
  }
  return animatedStyles;
}
class AnimatedStyle extends AnimatedWithChildren {
  constructor(style) {
    super();
    __publicField(this, "_inputStyle");
    __publicField(this, "_style");
    this._inputStyle = style, this._style = createAnimatedStyle(style);
  }
  // Recursively get values for nested styles (like iOS's shadowOffset)
  _walkStyleAndGetValues(style) {
    const updatedStyle = {};
    for (const key in style) {
      const value = style[key];
      value instanceof AnimatedNode ? value.__isNative || (updatedStyle[key] = value.__getValue()) : value && !Array.isArray(value) && typeof value == "object" ? updatedStyle[key] = this._walkStyleAndGetValues(value) : updatedStyle[key] = value;
    }
    return updatedStyle;
  }
  __getValue() {
    return [this._inputStyle, this._walkStyleAndGetValues(this._style)];
  }
  // Recursively get animated values for nested styles (like iOS's shadowOffset)
  _walkStyleAndGetAnimatedValues(style) {
    const updatedStyle = {};
    for (const key in style) {
      const value = style[key];
      value instanceof AnimatedNode ? updatedStyle[key] = value.__getAnimatedValue() : value && !Array.isArray(value) && typeof value == "object" && (updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value));
    }
    return updatedStyle;
  }
  __getAnimatedValue() {
    return this._walkStyleAndGetAnimatedValues(this._style);
  }
  __attach() {
    for (const key in this._style) {
      const value = this._style[key];
      value instanceof AnimatedNode && value.__addChild(this);
    }
  }
  __detach() {
    for (const key in this._style) {
      const value = this._style[key];
      value instanceof AnimatedNode && value.__removeChild(this);
    }
    super.__detach();
  }
  __makeNative() {
    for (const key in this._style) {
      const value = this._style[key];
      value instanceof AnimatedNode && value.__makeNative();
    }
    super.__makeNative();
  }
  __getNativeConfig() {
    const styleConfig = {};
    for (const styleKey in this._style) if (this._style[styleKey] instanceof AnimatedNode) {
      const style = this._style[styleKey];
      style.__makeNative(), styleConfig[styleKey] = style.__getNativeTag();
    }
    return NativeAnimatedHelper.validateStyles(styleConfig), {
      type: "style",
      style: styleConfig
    };
  }
}
class AnimatedProps extends AnimatedNode {
  constructor(props, callback) {
    super(), props.style && (props = __spreadProps(__spreadValues({}, props), {
      style: new AnimatedStyle(props.style)
    })), this._props = props, this._callback = callback, this.__attach();
  }
  __getValue() {
    const props = {};
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode ? (!value.__isNative || value instanceof AnimatedStyle) && (props[key] = value.__getValue()) : value instanceof AnimatedEvent ? props[key] = value.__getHandler() : props[key] = value;
    }
    return props;
  }
  __getAnimatedValue() {
    const props = {};
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode && (props[key] = value.__getAnimatedValue());
    }
    return props;
  }
  __attach() {
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode && value.__addChild(this);
    }
  }
  __detach() {
    this.__isNative && this._animatedView && this.__disconnectAnimatedView();
    for (const key in this._props) {
      const value = this._props[key];
      value instanceof AnimatedNode && value.__removeChild(this);
    }
    super.__detach();
  }
  update() {
    this._callback();
  }
  __makeNative() {
    if (!this.__isNative) {
      this.__isNative = true;
      for (const key in this._props) {
        const value = this._props[key];
        value instanceof AnimatedNode && value.__makeNative();
      }
      this._animatedView && this.__connectAnimatedView();
    }
  }
  setNativeView(animatedView) {
    this._animatedView !== animatedView && (this._animatedView = animatedView, this.__isNative && this.__connectAnimatedView());
  }
  __connectAnimatedView() {
    invariant(this.__isNative, 'Expected node to be marked as "native"');
    const nativeViewTag = this._animatedView;
    invariant(nativeViewTag != null, "Unable to locate attached view in the native tree"), NativeAnimatedHelper.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
  }
  __disconnectAnimatedView() {
    invariant(this.__isNative, 'Expected node to be marked as "native"');
    const nativeViewTag = this._animatedView;
    invariant(nativeViewTag != null, "Unable to locate attached view in the native tree"), NativeAnimatedHelper.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
  }
  __restoreDefaultValues() {
    this.__isNative && NativeAnimatedHelper.API.restoreDefaultValues(this.__getNativeTag());
  }
  __getNativeConfig() {
    const propsConfig = {};
    for (const propKey in this._props) {
      const value = this._props[propKey];
      value instanceof AnimatedNode && (value.__makeNative(), propsConfig[propKey] = value.__getNativeTag());
    }
    return {
      type: "props",
      props: propsConfig
    };
  }
}
function useRefEffect(effect) {
  const cleanupRef = React.useRef(void 0);
  return React.useCallback((instance) => {
    cleanupRef.current && (cleanupRef.current(), cleanupRef.current = void 0), instance != null && (cleanupRef.current = effect(instance));
  }, [effect]);
}
function useAnimatedProps(props) {
  const [, scheduleUpdate2] = React.useReducer((count) => count + 1, 0), onUpdateRef = React.useRef(null), node = React.useMemo(() => new AnimatedProps(props, () => {
    var _a;
    return (_a = onUpdateRef.current) == null ? void 0 : _a.call(onUpdateRef);
  }), [props]);
  useAnimatedPropsLifecycle(node);
  const refEffect = React.useCallback((instance) => {
    node.setNativeView(instance), onUpdateRef.current = () => {
      scheduleUpdate2();
    };
    const target = getEventTarget(instance), events = [];
    for (const propName in props) {
      const propValue = props[propName];
      propValue instanceof AnimatedEvent && propValue.__isNative && (propValue.__attach(target, propName), events.push([propName, propValue]));
    }
    return () => {
      onUpdateRef.current = null;
      for (const [propName, propValue] of events) propValue.__detach(target, propName);
    };
  }, [props, node]), callbackRef = useRefEffect(refEffect);
  return [reduceAnimatedProps(node), callbackRef];
}
function reduceAnimatedProps(node) {
  return __spreadProps(__spreadValues({}, node.__getValue()), {
    collapsable: false
  });
}
function useAnimatedPropsLifecycle(node) {
  const prevNodeRef = React.useRef(null), isUnmountingRef = React.useRef(false);
  React.useEffect(() => {
  }), useLayoutEffectImpl(() => (isUnmountingRef.current = false, () => {
    isUnmountingRef.current = true;
  }), []), useLayoutEffectImpl(() => {
    if (node.__attach(), prevNodeRef.current != null) {
      const prevNode = prevNodeRef.current;
      prevNode.__restoreDefaultValues(), prevNode.__detach(), prevNodeRef.current = null;
    }
    return () => {
      isUnmountingRef.current ? node.__detach() : prevNodeRef.current = node;
    };
  }, [node]);
}
function getEventTarget(instance) {
  return typeof instance == "object" && typeof (instance == null ? void 0 : instance.getScrollableNode) == "function" ? instance.getScrollableNode() : instance;
}
function useMergeRefs(...refs) {
  return React.useCallback(
    (current) => {
      for (const ref of refs) ref != null && (typeof ref == "function" ? ref(current) : ref.current = current);
    },
    [...refs]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
}
function createAnimatedComponent(Component) {
  return React__namespace.forwardRef((props, forwardedRef) => {
    const [reducedProps, callbackRef] = useAnimatedProps(props), ref = useMergeRefs(callbackRef, forwardedRef), {
      passthroughAnimatedPropExplicitValues,
      style
    } = reducedProps, _a = passthroughAnimatedPropExplicitValues != null ? passthroughAnimatedPropExplicitValues : {}, {
      style: passthroughStyle
    } = _a, passthroughProps = __objRest(_a, [
      "style"
    ]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Component, __spreadProps(__spreadValues(__spreadValues({}, reducedProps), passthroughProps), {
      style: [style, passthroughStyle],
      ref
    }));
  });
}
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}
const deepDiffer = function(one, two, maxDepth = -1) {
  if (maxDepth === 0)
    return true;
  if (one === two || typeof one == "function" && typeof two == "function")
    return false;
  if (typeof one != "object" || one === null)
    return one !== two;
  if (typeof two != "object" || two === null || one.constructor !== two.constructor)
    return true;
  if (Array.isArray(one)) {
    const len = one.length;
    if (two.length !== len)
      return true;
    for (let ii = 0; ii < len; ii++)
      if (deepDiffer(one[ii], two[ii], maxDepth - 1))
        return true;
  } else {
    for (const key in one)
      if (deepDiffer(one[key], two[key], maxDepth - 1))
        return true;
    for (const twoKey in two)
      if (one[twoKey] === void 0 && two[twoKey] !== void 0)
        return true;
  }
  return false;
};
const dimensions$1 = {
  window: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  },
  screen: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  }
}, listeners$1 = {};
let shouldInit$1 = canUseDOM$1;
function update$1() {
  if (!canUseDOM$1)
    return;
  const win = window, docEl = win.document.documentElement;
  dimensions$1.window = {
    fontScale: 1,
    height: docEl.clientHeight,
    scale: win.devicePixelRatio || 1,
    width: docEl.clientWidth
  }, dimensions$1.screen = {
    fontScale: 1,
    height: win.screen.height,
    scale: win.devicePixelRatio || 1,
    width: win.screen.width
  };
}
function handleResize$1() {
  update$1(), Array.isArray(listeners$1.change) && listeners$1.change.forEach((handler) => handler(dimensions$1));
}
let Dimensions$1 = class Dimensions {
  static get(dimension) {
    return shouldInit$1 && (shouldInit$1 = false, update$1()), invariant(dimensions$1[dimension], `No dimension set for key ${dimension}`), dimensions$1[dimension];
  }
  static set(initialDimensions) {
    initialDimensions && (canUseDOM$1 ? invariant(false, "Dimensions cannot be set in the browser") : (initialDimensions.screen != null && (dimensions$1.screen = initialDimensions.screen), initialDimensions.window != null && (dimensions$1.window = initialDimensions.window)));
  }
  static addEventListener(type, handler) {
    return listeners$1[type] = listeners$1[type] || [], listeners$1[type].push(handler), {
      remove: () => {
        this.removeEventListener(type, handler);
      }
    };
  }
  static removeEventListener(type, handler) {
    Array.isArray(listeners$1[type]) && (listeners$1[type] = listeners$1[type].filter((_handler) => _handler !== handler));
  }
};
canUseDOM$1 && window.addEventListener("resize", handleResize$1, false);
const useCreateElement = (component, props, options) => {
  const { element, styles: styles2 } = createElementAndStyles(component, props);
  useDidFinishSSR();
  const styleTags = React.useMemo(
    () => null,
    [
      // never changes
    ]
  );
  return React.useInsertionEffect(() => {
    if (!styles2) return;
    const styleObj = {};
    for (const style of styles2)
      styleObj[style[0]] = style;
  }, [styles2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    element,
    styleTags
  ] });
}, createElement = (component, props, options) => {
  const { element, styles: styles2 } = createElementAndStyles(component, props);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    element,
    styles2 ? getStyleTags() : null
  ] });
}, createElementAndStyles = (component, props, options) => {
  let accessibilityComponent;
  component && component.constructor === String && (accessibilityComponent = AccessibilityUtil.propsToAccessibilityComponent(props));
  const Component = accessibilityComponent || component, domProps = createDOMProps(Component, props), styles2 = stylesFromProps.get(domProps);
  let element = React.createElement(Component, domProps);
  return {
    element: domProps.dir ? /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleProvider, { direction: domProps.dir, locale: domProps.lang, children: element }) : element,
    styles: styles2
  };
};
const pickProps$5 = (props) => pick(props, forwardPropsListView), View$2 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const _a = props, {
      hrefAttrs,
      onLayout,
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    } = _a, rest = __objRest(_a, [
      "hrefAttrs",
      "onLayout",
      "onMoveShouldSetResponder",
      "onMoveShouldSetResponderCapture",
      "onResponderEnd",
      "onResponderGrant",
      "onResponderMove",
      "onResponderReject",
      "onResponderRelease",
      "onResponderStart",
      "onResponderTerminate",
      "onResponderTerminationRequest",
      "onScrollShouldSetResponder",
      "onScrollShouldSetResponderCapture",
      "onSelectionChangeShouldSetResponder",
      "onSelectionChangeShouldSetResponderCapture",
      "onStartShouldSetResponder",
      "onStartShouldSetResponderCapture"
    ]);
    React__namespace.Children.toArray(props.children).forEach((item) => {
      typeof item == "string" && console.error(
        `Unexpected text node: ${item}. A text node cannot be a child of a <View>.`
      );
    });
    const hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), { direction: contextDirection } = useLocaleContext();
    useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    let component = "div";
    const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$5(rest);
    if (supportedProps.dir = componentDirection, supportedProps.style = [styles$h.view, hasTextAncestor && styles$h.inline, props.style], props.href != null && (component = "a", hrefAttrs != null)) {
      const { download, rel, target } = hrefAttrs;
      download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
    }
    const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
    return supportedProps.ref = setRef2, useCreateElement(component, supportedProps);
  }
);
View$2.displayName = "View";
const styles$h = {
  view: {
    alignItems: "stretch",
    boxSizing: "border-box",
    display: "flex",
    flexBasis: "auto",
    flexDirection: "column",
    flexShrink: 0
  },
  inline: {
    display: "inline-flex"
  }
};
function normalizeScrollEvent$1(e2) {
  return {
    nativeEvent: {
      contentOffset: {
        get x() {
          return e2.target.scrollLeft;
        },
        get y() {
          return e2.target.scrollTop;
        }
      },
      contentSize: {
        get height() {
          return e2.target.scrollHeight;
        },
        get width() {
          return e2.target.scrollWidth;
        }
      },
      layoutMeasurement: {
        get height() {
          return e2.target.offsetHeight;
        },
        get width() {
          return e2.target.offsetWidth;
        }
      }
    },
    timeStamp: Date.now()
  };
}
function shouldEmitScrollEvent$1(lastTick, eventThrottle) {
  const timeSinceLastTick = Date.now() - lastTick;
  return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
}
const ScrollViewBase$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    onScroll,
    onTouchMove,
    onWheel,
    scrollEnabled = true,
    scrollEventThrottle = 0,
    showsHorizontalScrollIndicator,
    showsVerticalScrollIndicator,
    style
  } = _a, rest = __objRest(_a, [
    "onScroll",
    "onTouchMove",
    "onWheel",
    "scrollEnabled",
    "scrollEventThrottle",
    "showsHorizontalScrollIndicator",
    "showsVerticalScrollIndicator",
    "style"
  ]), scrollState = React__namespace.useRef({ isScrolling: false, scrollLastTick: 0 }), scrollTimeout = React__namespace.useRef(null), scrollRef = React__namespace.useRef(null);
  function createPreventableScrollHandler(handler) {
    return (e2) => {
      scrollEnabled && handler && handler(e2);
    };
  }
  function handleScroll(e2) {
    e2.stopPropagation(), e2.target === scrollRef.current && (e2.persist(), scrollTimeout.current != null && clearTimeout(scrollTimeout.current), scrollTimeout.current = setTimeout(() => {
      handleScrollEnd(e2);
    }, 100), scrollState.current.isScrolling ? shouldEmitScrollEvent$1(scrollState.current.scrollLastTick, scrollEventThrottle) && handleScrollTick(e2) : handleScrollStart(e2));
  }
  function handleScrollStart(e2) {
    scrollState.current.isScrolling = true, handleScrollTick(e2);
  }
  function handleScrollTick(e2) {
    scrollState.current.scrollLastTick = Date.now(), onScroll && onScroll(normalizeScrollEvent$1(e2));
  }
  function handleScrollEnd(e2) {
    scrollState.current.isScrolling = false, onScroll && onScroll(normalizeScrollEvent$1(e2));
  }
  const hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    View$2,
    __spreadProps(__spreadValues({}, rest), {
      onScroll: handleScroll,
      onTouchMove: createPreventableScrollHandler(onTouchMove),
      onWheel: createPreventableScrollHandler(onWheel),
      ref: useMergeRefs$1(scrollRef, forwardedRef),
      style: [
        style,
        // @ts-ignore
        !scrollEnabled && styles$g.scrollDisabled,
        // @ts-ignore
        hideScrollbar && styles$g.hideScrollbar
      ]
    })
  );
}), styles$g = {
  scrollDisabled: {
    overflowX: "hidden",
    overflowY: "hidden",
    touchAction: "none"
  },
  hideScrollbar: {
    scrollbarWidth: "none"
  }
};
const emptyObject$2 = {}, IS_ANIMATING_TOUCH_START_THRESHOLD_MS$1 = 16;
let ScrollView$2 = class ScrollView extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "_scrollNodeRef");
    __publicField(this, "_innerViewRef");
    __publicField(this, "keyboardWillOpenTo", null);
    __publicField(this, "additionalScrollOffset", 0);
    __publicField(this, "preventNegativeScrollOffset", false);
    __publicField(this, "isTouching", false);
    __publicField(this, "lastMomentumScrollBeginTime", 0);
    __publicField(this, "lastMomentumScrollEndTime", 0);
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    __publicField(this, "observedScrollSinceBecomingResponder", false);
    __publicField(this, "becameResponderWhileAnimating", false);
    __publicField(this, "flashScrollIndicators", () => {
      this.scrollResponderFlashScrollIndicators();
    });
    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollTo", (y, x, animated) => {
      typeof y == "number" ? console.warn(
        "`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead."
      ) : { x, y, animated } = y || emptyObject$2, this.scrollResponderScrollTo({
        x: x || 0,
        y: y || 0,
        animated: animated !== false
      });
    });
    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */
    __publicField(this, "scrollToEnd", (options) => {
      const animated = (options && options.animated) !== false, { horizontal } = this.props, scrollResponderNode = this.getScrollableNode(), x = horizontal ? scrollResponderNode.scrollWidth : 0, y = horizontal ? 0 : scrollResponderNode.scrollHeight;
      this.scrollResponderScrollTo({ x, y, animated });
    });
    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollResponderScrollTo", (x, y, animated) => {
      typeof x == "number" ? console.warn(
        "`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead."
      ) : { x, y, animated } = x || emptyObject$2;
      const node = this.getScrollableNode(), left = x || 0, top = y || 0;
      node != null && (typeof node.scroll == "function" ? node.scroll({ top, left, behavior: animated ? "smooth" : "auto" }) : (node.scrollLeft = left, node.scrollTop = top));
    });
    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */
    __publicField(this, "scrollResponderZoomTo", (rect, animated) => {
      invariant("zoomToRect is not implemented");
    });
    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */
    __publicField(this, "scrollResponderScrollNativeHandleToKeyboard", (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
      this.additionalScrollOffset = additionalOffset || 0, this.preventNegativeScrollOffset = !!preventNegativeScrollOffset, UIManager.measureLayout(
        nodeHandle,
        this.getInnerViewNode(),
        this.scrollResponderTextInputFocusError,
        this.scrollResponderInputMeasureAndScrollToKeyboard
      );
    });
    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */
    __publicField(this, "scrollResponderInputMeasureAndScrollToKeyboard", (left, top, width, height) => {
      let keyboardScreenY = Dimensions$1.get("window").height;
      this.keyboardWillOpenTo && (keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY);
      let scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;
      this.preventNegativeScrollOffset && (scrollOffsetY = Math.max(0, scrollOffsetY)), this.scrollResponderScrollTo({ x: 0, y: scrollOffsetY, animated: true }), this.additionalScrollOffset = 0, this.preventNegativeScrollOffset = false;
    });
    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */
    __publicField(this, "scrollResponderKeyboardWillShow", (e2) => {
      this.keyboardWillOpenTo = e2, this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardWillHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidShow", (e2) => {
      e2 && (this.keyboardWillOpenTo = e2), this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e2);
    });
  }
  /**
   * Returns a reference to the underlying scroll responder, which supports
   * operations like `scrollTo`. All ScrollView-like components should
   * implement this method so that they can be composed while providing access
   * to the underlying scroll responder's methods.
   */
  getScrollResponder() {
    return this;
  }
  getScrollableNode() {
    return this._scrollNodeRef;
  }
  getInnerViewRef() {
    return this._innerViewRef;
  }
  getInnerViewNode() {
    return this._innerViewRef;
  }
  getNativeScrollRef() {
    return this._scrollNodeRef;
  }
  render() {
    const _a = this.props, {
      contentContainerStyle,
      horizontal,
      onContentSizeChange,
      refreshControl,
      stickyHeaderIndices,
      pagingEnabled,
      forwardedRef: forwardedRef,
      keyboardDismissMode,
      onScroll,
      centerContent
    } = _a, other = __objRest(_a, [
      "contentContainerStyle",
      "horizontal",
      "onContentSizeChange",
      "refreshControl",
      "stickyHeaderIndices",
      "pagingEnabled",
      /* eslint-disable */
      "forwardedRef",
      "keyboardDismissMode",
      "onScroll",
      "centerContent"
    ]);
    if (this.props.style) {
      const style = StyleSheet.flatten(this.props.style), childLayoutProps = ["alignItems", "justifyContent"].filter(
        (prop) => style && style[prop] !== void 0
      );
      invariant(
        childLayoutProps.length === 0,
        `ScrollView child layout (${JSON.stringify(childLayoutProps)}) must be applied through the contentContainerStyle prop.`
      );
    }
    let contentSizeChangeProps = {};
    onContentSizeChange && (contentSizeChangeProps = {
      onLayout: this._handleContentOnLayout.bind(this)
    });
    const hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices), children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {
      const isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
      return child != null && (isSticky || pagingEnabled) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        View$2,
        {
          style: StyleSheet.compose(
            isSticky && styles$f.stickyHeader,
            pagingEnabled && styles$f.pagingEnabledChild
          ),
          children: child
        }
      ) : child;
    }) : this.props.children, contentContainer = /* @__PURE__ */ jsxRuntimeExports.jsx(
      View$2,
      __spreadProps(__spreadValues({}, contentSizeChangeProps), {
        collapsable: false,
        ref: this._setInnerViewRef.bind(this),
        style: [
          horizontal && styles$f.contentContainerHorizontal,
          centerContent && styles$f.contentContainerCenterContent,
          contentContainerStyle
        ],
        children
      })
    ), baseStyle = horizontal ? styles$f.baseHorizontal : styles$f.baseVertical, pagingEnabledStyle = horizontal ? styles$f.pagingEnabledHorizontal : styles$f.pagingEnabledVertical, props = __spreadProps(__spreadValues({}, other), {
      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
      onTouchStart: this.scrollResponderHandleTouchStart.bind(this),
      onTouchMove: this.scrollResponderHandleTouchMove.bind(this),
      onTouchEnd: this.scrollResponderHandleTouchEnd.bind(this),
      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag.bind(this),
      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag.bind(this),
      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin.bind(this),
      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd.bind(this),
      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder.bind(this),
      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture.bind(this),
      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder.bind(this),
      onScroll: this._handleScroll.bind(this),
      onResponderGrant: this.scrollResponderHandleResponderGrant.bind(this),
      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest.bind(this),
      onResponderRelease: this.scrollResponderHandleResponderRelease.bind(this),
      onResponderReject: this.scrollResponderHandleResponderReject.bind(this),
      onResponderTerminate: this.scrollResponderHandleTerminate.bind(this)
    }), ScrollViewClass = ScrollViewBase$1;
    invariant(ScrollViewClass !== void 0, "ScrollViewClass must not be undefined");
    const scrollView = /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollViewClass, __spreadProps(__spreadValues({}, props), { ref: this._setScrollNodeRef.bind(this), children: contentContainer }));
    return refreshControl ? React.cloneElement(refreshControl, { style: props.style }, scrollView) : scrollView;
  }
  _handleContentOnLayout(e2) {
    var _a, _b;
    const { width, height } = e2.nativeEvent.layout;
    (_b = (_a = this.props).onContentSizeChange) == null ? void 0 : _b.call(_a, width, height);
  }
  _handleScroll(e2) {
    this.props.onScroll && this.props.scrollEventThrottle == null && console.info(
      "You specified `onScroll` on a <ScrollView> but not `scrollEventThrottle`. You will only receive one event. Using `16` you get all the events but be aware that it may cause frame drops, use a bigger number if you don't need as much precision."
    ), this.props.keyboardDismissMode === "on-drag" && dismissKeyboard(), this.scrollResponderHandleScroll(e2);
  }
  _setInnerViewRef(node) {
    this._innerViewRef = node;
  }
  _setScrollNodeRef(node) {
    this._scrollNodeRef = node, node != null && (node.getScrollResponder = this.getScrollResponder, node.getInnerViewNode = this.getInnerViewNode, node.getInnerViewRef = this.getInnerViewRef, node.getNativeScrollRef = this.getNativeScrollRef, node.getScrollableNode = this.getScrollableNode, node.scrollTo = this.scrollTo, node.scrollToEnd = this.scrollToEnd, node.flashScrollIndicators = this.flashScrollIndicators, node.scrollResponderZoomTo = this.scrollResponderZoomTo, node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard), mergeRefs(this.props.forwardedRef)(node);
  }
  /**
   * Invoke this from an `onScroll` event.
   */
  scrollResponderHandleScrollShouldSetResponder() {
    return this.isTouching;
  }
  /**
   * Merely touch starting is not sufficient for a scroll view to become the
   * responder. Being the "responder" means that the very next touch move/end
   * event will result in an action/movement.
   *
   * Invoke this from an `onStartShouldSetResponder` event.
   *
   * `onStartShouldSetResponder` is used when the next move/end will trigger
   * some UI movement/action, but when you want to yield priority to views
   * nested inside of the view.
   *
   * There may be some cases where scroll views actually should return `true`
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
   * that gives priority to nested views.
   *
   * - If a single tap on the scroll view triggers an action such as
   *   recentering a map style view yet wants to give priority to interaction
   *   views inside (such as dropped pins or labels), then we would return true
   *   from this method when there is a single touch.
   *
   * - Similar to the previous case, if a two finger "tap" should trigger a
   *   zoom, we would check the `touches` count, and if `>= 2`, we would return
   *   true.
   *
   */
  scrollResponderHandleStartShouldSetResponder() {
    return false;
  }
  /**
   * There are times when the scroll view wants to become the responder
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
   * that *doesn't* give priority to nested views (hence the capture phase):
   *
   * - Currently animating.
   * - Tapping anywhere that is not the focused input, while the keyboard is
   *   up (which should dismiss the keyboard).
   *
   * Invoke this from an `onStartShouldSetResponderCapture` event.
   */
  scrollResponderHandleStartShouldSetResponderCapture(e2) {
    return this.scrollResponderIsAnimating();
  }
  /**
   * Invoke this from an `onResponderReject` event.
   *
   * Some other element is not yielding its role as responder. Normally, we'd
   * just disable the `UIScrollView`, but a touch has already began on it, the
   * `UIScrollView` will not accept being disabled after that. The easiest
   * solution for now is to accept the limitation of disallowing this
   * altogether. To improve this, find a way to disable the `UIScrollView` after
   * a touch has already started.
   */
  scrollResponderHandleResponderReject() {
    warning();
  }
  /**
   * We will allow the scroll view to give up its lock iff it acquired the lock
   * during an animation. This is a very useful default that happens to satisfy
   * many common user experiences.
   *
   * - Stop a scroll on the left edge, then turn that into an outer view's
   *   backswipe.
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
   *   view dismiss.
   * - However, without catching the scroll view mid-bounce (while it is
   *   motionless), if you drag far enough for the scroll view to become
   *   responder (and therefore drag the scroll view a bit), any backswipe
   *   navigation of a swipe gesture higher in the view hierarchy, should be
   *   rejected.
   */
  scrollResponderHandleTerminationRequest() {
    return !this.observedScrollSinceBecomingResponder;
  }
  /**
   * Invoke this from an `onTouchEnd` event.
   *
   * @param {SyntheticEvent} e Event.
   */
  scrollResponderHandleTouchEnd(e2) {
    const nativeEvent = e2.nativeEvent;
    this.isTouching = nativeEvent.touches.length !== 0, this.props.onTouchEnd && this.props.onTouchEnd(e2);
  }
  /**
   * Invoke this from an `onResponderRelease` event.
   */
  scrollResponderHandleResponderRelease(e2) {
    this.props.onResponderRelease && this.props.onResponderRelease(e2);
    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
    !this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e2.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating && (this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e2), TextInputState.blurTextInput(currentlyFocusedTextInput));
  }
  scrollResponderHandleScroll(e2) {
    this.observedScrollSinceBecomingResponder = true, this.props.onScroll && this.props.onScroll(e2);
  }
  /**
   * Invoke this from an `onResponderGrant` event.
   */
  scrollResponderHandleResponderGrant(e2) {
    this.observedScrollSinceBecomingResponder = false, this.props.onResponderGrant && this.props.onResponderGrant(e2), this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
  }
  /**
   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
   * animation, and there's not an easy way to distinguish a drag vs. stopping
   * momentum.
   *
   * Invoke this from an `onScrollBeginDrag` event.
   */
  scrollResponderHandleScrollBeginDrag(e2) {
    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e2);
  }
  /**
   * Invoke this from an `onScrollEndDrag` event.
   */
  scrollResponderHandleScrollEndDrag(e2) {
    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollBegin` event.
   */
  scrollResponderHandleMomentumScrollBegin(e2) {
    this.lastMomentumScrollBeginTime = Date.now(), this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollEnd` event.
   */
  scrollResponderHandleMomentumScrollEnd(e2) {
    this.lastMomentumScrollEndTime = Date.now(), this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e2);
  }
  /**
   * Invoke this from an `onTouchStart` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchStart(e2) {
    this.isTouching = true, this.props.onTouchStart && this.props.onTouchStart(e2);
  }
  /**
   * Invoke this from an `onTouchMove` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchMove(e2) {
    this.props.onTouchMove && this.props.onTouchMove(e2);
  }
  scrollResponderHandleTerminate(e2) {
    this.props.onResponderTerminate && this.props.onResponderTerminate(e2);
  }
  /**
   * A helper function for this class that lets us quickly determine if the
   * view is currently animating. This is particularly useful to know when
   * a touch has just started or ended.
   */
  scrollResponderIsAnimating() {
    return Date.now() - this.lastMomentumScrollEndTime < IS_ANIMATING_TOUCH_START_THRESHOLD_MS$1 || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
  }
  /**
   * Displays the scroll indicators momentarily.
   */
  scrollResponderFlashScrollIndicators() {
  }
  scrollResponderTextInputFocusError(e2) {
    console.error("Error measuring text field: ", e2);
  }
};
const commonStyle$1 = {
  flexGrow: 1,
  flexShrink: 1,
  // Enable hardware compositing in modern browsers.
  // Creates a new layer with its own backing surface that can significantly
  // improve scroll performance.
  transform: [{ translateZ: 0 }],
  // iOS native scrolling
  WebkitOverflowScrolling: "touch"
}, styles$f = {
  baseVertical: __spreadProps(__spreadValues({}, commonStyle$1), {
    flexDirection: "column",
    overflowX: "hidden",
    overflowY: "auto"
  }),
  baseHorizontal: __spreadProps(__spreadValues({}, commonStyle$1), {
    flexDirection: "row",
    overflowX: "auto",
    overflowY: "hidden"
  }),
  contentContainerHorizontal: {
    flexDirection: "row"
  },
  contentContainerCenterContent: {
    justifyContent: "center",
    flexGrow: 1
  },
  stickyHeader: {
    position: "sticky",
    top: 0,
    zIndex: 10
  },
  pagingEnabledHorizontal: {
    scrollSnapType: "x mandatory"
  },
  pagingEnabledVertical: {
    scrollSnapType: "y mandatory"
  },
  pagingEnabledChild: {
    scrollSnapAlign: "start"
  }
}, ForwardedScrollView$1 = React.forwardRef((props, forwardedRef) => /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollView$2, __spreadProps(__spreadValues({}, props), { forwardedRef })));
ForwardedScrollView$1.displayName = "ScrollView";
function RefreshControl(props) {
  const _a = props, {
    colors: colors,
    enabled,
    onRefresh,
    progressBackgroundColor,
    progressViewOffset,
    refreshing,
    size,
    tintColor,
    title,
    titleColor
  } = _a, rest = __objRest(_a, [
    /* eslint-disable */
    "colors",
    "enabled",
    "onRefresh",
    "progressBackgroundColor",
    "progressViewOffset",
    "refreshing",
    "size",
    "tintColor",
    "title",
    "titleColor"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadValues({}, rest));
}
class Batchinator {
  constructor(callback, delayMS) {
    __publicField(this, "_callback");
    __publicField(this, "_delay");
    __publicField(this, "_taskHandle");
    this._delay = delayMS, this._callback = callback;
  }
  /*
   * Cleanup any pending tasks.
   *
   * By default, if there is a pending task the callback is run immediately. Set the option abort to
   * true to not call the callback if it was pending.
   */
  dispose(options = { abort: false }) {
    this._taskHandle && (this._taskHandle.cancel(), options.abort || this._callback(), this._taskHandle = null);
  }
  schedule() {
    if (this._taskHandle)
      return;
    const timeoutHandle = setTimeout(() => {
      this._taskHandle = InteractionManager.runAfterInteractions(() => {
        this._taskHandle = null, this._callback();
      });
    }, this._delay);
    this._taskHandle = { cancel: () => clearTimeout(timeoutHandle) };
  }
}
class ChildListCollection {
  constructor() {
    __publicField(this, "_cellKeyToChildren", /* @__PURE__ */ new Map());
    __publicField(this, "_childrenToCellKey", /* @__PURE__ */ new Map());
  }
  add(list, cellKey) {
    var _a;
    invariant(
      !this._childrenToCellKey.has(list),
      "Trying to add already present child list"
    );
    const cellLists = (_a = this._cellKeyToChildren.get(cellKey)) != null ? _a : /* @__PURE__ */ new Set();
    cellLists.add(list), this._cellKeyToChildren.set(cellKey, cellLists), this._childrenToCellKey.set(list, cellKey);
  }
  remove(list) {
    const cellKey = this._childrenToCellKey.get(list);
    invariant(cellKey != null, "Trying to remove non-present child list"), this._childrenToCellKey.delete(list);
    const cellLists = this._cellKeyToChildren.get(cellKey);
    invariant(cellLists, "_cellKeyToChildren should contain cellKey"), cellLists.delete(list), cellLists.size === 0 && this._cellKeyToChildren.delete(cellKey);
  }
  forEach(fn) {
    for (const listSet of this._cellKeyToChildren.values())
      for (const list of listSet)
        fn(list);
  }
  forEachInCell(cellKey, fn) {
    var _a;
    const listSet = (_a = this._cellKeyToChildren.get(cellKey)) != null ? _a : [];
    for (const list of listSet)
      fn(list);
  }
  anyInCell(cellKey, fn) {
    var _a;
    const listSet = (_a = this._cellKeyToChildren.get(cellKey)) != null ? _a : [];
    for (const list of listSet)
      if (fn(list))
        return true;
    return false;
  }
  size() {
    return this._childrenToCellKey.size;
  }
}
class Info {
  constructor() {
    __publicField(this, "any_blank_count", 0);
    __publicField(this, "any_blank_ms", 0);
    __publicField(this, "any_blank_speed_sum", 0);
    __publicField(this, "mostly_blank_count", 0);
    __publicField(this, "mostly_blank_ms", 0);
    __publicField(this, "pixels_blank", 0);
    __publicField(this, "pixels_sampled", 0);
    __publicField(this, "pixels_scrolled", 0);
    __publicField(this, "total_time_spent", 0);
    __publicField(this, "sample_count", 0);
  }
}
let _listeners = [], _minSampleCount = 10, _sampleRate = null;
class FillRateHelper {
  constructor(getFrameMetrics) {
    __publicField(this, "_anyBlankStartTime", null);
    __publicField(this, "_enabled", false);
    __publicField(this, "_getFrameMetrics");
    __publicField(this, "_info", new Info());
    __publicField(this, "_mostlyBlankStartTime", null);
    __publicField(this, "_samplesStartTime", null);
    this._getFrameMetrics = getFrameMetrics, this._enabled = (_sampleRate || 0) > Math.random(), this._resetData();
  }
  static addListener(callback) {
    return _sampleRate === null && console.warn("Call `FillRateHelper.setSampleRate` before `addListener`."), _listeners.push(callback), {
      remove: () => {
        _listeners = _listeners.filter((listener) => callback !== listener);
      }
    };
  }
  static setSampleRate(sampleRate) {
    _sampleRate = sampleRate;
  }
  static setMinSampleCount(minSampleCount) {
    _minSampleCount = minSampleCount;
  }
  activate() {
    this._enabled && this._samplesStartTime == null && (this._samplesStartTime = global.performance.now());
  }
  deactivateAndFlush() {
    if (!this._enabled)
      return;
    const start = this._samplesStartTime;
    if (start == null) {
      return;
    }
    if (this._info.sample_count < _minSampleCount) {
      this._resetData();
      return;
    }
    const total_time_spent = global.performance.now() - start, info = __spreadProps(__spreadValues({}, this._info), {
      total_time_spent
    });
    _listeners.forEach((listener) => listener(info)), this._resetData();
  }
  computeBlankness(props, cellsAroundViewport, scrollMetrics) {
    if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null)
      return 0;
    const { dOffset, offset: offset2, velocity, visibleLength } = scrollMetrics;
    this._info.sample_count++, this._info.pixels_sampled += Math.round(visibleLength), this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
    const scrollSpeed = Math.round(Math.abs(velocity) * 1e3), now = global.performance.now();
    this._anyBlankStartTime != null && (this._info.any_blank_ms += now - this._anyBlankStartTime), this._anyBlankStartTime = null, this._mostlyBlankStartTime != null && (this._info.mostly_blank_ms += now - this._mostlyBlankStartTime), this._mostlyBlankStartTime = null;
    let blankTop = 0, first = cellsAroundViewport.first, firstFrame = this._getFrameMetrics(first, props);
    for (; first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout); )
      firstFrame = this._getFrameMetrics(first, props), first++;
    firstFrame && first > 0 && (blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset2)));
    let blankBottom = 0, last = cellsAroundViewport.last, lastFrame = this._getFrameMetrics(last, props);
    for (; last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout); )
      lastFrame = this._getFrameMetrics(last, props), last--;
    if (lastFrame && last < props.getItemCount(props.data) - 1) {
      const bottomEdge = lastFrame.offset + lastFrame.length;
      blankBottom = Math.min(
        visibleLength,
        Math.max(0, offset2 + visibleLength - bottomEdge)
      );
    }
    const pixels_blank = Math.round(blankTop + blankBottom), blankness = pixels_blank / visibleLength;
    return blankness > 0 ? (this._anyBlankStartTime = now, this._info.any_blank_speed_sum += scrollSpeed, this._info.any_blank_count++, this._info.pixels_blank += pixels_blank, blankness > 0.5 && (this._mostlyBlankStartTime = now, this._info.mostly_blank_count++)) : (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) && this.deactivateAndFlush(), blankness;
  }
  enabled() {
    return this._enabled;
  }
  _resetData() {
    this._anyBlankStartTime = null, this._info = new Info(), this._mostlyBlankStartTime = null, this._samplesStartTime = null;
  }
}
class StateSafePureComponent extends React__namespace.PureComponent {
  constructor(props) {
    super(props);
    __publicField(this, "_inAsyncStateUpdate", false);
    this._installSetStateHooks();
  }
  setState(partialState, callback) {
    typeof partialState == "function" ? super.setState((state, props) => {
      this._inAsyncStateUpdate = true;
      let ret;
      try {
        ret = partialState(state, props);
      } catch (err) {
        throw err;
      } finally {
        this._inAsyncStateUpdate = false;
      }
      return ret;
    }, callback) : super.setState(partialState, callback);
  }
  _installSetStateHooks() {
    const that = this;
    let { props, state } = this;
    Object.defineProperty(this, "props", {
      get() {
        return invariant(
          !that._inAsyncStateUpdate,
          '"this.props" should not be accessed during state updates'
        ), props;
      },
      set(newProps) {
        props = newProps;
      }
    }), Object.defineProperty(this, "state", {
      get() {
        return invariant(
          !that._inAsyncStateUpdate,
          '"this.state" should not be acceessed during state updates'
        ), state;
      },
      set(newState) {
        state = newState;
      }
    });
  }
}
class ViewabilityHelper {
  constructor(config = { viewAreaCoveragePercentThreshold: 0 }) {
    __publicField(this, "_config");
    __publicField(this, "_hasInteracted", false);
    __publicField(this, "_timers", /* @__PURE__ */ new Set());
    __publicField(this, "_viewableIndices", []);
    __publicField(this, "_viewableItems", /* @__PURE__ */ new Map());
    this._config = config;
  }
  /**
   * Cleanup, e.g. on unmount. Clears any pending timers.
   */
  dispose() {
    this._timers.forEach(clearTimeout);
  }
  /**
   * Determines which items are viewable based on the current metrics and config.
   */
  computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics, renderRange) {
    const itemCount = props.getItemCount(props.data), { itemVisiblePercentThreshold, viewAreaCoveragePercentThreshold } = this._config, viewAreaMode = viewAreaCoveragePercentThreshold != null, viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
    invariant(
      viewablePercentThreshold != null && itemVisiblePercentThreshold != null != (viewAreaCoveragePercentThreshold != null),
      "Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold"
    );
    const viewableIndices = [];
    if (itemCount === 0)
      return viewableIndices;
    let firstVisible = -1;
    const { first, last } = renderRange || { first: 0, last: itemCount - 1 };
    if (last >= itemCount)
      return console.warn(
        "Invalid render range computing viewability " + JSON.stringify({ renderRange, itemCount })
      ), [];
    for (let idx = first; idx <= last; idx++) {
      const metrics = getFrameMetrics(idx, props);
      if (!metrics)
        continue;
      const top = metrics.offset - scrollOffset, bottom = top + metrics.length;
      if (top < viewportHeight && bottom > 0)
        firstVisible = idx, _isViewable(
          viewAreaMode,
          viewablePercentThreshold,
          top,
          bottom,
          viewportHeight,
          metrics.length
        ) && viewableIndices.push(idx);
      else if (firstVisible >= 0)
        break;
    }
    return viewableIndices;
  }
  /**
   * Figures out which items are viewable and how that has changed from before and calls
   * `onViewableItemsChanged` as appropriate.
   */
  onUpdate(props, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged, renderRange) {
    const itemCount = props.getItemCount(props.data);
    if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0, props))
      return;
    let viewableIndices = [];
    if (itemCount && (viewableIndices = this.computeViewableItems(
      props,
      scrollOffset,
      viewportHeight,
      getFrameMetrics,
      renderRange
    )), !(this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every((v, ii) => v === viewableIndices[ii])))
      if (this._viewableIndices = viewableIndices, this._config.minimumViewTime) {
        const handle = setTimeout(() => {
          this._timers.delete(handle), this._onUpdateSync(
            props,
            viewableIndices,
            onViewableItemsChanged,
            createViewToken
          );
        }, this._config.minimumViewTime);
        this._timers.add(handle);
      } else
        this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
  }
  resetViewableIndices() {
    this._viewableIndices = [];
  }
  recordInteraction() {
    this._hasInteracted = true;
  }
  _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
    viewableIndicesToCheck = viewableIndicesToCheck.filter(
      (ii) => this._viewableIndices.includes(ii)
    );
    const prevItems = this._viewableItems, nextItems = new Map(
      viewableIndicesToCheck.map((ii) => {
        const viewable = createViewToken(ii, true, props);
        return [viewable.key, viewable];
      })
    ), changed = [];
    for (const [key, viewable] of nextItems)
      prevItems.has(key) || changed.push(viewable);
    for (const [key, viewable] of prevItems)
      nextItems.has(key) || changed.push(__spreadProps(__spreadValues({}, viewable), { isViewable: false }));
    changed.length > 0 && (this._viewableItems = nextItems, onViewableItemsChanged({
      viewableItems: Array.from(nextItems.values()),
      changed
    }));
  }
}
function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
  if (_isEntirelyVisible(top, bottom, viewportHeight))
    return true;
  {
    const pixels = _getPixelsVisible(top, bottom, viewportHeight);
    return 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength) >= viewablePercentThreshold;
  }
}
function _getPixelsVisible(top, bottom, viewportHeight) {
  const visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
  return Math.max(0, visibleHeight);
}
function _isEntirelyVisible(top, bottom, viewportHeight) {
  return top >= 0 && bottom <= viewportHeight && bottom > top;
}
const VirtualizedListContext = React__namespace.createContext(null);
VirtualizedListContext.displayName = "VirtualizedListContext";
function VirtualizedListCellContextProvider({ cellKey, children }) {
  const currContext = React.useContext(VirtualizedListContext), context2 = React.useMemo(
    () => currContext == null ? null : __spreadProps(__spreadValues({}, currContext), { cellKey }),
    [currContext, cellKey]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualizedListContext.Provider, { value: context2, children });
}
class CellRenderer extends React__namespace.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      separatorProps: {
        highlighted: false,
        leadingItem: this.props.item
      }
    });
    // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
    // reused by SectionList and we can keep VirtualizedList simpler.
    // $FlowFixMe[missing-local-annot]
    __publicField(this, "_separators", {
      highlight: () => {
        var _a, _b;
        const { cellKey, prevCellKey } = this.props;
        (_b = (_a = this.props).onUpdateSeparators) == null ? void 0 : _b.call(_a, [cellKey, prevCellKey], {
          highlighted: true
        });
      },
      unhighlight: () => {
        var _a, _b;
        const { cellKey, prevCellKey } = this.props;
        (_b = (_a = this.props).onUpdateSeparators) == null ? void 0 : _b.call(_a, [cellKey, prevCellKey], {
          highlighted: false
        });
      },
      updateProps: (select, newProps) => {
        var _a, _b;
        const { cellKey, prevCellKey } = this.props;
        (_b = (_a = this.props).onUpdateSeparators) == null ? void 0 : _b.call(
          _a,
          [select === "leading" ? prevCellKey : cellKey],
          newProps
        );
      }
    });
    __publicField(this, "_onLayout", (nativeEvent) => {
      var _a, _b;
      (_b = (_a = this.props).onCellLayout) == null ? void 0 : _b.call(_a, nativeEvent, this.props.cellKey, this.props.index);
    });
  }
  static getDerivedStateFromProps(props, prevState) {
    return {
      separatorProps: __spreadProps(__spreadValues({}, prevState.separatorProps), {
        leadingItem: props.item
      })
    };
  }
  updateSeparatorProps(newProps) {
    this.setState((state) => ({
      separatorProps: __spreadValues(__spreadValues({}, state.separatorProps), newProps)
    }));
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).onUnmount) == null ? void 0 : _b.call(_a, this.props.cellKey);
  }
  _renderElement(renderItem, ListItemComponent2, item, index2) {
    if (renderItem && ListItemComponent2 && console.warn(
      "VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take precedence over renderItem."
    ), ListItemComponent2)
      return React__namespace.createElement(ListItemComponent2, {
        item,
        index: index2,
        separators: this._separators
      });
    if (renderItem)
      return renderItem({
        item,
        index: index2,
        separators: this._separators
      });
    invariant(
      false,
      "VirtualizedList: Either ListItemComponent or renderItem props are required but none were found."
    );
  }
  render() {
    const {
      CellRendererComponent,
      ItemSeparatorComponent,
      ListItemComponent: ListItemComponent2,
      cellKey,
      horizontal,
      item,
      index: index2,
      inversionStyle,
      onCellFocusCapture,
      onCellLayout,
      renderItem
    } = this.props, element = this._renderElement(renderItem, ListItemComponent2, item, index2), itemSeparator = React__namespace.isValidElement(ItemSeparatorComponent) ? (
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent
    ) : (
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent && /* @__PURE__ */ jsxRuntimeExports.jsx(ItemSeparatorComponent, __spreadValues({}, this.state.separatorProps))
    ), cellStyle = inversionStyle ? horizontal ? [styles$e.rowReverse, inversionStyle] : [styles$e.columnReverse, inversionStyle] : horizontal ? [styles$e.row, inversionStyle] : inversionStyle, result = CellRendererComponent ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      CellRendererComponent,
      __spreadProps(__spreadValues({
        cellKey,
        index: index2,
        item,
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && { onLayout: this._onLayout }), {
        children: [
          element,
          itemSeparator
        ]
      })
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View$2,
      __spreadProps(__spreadValues({
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && { onLayout: this._onLayout }), {
        children: [
          element,
          itemSeparator
        ]
      })
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualizedListCellContextProvider, { cellKey: this.props.cellKey, children: result });
  }
}
const styles$e = StyleSheet.create({
  row: {
    flexDirection: "row"
  },
  rowReverse: {
    flexDirection: "row-reverse"
  },
  columnReverse: {
    flexDirection: "column-reverse"
  }
});
function horizontalOrDefault(horizontal) {
  return horizontal != null ? horizontal : false;
}
function scrollEventThrottleOrDefault(scrollEventThrottle) {
  return scrollEventThrottle != null ? scrollEventThrottle : 50;
}
class VirtualizedList extends StateSafePureComponent {
  constructor(props) {
    var _a;
    super(props);
    __publicField(this, "_captureRef", (ref) => {
      this._scrollRef = ref;
    });
    __publicField(this, "_onContentSizeChange", (width, height) => {
    });
    __publicField(this, "_onLayout", (event) => {
    });
    __publicField(this, "_onScroll", (event) => {
    });
    this._nestedChildLists = new ChildListCollection(), this._viewabilityTuples = [], this._scrollMetrics = {
      contentLength: 0,
      dOffset: 0,
      dt: 10,
      offset: 0,
      timestamp: 0,
      velocity: 0,
      visibleLength: 0
    }, this._highestMeasuredFrameIndex = 0, this._headerLength = 0, this._footerLength = 0, this._averageCellLength = 0, this._hasWarned = {}, this._fillRateHelper = new FillRateHelper(this._getFrameMetrics), this._updateCellsToRenderBatcher = new Batchinator(
      this._updateCellsToRender,
      (_a = this.props.updateCellsBatchingPeriod) != null ? _a : 50
    ), this.props.viewabilityConfig && this.props.onViewableItemsChanged && this._viewabilityTuples.push({
      viewabilityHelper: new ViewabilityHelper(this.props.viewabilityConfig),
      onViewableItemsChanged: this.props.onViewableItemsChanged
    });
  }
  scrollToEnd(params) {
    const animated = params ? params.animated : true, veryLast = this.props.getItemCount(this.props.data) - 1;
    if (veryLast < 0)
      return;
    const frame = this.__getFrameMetricsApprox(veryLast, this.props), offset2 = Math.max(
      0,
      frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength
    );
    if (this._scrollRef != null) {
      if (this._scrollRef.scrollTo == null) {
        console.warn(
          "No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo."
        );
        return;
      }
      this._scrollRef.scrollTo(
        horizontalOrDefault(this.props.horizontal) ? { x: offset2, animated } : { y: offset2, animated }
      );
    }
  }
  scrollToIndex(params) {
    const {
      data,
      horizontal,
      getItemCount,
      getItemLayout,
      onScrollToIndexFailed
    } = this.props, { animated, index: index2, viewOffset, viewPosition } = params;
    if (invariant(
      index2 >= 0,
      `scrollToIndex out of range: requested index ${index2} but minimum is 0`
    ), invariant(
      getItemCount(data) >= 1,
      `scrollToIndex out of range: item length ${getItemCount(
        data
      )} but minimum is 1`
    ), invariant(
      index2 < getItemCount(data),
      `scrollToIndex out of range: requested index ${index2} is out of 0 to ${getItemCount(data) - 1}`
    ), !getItemLayout && index2 > this._highestMeasuredFrameIndex) {
      invariant(
        !!onScrollToIndexFailed,
        "scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, otherwise there is no way to know the location of offscreen indices or handle failures."
      ), onScrollToIndexFailed({
        averageItemLength: this._averageCellLength,
        highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
        index: index2
      });
      return;
    }
    const frame = this.__getFrameMetricsApprox(Math.floor(index2), this.props), offset2 = Math.max(
      0,
      this._getOffsetApprox(index2, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)
    ) - (viewOffset || 0);
    this._scrollRef != null && this._scrollRef.scrollTo(
      horizontalOrDefault(horizontal) ? { x: offset2, animated } : { y: offset2, animated }
    );
  }
  scrollToItem(params) {
    const { data, getItem, getItemCount, horizontal, onScrollToIndexFailed } = this.props, { animated, item, viewPosition, viewOffset } = params, index2 = this.props.data.indexOf(item);
    if (index2 !== -1)
      this.scrollToIndex({
        animated,
        index: index2,
        viewOffset,
        viewPosition
      });
    else {
      const itemCount = getItemCount(data);
      for (let i = 0; i < itemCount; i++)
        if (getItem(data, i) === item) {
          this.scrollToIndex({
            animated,
            index: i,
            viewOffset,
            viewPosition
          });
          break;
        }
    }
  }
  scrollToOffset(params) {
    const { animated, offset: offset2 } = params;
    this._scrollRef != null && this._scrollRef.scrollTo(
      horizontalOrDefault(this.props.horizontal) ? { x: offset2, animated } : { y: offset2, animated }
    );
  }
  recordInteraction() {
    this._nestedChildLists.forEach((childList) => {
      childList.recordInteraction();
    }), this._viewabilityTuples.forEach((viewabilityTuple) => {
      viewabilityTuple.viewabilityHelper.recordInteraction();
    });
  }
  flashScrollIndicators() {
    this._scrollRef && this._scrollRef.flashScrollIndicators && this._scrollRef.flashScrollIndicators();
  }
  getScrollResponder() {
    if (this._scrollRef && this._scrollRef.getScrollResponder)
      return this._scrollRef.getScrollResponder();
  }
  getScrollableNode() {
    if (this._scrollRef && this._scrollRef.getScrollableNode)
      return this._scrollRef.getScrollableNode();
  }
  getScrollRef() {
    return this._scrollRef;
  }
  setNativeProps(props) {
    this._scrollRef && this._scrollRef.setNativeProps(props);
  }
  render() {
    const _a = this.props, {
      ListEmptyComponent,
      ListFooterComponent,
      ListHeaderComponent,
      data,
      debug,
      disableVirtualization,
      getItem,
      getItemCount,
      getItemLayout,
      horizontal,
      keyExtractor: keyExtractor2,
      numColumns,
      onEndReached,
      onEndReachedThreshold,
      onLayout,
      onRefresh,
      onScroll,
      onScrollBeginDrag,
      onScrollEndDrag,
      onMomentumScrollBegin,
      onMomentumScrollEnd,
      onStartReached,
      onStartReachedThreshold,
      onViewableItemsChanged,
      refreshing,
      removeClippedSubviews,
      renderItem,
      viewabilityConfig,
      viewabilityConfigCallbackPairs
    } = _a, restProps = __objRest(_a, [
      "ListEmptyComponent",
      "ListFooterComponent",
      "ListHeaderComponent",
      "data",
      "debug",
      "disableVirtualization",
      "getItem",
      "getItemCount",
      "getItemLayout",
      "horizontal",
      "keyExtractor",
      "numColumns",
      "onEndReached",
      "onEndReachedThreshold",
      "onLayout",
      "onRefresh",
      "onScroll",
      "onScrollBeginDrag",
      "onScrollEndDrag",
      "onMomentumScrollBegin",
      "onMomentumScrollEnd",
      "onStartReached",
      "onStartReachedThreshold",
      "onViewableItemsChanged",
      "refreshing",
      "removeClippedSubviews",
      "renderItem",
      "viewabilityConfig",
      "viewabilityConfigCallbackPairs"
    ]);
    return getItemCount(data) === 0 ? ListEmptyComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(ListEmptyComponent, {}) : null : /* @__PURE__ */ jsxRuntimeExports.jsx(
      ForwardedScrollView$1,
      __spreadProps(__spreadValues({}, restProps), {
        ref: this._captureRef,
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout,
        onScroll: this._onScroll,
        refreshControl: onRefresh && /* @__PURE__ */ jsxRuntimeExports.jsx(RefreshControl, { refreshing, onRefresh }),
        scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
        removeClippedSubviews,
        children: this._renderChildren()
      })
    );
  }
  _renderChildren() {
    const { data, getItem, getItemCount, renderItem } = this.props, items = [];
    for (let i = 0; i < getItemCount(data); i++) {
      const item = getItem(data, i);
      items.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CellRenderer,
          {
            cellKey: String(i),
            index: i,
            item,
            renderItem
          },
          this.props.keyExtractor ? this.props.keyExtractor(item, i) : i
        )
      );
    }
    return items;
  }
  __getFrameMetricsApprox(index2, props) {
    return {
      length: this._averageCellLength,
      offset: this._averageCellLength * index2
    };
  }
  _getOffsetApprox(index2, props) {
    return this.__getFrameMetricsApprox(index2, props).offset;
  }
}
__publicField(VirtualizedList, "contextType", VirtualizedListContext);
function keyExtractor(item, index2) {
  return typeof item == "object" && (item == null ? void 0 : item.key) != null ? item.key : typeof item == "object" && (item == null ? void 0 : item.id) != null ? item.id : String(index2);
}
function removeClippedSubviewsOrDefault(removeClippedSubviews) {
  return removeClippedSubviews != null ? removeClippedSubviews : Platform.OS === "android";
}
function numColumnsOrDefault(numColumns) {
  return numColumns != null ? numColumns : 1;
}
function isArrayLike(data) {
  return typeof Object(data).length == "number";
}
class FlatList extends React.PureComponent {
  constructor(props) {
    super(props);
    __publicField(this, "props");
    __publicField(this, "_listRef", null);
    __publicField(this, "_virtualizedListPairs", []);
    __publicField(this, "_captureRef", (ref) => {
      this._listRef = ref;
    });
    __publicField(this, "_getItem", (data, index2) => {
      const numColumns = numColumnsOrDefault(this.props.numColumns);
      if (numColumns > 1) {
        const ret = [];
        for (let kk = 0; kk < numColumns; kk++) {
          const itemIndex = index2 * numColumns + kk;
          if (itemIndex < data.length) {
            const item = data[itemIndex];
            ret.push(item);
          }
        }
        return ret;
      } else return data[index2];
    });
    __publicField(this, "_getItemCount", (data) => {
      if (data != null && isArrayLike(data)) {
        const numColumns = numColumnsOrDefault(this.props.numColumns);
        return numColumns > 1 ? Math.ceil(data.length / numColumns) : data.length;
      } else return 0;
    });
    __publicField(this, "_keyExtractor", (items, index2) => {
      var _a;
      const numColumns = numColumnsOrDefault(this.props.numColumns), keyExtractor$1 = (_a = this.props.keyExtractor) != null ? _a : keyExtractor;
      return numColumns > 1 ? (invariant(Array.isArray(items), "FlatList: Expected each item to be an array with multiple columns."), items.map((item, kk) => keyExtractor$1(item, index2 * numColumns + kk)).join(":")) : keyExtractor$1(items, index2);
    });
    __publicField(this, "_renderer", (ListItemComponent2, renderItem, columnWrapperStyle, numColumns, extraData) => {
      const cols = numColumnsOrDefault(numColumns), render = (props) => ListItemComponent2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemComponent2, __spreadValues({}, props)) : renderItem ? renderItem(props) : null, renderProp = (info) => {
        if (cols > 1) {
          const {
            item,
            index: index2
          } = info;
          return invariant(Array.isArray(item), "Expected array of items with numColumns > 1"), /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, {
            style: [styles$d.row, columnWrapperStyle],
            children: item.map((it, kk) => {
              const element = render({
                item: it,
                index: index2 * cols + kk,
                separators: info.separators
              });
              return element != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, {
                children: element
              }, kk) : null;
            })
          });
        } else return render(info);
      };
      return ListItemComponent2 ? {
        ListItemComponent: renderProp
      } : {
        renderItem: renderProp
      };
    });
    __publicField(this, "_memoizedRenderer", memoizeOne(this._renderer));
    this.props = props, this._checkProps(this.props), this.props.viewabilityConfigCallbackPairs ? this._virtualizedListPairs = this.props.viewabilityConfigCallbackPairs.map((pair) => ({
      viewabilityConfig: pair.viewabilityConfig,
      onViewableItemsChanged: this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
    })) : this.props.onViewableItemsChanged && this._virtualizedListPairs.push({
      viewabilityConfig: this.props.viewabilityConfig,
      onViewableItemsChanged: this._createOnViewableItemsChanged(this.props.onViewableItemsChanged)
    });
  }
  componentDidUpdate(prevProps) {
    invariant(prevProps.numColumns === this.props.numColumns, "Changing numColumns on the fly is not supported. Change the key prop on FlatList when changing the number of columns to force a fresh render of the component."), invariant(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, "Changing onViewableItemsChanged on the fly is not supported"), invariant(!deepDiffer(prevProps.viewabilityConfig, this.props.viewabilityConfig), "Changing viewabilityConfig on the fly is not supported"), invariant(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, "Changing viewabilityConfigCallbackPairs on the fly is not supported"), this._checkProps(this.props);
  }
  _checkProps(props) {
    const {
      getItem,
      getItemCount,
      horizontal,
      columnWrapperStyle,
      onViewableItemsChanged,
      viewabilityConfigCallbackPairs
    } = props, numColumns = numColumnsOrDefault(this.props.numColumns);
    invariant(!getItem && !getItemCount, "FlatList does not support custom data formats."), numColumns > 1 ? invariant(!horizontal, "numColumns does not support horizontal.") : invariant(!columnWrapperStyle, "columnWrapperStyle not supported for single column lists"), invariant(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), "FlatList does not support setting both onViewableItemsChanged and viewabilityConfigCallbackPairs.");
  }
  _pushMultiColumnViewable(arr, v) {
    var _a;
    const numColumns = numColumnsOrDefault(this.props.numColumns), keyExtractor$1 = (_a = this.props.keyExtractor) != null ? _a : keyExtractor;
    v.item.forEach((item, ii) => {
      invariant(v.index != null, "Missing index!");
      const index2 = v.index * numColumns + ii;
      arr.push(__spreadProps(__spreadValues({}, v), {
        item,
        key: keyExtractor$1(item, index2),
        index: index2
      }));
    });
  }
  _createOnViewableItemsChanged(onViewableItemsChanged) {
    return (info) => {
      const numColumns = numColumnsOrDefault(this.props.numColumns);
      if (onViewableItemsChanged) if (numColumns > 1) {
        const changed = [], viewableItems = [];
        info.viewableItems.forEach((v) => this._pushMultiColumnViewable(viewableItems, v)), info.changed.forEach((v) => this._pushMultiColumnViewable(changed, v)), onViewableItemsChanged({
          viewableItems,
          changed
        });
      } else onViewableItemsChanged(info);
    };
  }
  render() {
    const _a = this.props, {
      numColumns,
      columnWrapperStyle,
      removeClippedSubviews: _removeClippedSubviews,
      strictMode = false
    } = _a, restProps = __objRest(_a, [
      "numColumns",
      "columnWrapperStyle",
      "removeClippedSubviews",
      "strictMode"
    ]), renderer = strictMode ? this._memoizedRenderer : this._renderer;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VirtualizedList, __spreadValues(__spreadProps(__spreadValues({}, restProps), {
      getItem: this._getItem,
      getItemCount: this._getItemCount,
      keyExtractor: this._keyExtractor,
      ref: this._captureRef,
      viewabilityConfigCallbackPairs: this._virtualizedListPairs,
      removeClippedSubviews: removeClippedSubviewsOrDefault(_removeClippedSubviews)
    }), renderer(this.props.ListItemComponent, this.props.renderItem, columnWrapperStyle, numColumns, this.props.extraData)));
  }
}
const styles$d = {
  row: {
    flexDirection: "row"
  }
};
const FlatListWithEventThrottle = React__namespace.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(FlatList, __spreadProps(__spreadValues({
  scrollEventThrottle: 1e-4
}, props), {
  ref
})));
createAnimatedComponent(FlatListWithEventThrottle);
let PixelRatio$1 = class PixelRatio {
  /**
   * Returns the device pixel density.
   */
  static get() {
    return Dimensions$1.get("window").scale;
  }
  /**
   * No equivalent for Web
   */
  static getFontScale() {
    return Dimensions$1.get("window").fontScale || PixelRatio.get();
  }
  /**
   * Converts a layout size (dp) to pixel size (px).
   * Guaranteed to return an integer number.
   */
  static getPixelSizeForLayoutSize(layoutSize) {
    return Math.round(layoutSize * PixelRatio.get());
  }
  /**
   * Rounds a layout size (dp) to the nearest layout size that corresponds to
   * an integer number of pixels. For example, on a device with a PixelRatio
   * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
   * exactly (8.33 * 3) = 25 pixels.
   */
  static roundToNearestPixel(layoutSize) {
    const ratio = PixelRatio.get();
    return Math.round(layoutSize * ratio) / ratio;
  }
};
const ERRORED$1 = "ERRORED", LOADED$1 = "LOADED", LOADING$1 = "LOADING", IDLE$1 = "IDLE";
let _filterId$1 = 0;
const svgDataUriPattern$1 = /^(data:image\/svg\+xml;utf8,)(.*)/;
function createTintColorSVG$1(tintColor, id2) {
  return tintColor && id2 != null ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      style: {
        position: "absolute",
        height: 0,
        visibility: "hidden",
        width: 0
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", { id: `tint-${id2}`, suppressHydrationWarning: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", { floodColor: `${tintColor}` }, tintColor),
        /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", { in2: "SourceAlpha", operator: "atop" })
      ] }) })
    }
  ) : null;
}
function getFlatStyle$1(style, blurRadius, filterId) {
  const flatStyle = StyleSheet.flatten(style), { filter, resizeMode, shadowOffset, tintColor } = flatStyle, filters = [];
  let _filter = null;
  if (filter && filters.push(filter), blurRadius && filters.push(`blur(${blurRadius}px)`), shadowOffset) {
    const shadowString = createBoxShadowValue(flatStyle);
    shadowString && filters.push(`drop-shadow(${shadowString})`);
  }
  return tintColor && filterId != null && filters.push(`url(#tint-${filterId})`), filters.length > 0 && (_filter = filters.join(" ")), delete flatStyle.blurRadius, delete flatStyle.shadowColor, delete flatStyle.shadowOpacity, delete flatStyle.shadowOffset, delete flatStyle.shadowRadius, delete flatStyle.tintColor, delete flatStyle.overlayColor, delete flatStyle.resizeMode, [flatStyle, resizeMode, _filter, tintColor];
}
function resolveAssetDimensions$1(source) {
  if (typeof source == "number") {
    const { height, width } = getAssetByID(source);
    return { height, width };
  } else if (source != null && !Array.isArray(source) && typeof source == "object") {
    const { height, width } = source;
    return { height, width };
  }
}
function resolveAssetUri$1(source) {
  let uri = null;
  if (typeof source == "number") {
    const asset = getAssetByID(source);
    let scale = asset.scales[0];
    if (asset.scales.length > 1) {
      const preferredScale = PixelRatio$1.get();
      scale = asset.scales.reduce(
        (prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev
      );
    }
    const scaleSuffix = scale !== 1 ? `@${scale}x` : "";
    uri = asset ? `${asset.httpServerLocation}/${asset.name}${scaleSuffix}.${asset.type}` : "";
  } else typeof source == "string" ? uri = source : source && typeof source.uri == "string" && (uri = source.uri);
  if (uri) {
    const match = uri.match(svgDataUriPattern$1);
    if (match) {
      const [, prefix, svg] = match, encodedSvg = encodeURIComponent(svg);
      return `${prefix}${encodedSvg}`;
    }
  }
  return uri;
}
const Image$2 = React__namespace.forwardRef((props, ref) => {
  const _a = props, {
    accessibilityLabel,
    blurRadius,
    defaultSource,
    draggable,
    onError,
    onLayout,
    onLoad,
    onLoadEnd,
    onLoadStart,
    pointerEvents,
    source,
    style
  } = _a, rest = __objRest(_a, [
    "accessibilityLabel",
    "blurRadius",
    "defaultSource",
    "draggable",
    "onError",
    "onLayout",
    "onLoad",
    "onLoadEnd",
    "onLoadStart",
    "pointerEvents",
    "source",
    "style"
  ]);
  if (props.children)
    throw new Error(
      "The <Image> component cannot contain children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning."
    );
  const [state, updateState] = React__namespace.useState(() => {
    const uri2 = resolveAssetUri$1(source);
    return uri2 != null && ImageLoader.has(uri2) ? LOADED$1 : IDLE$1;
  }), [layout, updateLayout] = React__namespace.useState({}), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hiddenImageRef = React__namespace.useRef(null), filterRef = React__namespace.useRef(_filterId$1++), requestRef = React__namespace.useRef(null), shouldDisplaySource = state === LOADED$1 || state === LOADING$1 && defaultSource == null, [flatStyle, _resizeMode, filter, tintColor] = getFlatStyle$1(
    {},
    blurRadius,
    filterRef.current
  ), resizeMode = props.resizeMode || _resizeMode || "cover", selectedSource = shouldDisplaySource ? source : defaultSource, displayImageUri = resolveAssetUri$1(selectedSource), imageSizeStyle = resolveAssetDimensions$1(selectedSource), backgroundImage = displayImageUri ? `url("${displayImageUri}")` : null, backgroundSize = getBackgroundSize(), hiddenImage = displayImageUri ? createElement("img", {
    alt: accessibilityLabel || "",
    style: styles$c.accessibilityImage$raw,
    draggable: draggable || false,
    ref: hiddenImageRef,
    src: displayImageUri
  }) : null;
  function getBackgroundSize() {
    if (hiddenImageRef.current != null && (resizeMode === "center" || resizeMode === "repeat")) {
      const { naturalHeight, naturalWidth } = hiddenImageRef.current, { height, width } = layout;
      if (naturalHeight && naturalWidth && height && width) {
        const scaleFactor = Math.min(1, width / naturalWidth, height / naturalHeight), x = Math.ceil(scaleFactor * naturalWidth), y = Math.ceil(scaleFactor * naturalHeight);
        return `${x}px ${y}px`;
      }
    }
  }
  function handleLayout(e2) {
    if (resizeMode === "center" || resizeMode === "repeat" || onLayout) {
      const { layout: layout2 } = e2.nativeEvent;
      onLayout && onLayout(e2), updateLayout(layout2);
    }
  }
  const uri = resolveAssetUri$1(source);
  return React__namespace.useEffect(() => {
    abortPendingRequest(), uri != null && (updateState(LOADING$1), onLoadStart && onLoadStart(), requestRef.current = ImageLoader.load(
      uri,
      function(e2) {
        updateState(LOADED$1), onLoad && onLoad(e2), onLoadEnd && onLoadEnd();
      },
      function() {
        updateState(ERRORED$1), onError && onError({
          nativeEvent: {
            error: `Failed to load resource ${uri} (404)`
          }
        }), onLoadEnd && onLoadEnd();
      }
    ));
    function abortPendingRequest() {
      requestRef.current != null && (ImageLoader.abort(requestRef.current), requestRef.current = null);
    }
    return abortPendingRequest;
  }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]), /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View$2,
    __spreadProps(__spreadValues({}, rest), {
      accessibilityLabel,
      onLayout: handleLayout,
      pointerEvents,
      ref,
      style: [
        style,
        styles$c.root,
        hasTextAncestor && styles$c.inline,
        imageSizeStyle,
        flatStyle
      ],
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          View$2,
          {
            style: [
              ...[].concat(styles$c.image),
              resizeModeStyles$1[resizeMode],
              { backgroundImage, filter },
              backgroundSize != null && { backgroundSize }
            ],
            suppressHydrationWarning: true
          }
        ),
        hiddenImage,
        createTintColorSVG$1(tintColor, filterRef.current)
      ]
    })
  );
});
Image$2.displayName = "Image";
const ImageWithStatics$1 = Image$2;
ImageWithStatics$1.getSize = function(uri, success, failure) {
  ImageLoader.getSize(uri, success, failure);
};
ImageWithStatics$1.prefetch = function(uri) {
  return ImageLoader.prefetch(uri);
};
ImageWithStatics$1.queryCache = function(uris) {
  return ImageLoader.queryCache(uris);
};
const styles$c = StyleSheet.create({
  root: {
    flexBasis: "auto",
    overflow: "hidden",
    zIndex: 0
  },
  inline: {
    display: "inline-flex"
  },
  image: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    backgroundColor: "transparent",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    backgroundSize: "cover",
    height: "100%",
    width: "100%",
    zIndex: -1
  }),
  accessibilityImage$raw: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    height: "100%",
    opacity: 0,
    width: "100%",
    zIndex: -1
  })
}), resizeModeStyles$1 = StyleSheet.create({
  center: {
    backgroundSize: "auto"
  },
  contain: {
    backgroundSize: "contain"
  },
  cover: {
    backgroundSize: "cover"
  },
  none: {
    backgroundPosition: "0",
    backgroundSize: "auto"
  },
  repeat: {
    backgroundPosition: "0",
    backgroundRepeat: "repeat",
    backgroundSize: "auto"
  },
  stretch: {
    backgroundSize: "100% 100%"
  }
});
createAnimatedComponent(ImageWithStatics$1);
const ScrollViewWithEventThrottle = React__namespace.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(ForwardedScrollView$1, __spreadProps(__spreadValues({
  scrollEventThrottle: 1e-4
}, props), {
  ref
})));
createAnimatedComponent(ScrollViewWithEventThrottle);
const defaultProps = {
  data: [],
  key: null,
  renderItem: null,
  ItemSeparatorComponent: null,
  keyExtractor: null
};
class VirtualizedSectionList extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_keyExtractor", (item, index2) => (this.props.keyExtractor || this._defaultKeyExtractor)(item, index2));
    __publicField(this, "_defaultKeyExtractor", (item, index2) => item.key != null ? item.key : String(index2));
    __publicField(this, "_captureRef", (ref) => {
      this._listRef = ref;
    });
    __publicField(this, "_renderItem", (itemCount) => ({ item, index: index2 }) => index2 === 0 || index2 === itemCount - 1 ? null : (this.props.renderItem || this._defaultRenderItem)({ item, index: index2, section: item }));
    __publicField(this, "_defaultRenderItem", ({ item }) => null);
    __publicField(this, "_onViewableItemsChanged", (info) => {
      this.props.onViewableItemsChanged && this.props.onViewableItemsChanged(info);
    });
  }
  scrollToLocation(params) {
    let index2 = params.itemIndex;
    for (let i = 0; i < params.sectionIndex; i++)
      index2 += this.props.getItemCount(this.props.sections[i].data) + 2;
    let viewOffset = params.viewOffset || 0;
    if (this._listRef == null)
      return;
    if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
      const frame = this._listRef.__getFrameMetricsApprox(
        index2 - params.itemIndex,
        this._listRef.props
      );
      viewOffset += frame.length;
    }
    const toIndexParams = __spreadProps(__spreadValues({}, params), {
      viewOffset,
      index: index2
    });
    this._listRef.scrollToIndex(toIndexParams);
  }
  getListRef() {
    return this._listRef;
  }
  render() {
    const _a = this.props, {
      ItemSeparatorComponent,
      SectionSeparatorComponent,
      renderItem: _renderItem,
      renderSectionFooter,
      renderSectionHeader,
      sections: _sections,
      stickySectionHeadersEnabled
    } = _a, passThroughProps = __objRest(_a, [
      "ItemSeparatorComponent",
      "SectionSeparatorComponent",
      "renderItem",
      "renderSectionFooter",
      "renderSectionHeader",
      "sections",
      "stickySectionHeadersEnabled"
    ]), listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0, stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : void 0;
    let itemCount = 0;
    for (const section of this.props.sections)
      stickyHeaderIndices == null ? void 0 : stickyHeaderIndices.push(itemCount + listHeaderOffset), itemCount += 2, itemCount += this.props.getItemCount(section.data);
    const renderItem = this._renderItem(itemCount);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VirtualizedList,
      __spreadProps(__spreadValues({}, passThroughProps), {
        keyExtractor: this._keyExtractor,
        stickyHeaderIndices,
        renderItem,
        data: this.props.sections,
        getItem: (sections, index2) => this._getItem(this.props, sections, index2),
        getItemCount: () => itemCount,
        onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : void 0,
        ref: this._captureRef
      })
    );
  }
  _getItem(props, sections, index2) {
    if (!sections)
      return null;
    let itemIdx = index2 - 1;
    for (let i = 0; i < sections.length; i++) {
      const section = sections[i], sectionData = section.data, itemCount = props.getItemCount(sectionData);
      if (itemIdx === -1 || itemIdx === itemCount)
        return section;
      if (itemIdx < itemCount)
        return props.getItem(sectionData, itemIdx);
      itemIdx -= itemCount + 2;
    }
    return null;
  }
}
VirtualizedSectionList.defaultProps = defaultProps;
class SectionList extends React__namespace.PureComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_captureRef", (ref) => {
      this._wrapperListRef = ref;
    });
    __publicField(this, "_getItem", (sections, index2) => {
      if (!sections)
        return null;
      const section = sections[index2];
      return section && section.data ? section.data[0] : null;
    });
    __publicField(this, "_getItemCount", (sections) => sections ? sections.length : 0);
    __publicField(this, "_keyExtractor", (item, index2) => (this.props.keyExtractor || this._defaultKeyExtractor)(item, index2));
    __publicField(this, "_defaultKeyExtractor", (item, index2) => item.key != null ? item.key : String(index2));
    __publicField(this, "_renderItem", ({ item, index: index2, section }) => (this.props.renderItem || this._defaultRenderItem)({ item, index: index2, section }));
    __publicField(this, "_defaultRenderItem", ({ item }) => null);
  }
  scrollToLocation(params) {
    this._wrapperListRef != null && this._wrapperListRef.scrollToLocation(params);
  }
  recordInteraction() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    listRef && listRef.recordInteraction();
  }
  flashScrollIndicators() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    listRef && listRef.flashScrollIndicators();
  }
  getScrollResponder() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    if (listRef)
      return listRef.getScrollResponder();
  }
  getScrollableNode() {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    if (listRef)
      return listRef.getScrollableNode();
  }
  setNativeProps(props) {
    const listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
    listRef && listRef.setNativeProps(props);
  }
  render() {
    const _a = this.props, { sections } = _a, passThroughProps = __objRest(_a, ["sections"]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VirtualizedSectionList,
      __spreadProps(__spreadValues({}, passThroughProps), {
        sections,
        ref: this._captureRef,
        getItem: this._getItem,
        getItemCount: this._getItemCount,
        keyExtractor: this._keyExtractor,
        renderItem: this._renderItem
      })
    );
  }
}
var SectionList_default = SectionList;
const SectionListWithEventThrottle = React__namespace.forwardRef((props, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(SectionList_default, __spreadProps(__spreadValues({
  scrollEventThrottle: 1e-4
}, props), {
  ref
})));
createAnimatedComponent(SectionListWithEventThrottle);
const pickProps$4 = (props) => pick(props, forwardPropsListText), Text$3 = React__namespace.forwardRef(
  (props, forwardedRef) => {
    const _a = props, {
      hrefAttrs,
      numberOfLines,
      onClick,
      onLayout,
      onPress,
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture,
      selectable
    } = _a, rest = __objRest(_a, [
      "hrefAttrs",
      "numberOfLines",
      "onClick",
      "onLayout",
      "onPress",
      "onMoveShouldSetResponder",
      "onMoveShouldSetResponderCapture",
      "onResponderEnd",
      "onResponderGrant",
      "onResponderMove",
      "onResponderReject",
      "onResponderRelease",
      "onResponderStart",
      "onResponderTerminate",
      "onResponderTerminationRequest",
      "onScrollShouldSetResponder",
      "onScrollShouldSetResponderCapture",
      "onSelectionChangeShouldSetResponder",
      "onSelectionChangeShouldSetResponderCapture",
      "onStartShouldSetResponder",
      "onStartShouldSetResponderCapture",
      "selectable"
    ]), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), { direction: contextDirection } = useLocaleContext();
    useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    const handleClick = React__namespace.useCallback(
      (e2) => {
        onClick != null ? onClick(e2) : onPress != null && (e2.stopPropagation(), onPress(e2));
      },
      [onClick, onPress]
    );
    let component = hasTextAncestor ? "span" : "div";
    const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$4(rest);
    if (supportedProps.dir = componentDirection, hasTextAncestor || (supportedProps.dir = componentDirection != null ? componentDirection : "auto"), (onClick || onPress) && (supportedProps.onClick = handleClick), supportedProps.style = [
      numberOfLines != null && numberOfLines > 1 && { WebkitLineClamp: numberOfLines },
      hasTextAncestor === true ? styles$b.textHasAncestor$raw : styles$b.text,
      numberOfLines === 1 && styles$b.textOneLine,
      numberOfLines != null && numberOfLines > 1 && styles$b.textMultiLine,
      props.style,
      selectable === true && styles$b.selectable,
      selectable === false && styles$b.notSelectable,
      onPress && styles$b.pressable
    ], props.href != null && (component = "a", hrefAttrs != null)) {
      const { download, rel, target } = hrefAttrs;
      download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
    }
    const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef2;
    const element = useCreateElement(component, supportedProps);
    return hasTextAncestor ? element : /* @__PURE__ */ jsxRuntimeExports.jsx(TextAncestorContext.Provider, { value: true, children: element });
  }
);
Text$3.displayName = "Text";
const textStyle$1 = {
  backgroundColor: "transparent",
  border: "0 solid black",
  boxSizing: "border-box",
  color: "black",
  display: "inline",
  font: "14px System",
  listStyle: "none",
  margin: 0,
  padding: 0,
  textAlign: "inherit",
  textDecoration: "none",
  whiteSpace: "pre-wrap",
  wordWrap: "break-word"
}, styles$b = {
  text: textStyle$1,
  textHasAncestor$raw: __spreadProps(__spreadValues({}, textStyle$1), {
    color: "inherit",
    font: "inherit",
    whiteSpace: "inherit"
  }),
  textOneLine: {
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  },
  // See #13
  textMultiLine: {
    display: "-webkit-box",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    WebkitBoxOrient: "vertical"
  },
  notSelectable: {
    userSelect: "none"
  },
  selectable: {
    userSelect: "text"
  },
  pressable: {
    cursor: "pointer"
  }
};
createAnimatedComponent(Text$3);
createAnimatedComponent(View$2);
canUseDOM$1 && typeof window.matchMedia == "function" ? window.matchMedia("(prefers-reduced-motion: reduce)") : null;
function getQuery() {
  return canUseDOM$1 && window.matchMedia != null ? window.matchMedia("(prefers-color-scheme: dark)") : null;
}
const query = getQuery(), listenerMapping = /* @__PURE__ */ new WeakMap(), Appearance = {
  getColorScheme() {
    return query && query.matches ? "dark" : "light";
  },
  addChangeListener(listener) {
    let mappedListener = listenerMapping.get(listener);
    mappedListener || (mappedListener = ({
      matches
    }) => {
      listener({
        colorScheme: matches ? "dark" : "light"
      });
    }, listenerMapping.set(listener, mappedListener)), query && query.addListener(mappedListener);
    function remove() {
      const mappedListener2 = listenerMapping.get(listener);
      query && mappedListener2 && query.removeListener(mappedListener2), listenerMapping.delete(listener);
    }
    return {
      remove
    };
  }
};
var reactDom = { exports: {} };
var reactDom_development = {};
var hasRequiredReactDom_development;
function requireReactDom_development() {
  if (hasRequiredReactDom_development) return reactDom_development;
  hasRequiredReactDom_development = 1;
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function() {
    function noop() {
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch (e2) {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error(
        "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
        "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
      ), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      null === dispatcher && console.error(
        "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
      );
      return dispatcher;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React$1 = React, Internals = {
      d: {
        f: noop,
        r: function() {
          throw Error(
            "Invalid form element. requestFormReset must be passed a form that was rendered by React."
          );
        },
        D: noop,
        C: noop,
        L: noop,
        m: noop,
        X: noop,
        S: noop,
        M: noop
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
      "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
    );
    reactDom_development.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    reactDom_development.createPortal = function(children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    reactDom_development.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn)
          return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
          "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
        );
      }
    };
    reactDom_development.preconnect = function(href, options) {
      "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
        "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
        getValueDescriptorExpectingEnumForWarning(options)
      ) : null != options && "string" !== typeof options.crossOrigin && console.error(
        "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
        getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
      ) : console.error(
        "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        getValueDescriptorExpectingObjectForWarning(href)
      );
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    reactDom_development.prefetchDNS = function(href) {
      if ("string" !== typeof href || !href)
        console.error(
          "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
      else if (1 < arguments.length) {
        var options = arguments[1];
        "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : console.error(
          "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
          getValueDescriptorExpectingEnumForWarning(options)
        );
      }
      "string" === typeof href && Internals.d.D(href);
    };
    reactDom_development.preinit = function(href, options) {
      "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
        "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
        getValueDescriptorExpectingEnumForWarning(options)
      ) : "style" !== options.as && "script" !== options.as && console.error(
        'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
        getValueDescriptorExpectingEnumForWarning(options.as)
      ) : console.error(
        "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
        getValueDescriptorExpectingObjectForWarning(href)
      );
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    reactDom_development.preinitModule = function(href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
      if (encountered)
        console.error(
          "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
          encountered
        );
      else
        switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
          case "script":
            break;
          default:
            encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
              'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
              encountered,
              href
            );
        }
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as)
            encountered = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            ), Internals.d.M(href, {
              crossOrigin: encountered,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
        } else null == options && Internals.d.M(href);
    };
    reactDom_development.preload = function(href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error(
        'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
        encountered
      );
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(
          encountered,
          options.crossOrigin
        );
        Internals.d.L(href, encountered, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    reactDom_development.preloadModule = function(href, options) {
      var encountered = "";
      "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error(
        'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
        encountered
      );
      "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
        options.as,
        options.crossOrigin
      ), Internals.d.m(href, {
        as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
        crossOrigin: encountered,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0
      })) : Internals.d.m(href));
    };
    reactDom_development.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    reactDom_development.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    reactDom_development.useFormState = function(action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    reactDom_development.useFormStatus = function() {
      return resolveDispatcher().useHostTransitionStatus();
    };
    reactDom_development.version = "19.1.0";
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
  return reactDom_development;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  {
    reactDom.exports = requireReactDom_development();
  }
  return reactDom.exports;
}
requireReactDom();
const pickProps$3 = (props) => pick(props, forwardPropsListView), View$1 = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    hrefAttrs,
    onLayout,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  } = _a, rest = __objRest(_a, [
    "hrefAttrs",
    "onLayout",
    "onMoveShouldSetResponder",
    "onMoveShouldSetResponderCapture",
    "onResponderEnd",
    "onResponderGrant",
    "onResponderMove",
    "onResponderReject",
    "onResponderRelease",
    "onResponderStart",
    "onResponderTerminate",
    "onResponderTerminationRequest",
    "onScrollShouldSetResponder",
    "onScrollShouldSetResponderCapture",
    "onSelectionChangeShouldSetResponder",
    "onSelectionChangeShouldSetResponderCapture",
    "onStartShouldSetResponder",
    "onStartShouldSetResponderCapture"
  ]);
  React__namespace.Children.toArray(props.children).forEach((item) => {
    typeof item == "string" && console.error(`Unexpected text node: ${item}. A text node cannot be a child of a <View>.`);
  });
  const hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), {
    direction: contextDirection
  } = useLocaleContext();
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  let component = "div";
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$3(rest);
  if (supportedProps.dir = componentDirection, supportedProps.style = [styles$a.view, hasTextAncestor && styles$a.inline, props.style], props.href != null && (component = "a", hrefAttrs != null)) {
    const {
      download,
      rel,
      target
    } = hrefAttrs;
    download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
  }
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
  return supportedProps.ref = setRef2, useCreateElement$1(component, supportedProps);
});
View$1.displayName = "View";
const styles$a = {
  view: {
    alignItems: "stretch",
    boxSizing: "border-box",
    display: "flex",
    flexBasis: "auto",
    flexDirection: "column",
    flexShrink: 0
  },
  inline: {
    display: "inline-flex"
  }
};
const RootTagContext$1 = React__namespace.createContext(null), AppContainer = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    children,
    WrapperComponent
  } = props;
  let innerView = /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
    pointerEvents: "box-none",
    style: styles$9.appContainer,
    children
  }, 1);
  return WrapperComponent && (innerView = /* @__PURE__ */ jsxRuntimeExports.jsx(WrapperComponent, {
    children: innerView
  })), /* @__PURE__ */ jsxRuntimeExports.jsx(RootTagContext$1.Provider, {
    value: props.rootTag,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
      pointerEvents: "box-none",
      ref: forwardedRef,
      style: styles$9.appContainer,
      children: innerView
    })
  });
});
AppContainer.displayName = "AppContainer";
const styles$9 = StyleSheet.create({
  appContainer: {
    flex: 1
  }
});
canUseDOM$1 && !document.hasOwnProperty("hidden") && document.hasOwnProperty("webkitHidden");
const dimensions = {
  window: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  },
  screen: {
    fontScale: 1,
    height: 0,
    scale: 1,
    width: 0
  }
}, listeners = {};
let shouldInit = canUseDOM$1;
function update() {
  if (!canUseDOM$1) return;
  const win = window, docEl = win.document.documentElement;
  dimensions.window = {
    fontScale: 1,
    height: docEl.clientHeight,
    scale: win.devicePixelRatio || 1,
    width: docEl.clientWidth
  }, dimensions.screen = {
    fontScale: 1,
    height: win.screen.height,
    scale: win.devicePixelRatio || 1,
    width: win.screen.width
  };
}
function handleResize() {
  update(), Array.isArray(listeners.change) && listeners.change.forEach((handler) => handler(dimensions));
}
class Dimensions2 {
  static get(dimension) {
    return shouldInit && (shouldInit = false, update()), invariant(dimensions[dimension], `No dimension set for key ${dimension}`), dimensions[dimension];
  }
  static set(initialDimensions) {
    initialDimensions && (canUseDOM$1 ? invariant(false, "Dimensions cannot be set in the browser") : (initialDimensions.screen != null && (dimensions.screen = initialDimensions.screen), initialDimensions.window != null && (dimensions.window = initialDimensions.window)));
  }
  static addEventListener(type, handler) {
    return listeners[type] = listeners[type] || [], listeners[type].push(handler), {
      remove: () => {
        this.removeEventListener(type, handler);
      }
    };
  }
  static removeEventListener(type, handler) {
    Array.isArray(listeners[type]) && (listeners[type] = listeners[type].filter((_handler) => _handler !== handler));
  }
}
canUseDOM$1 && window.addEventListener("resize", handleResize, false);
const Keyboard = {
  addListener() {
    return {
      remove: () => {
      }
    };
  },
  dismiss() {
    dismissKeyboard();
  },
  removeAllListeners() {
  },
  removeListener() {
  }
};
const initialURL = canUseDOM$1 ? window.location.href : "";
class Linking {
  constructor() {
    /**
     * An object mapping of event name
     * and all the callbacks subscribing to it
     */
    __publicField(this, "_eventCallbacks", {});
    /**
     * Adds a event listener for the specified event. The callback will be called when the
     * said event is dispatched.
     */
    __publicField(this, "addEventListener", (event, callback) => {
      if (!this._eventCallbacks[event]) {
        this._eventCallbacks[event] = [callback];
        return;
      }
      this._eventCallbacks[event].push(callback);
    });
    /**
     * Removes a previously added event listener for the specified event. The callback must
     * be the same object as the one passed to `addEventListener`.
     */
    __publicField(this, "removeEventListener", (event, callback) => {
      const filteredCallbacks = this._eventCallbacks[event].filter((c) => c.toString() !== callback.toString());
      this._eventCallbacks[event] = filteredCallbacks;
    });
  }
  _dispatchEvent(event, ...data) {
    const listeners2 = this._eventCallbacks[event];
    listeners2 != null && Array.isArray(listeners2) && listeners2.map((listener) => {
      listener(...data);
    });
  }
  canOpenURL() {
    return Promise.resolve(true);
  }
  getInitialURL() {
    return Promise.resolve(initialURL);
  }
  /**
   * Try to open the given url in a secure fashion. The method returns a Promise object.
   * If a target is passed (including undefined) that target will be used, otherwise '_blank'.
   * If the url opens, the promise is resolved. If not, the promise is rejected.
   * Dispatches the `onOpen` event if `url` is opened successfully.
   */
  openURL(url, target) {
    arguments.length === 1 && (target = "_blank");
    try {
      return open(url, target), this._dispatchEvent("onOpen", url), Promise.resolve();
    } catch (e2) {
      return Promise.reject(e2);
    }
  }
  _validateURL(url) {
    invariant(typeof url == "string", "Invalid URL: should be a string. Was: " + url), invariant(url, "Invalid URL: cannot be empty");
  }
}
const open = (url, target) => {
  if (canUseDOM$1) {
    const urlToOpen = new URL(url, window.location).toString();
    urlToOpen.indexOf("tel:") === 0 ? window.location = urlToOpen : window.open(urlToOpen, target, "noopener");
  }
}, LinkingInstance = new Linking();
const currentCentroidXOfTouchesChangedAfter = () => 0, currentCentroidYOfTouchesChangedAfter = () => 0, previousCentroidXOfTouchesChangedAfter = () => 0, previousCentroidYOfTouchesChangedAfter = () => 0, PanResponder = {
  _initializeGestureState(gestureState) {
    gestureState.moveX = 0, gestureState.moveY = 0, gestureState.x0 = 0, gestureState.y0 = 0, gestureState.dx = 0, gestureState.dy = 0, gestureState.vx = 0, gestureState.vy = 0, gestureState.numberActiveTouches = 0, gestureState._accountsForMovesUpTo = 0;
  },
  _updateGestureStateOnMove(gestureState, touchHistory) {
    gestureState.numberActiveTouches = touchHistory.numberActiveTouches, gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo), gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
    gestureState._accountsForMovesUpTo;
    const prevX = previousCentroidXOfTouchesChangedAfter(), prevY = previousCentroidYOfTouchesChangedAfter(), nextDX = gestureState.dx + (gestureState.moveX - prevX), nextDY = gestureState.dy + (gestureState.moveY - prevY), dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
    gestureState.vx = (nextDX - gestureState.dx) / dt, gestureState.vy = (nextDY - gestureState.dy) / dt, gestureState.dx = nextDX, gestureState.dy = nextDY, gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
  },
  create(config) {
    const interactionState = {
      handle: null
    }, gestureState = {
      stateID: Math.random(),
      moveX: 0,
      moveY: 0,
      x0: 0,
      y0: 0,
      dx: 0,
      dy: 0,
      vx: 0,
      vy: 0,
      numberActiveTouches: 0,
      _accountsForMovesUpTo: 0
    };
    return {
      panHandlers: {
        onStartShouldSetResponder: (evt) => config.onStartShouldSetPanResponder ? config.onStartShouldSetPanResponder(evt, gestureState) : false,
        onMoveShouldSetResponder: (evt) => config.onMoveShouldSetPanResponder ? config.onMoveShouldSetPanResponder(evt, gestureState) : false,
        onResponderGrant: (evt) => {
          this._initializeGestureState(gestureState), gestureState.x0 = evt.nativeEvent.pageX || 0, gestureState.y0 = evt.nativeEvent.pageY || 0, config.onPanResponderGrant && config.onPanResponderGrant(evt, gestureState);
        },
        onResponderMove: (evt) => {
          evt.nativeEvent.touches && evt.nativeEvent.touches.length === 1 && this._updateGestureStateOnMove(gestureState, evt.nativeEvent), config.onPanResponderMove && config.onPanResponderMove(evt, gestureState);
        },
        onResponderRelease: (evt) => {
          config.onPanResponderRelease && config.onPanResponderRelease(evt, gestureState);
        },
        onResponderTerminate: (evt) => {
          config.onPanResponderTerminate && config.onPanResponderTerminate(evt, gestureState);
        },
        onResponderTerminationRequest: (evt) => config.onPanResponderTerminationRequest ? config.onPanResponderTerminationRequest(evt, gestureState) : true
      },
      getInteractionHandle() {
        return interactionState.handle;
      }
    };
  }
};
var PanResponder_default = PanResponder;
class PixelRatio2 {
  /**
   * Returns the device pixel density.
   */
  static get() {
    return Dimensions2.get("window").scale;
  }
  /**
   * No equivalent for Web
   */
  static getFontScale() {
    return Dimensions2.get("window").fontScale || PixelRatio2.get();
  }
  /**
   * Converts a layout size (dp) to pixel size (px).
   * Guaranteed to return an integer number.
   */
  static getPixelSizeForLayoutSize(layoutSize) {
    return Math.round(layoutSize * PixelRatio2.get());
  }
  /**
   * Rounds a layout size (dp) to the nearest layout size that corresponds to
   * an integer number of pixels. For example, on a device with a PixelRatio
   * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
   * exactly (8.33 * 3) = 25 pixels.
   */
  static roundToNearestPixel(layoutSize) {
    const ratio = PixelRatio2.get();
    return Math.round(layoutSize * ratio) / ratio;
  }
}
class UnimplementedView extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "setNativeProps", () => {
    });
  }
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadValues({}, this.props));
  }
}
function TouchableOpacityImpl(props, forwardedRef) {
  const _a = props, {
    activeOpacity,
    delayPressIn,
    delayPressOut,
    delayLongPress,
    disabled,
    focusable,
    onLongPress,
    onPress,
    onPressIn,
    onPressOut,
    rejectResponderTermination,
    style
  } = _a, rest = __objRest(_a, [
    "activeOpacity",
    "delayPressIn",
    "delayPressOut",
    "delayLongPress",
    "disabled",
    "focusable",
    "onLongPress",
    "onPress",
    "onPressIn",
    "onPressOut",
    "rejectResponderTermination",
    "style"
  ]), hostRef = React.useRef(null), setRef2 = useMergeRefs$1(forwardedRef, hostRef), [duration, setDuration] = React.useState("0s"), [opacityOverride, setOpacityOverride] = React.useState(null), setOpacityTo = React.useCallback((value, duration2) => {
    setOpacityOverride(value), setDuration(duration2 ? `${duration2 / 1e3}s` : "0s");
  }, [setOpacityOverride, setDuration]), setOpacityActive = React.useCallback((duration2) => {
    setOpacityTo(activeOpacity != null ? activeOpacity : 0.2, duration2);
  }, [activeOpacity, setOpacityTo]), setOpacityInactive = React.useCallback((duration2) => {
    setOpacityTo(null, duration2);
  }, [setOpacityTo]), pressConfig = React.useMemo(() => ({
    cancelable: !rejectResponderTermination,
    disabled,
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    onLongPress,
    onPress,
    onPressStart(event) {
      const isGrant = event.dispatchConfig != null ? event.dispatchConfig.registrationName === "onResponderGrant" : event.type === "keydown";
      setOpacityActive(isGrant ? 0 : 150), onPressIn == null ? void 0 : onPressIn(event);
    },
    onPressEnd(event) {
      setOpacityInactive(250), onPressOut == null ? void 0 : onPressOut(event);
    }
  }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, setOpacityActive, setOpacityInactive]), pressEventHandlers = usePressEvents(hostRef, pressConfig);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$2, __spreadProps(__spreadValues(__spreadValues({}, rest), pressEventHandlers), {
    accessibilityDisabled: disabled,
    focusable: !disabled && focusable !== false,
    ref: setRef2,
    style: [styles$8.root, !disabled && styles$8.actionable, style, opacityOverride != null && {
      opacity: opacityOverride
    }, {
      transitionDuration: duration
    }]
  }));
}
const styles$8 = StyleSheet.create({
  root: {
    transitionProperty: "opacity",
    transitionDuration: "0.15s",
    userSelect: "none"
  },
  actionable: {
    cursor: "pointer",
    touchAction: "manipulation"
  }
}), TouchableOpacity = React__namespace.memo(React__namespace.forwardRef(TouchableOpacityImpl));
TouchableOpacity.displayName = "TouchableOpacity";
TouchableOpacity.Mixin = {};
const forwardPropsList$1 = {
  accessibilityDisabled: true,
  accessibilityLabel: true,
  accessibilityLiveRegion: true,
  accessibilityRole: true,
  accessibilityState: true,
  accessibilityValue: true,
  children: true,
  disabled: true,
  focusable: true,
  nativeID: true,
  onBlur: true,
  onFocus: true,
  onLayout: true,
  testID: true
}, pickProps$2 = (props) => pick(props, forwardPropsList$1);
function TouchableWithoutFeedbackImpl(props, forwardedRef) {
  const {
    delayPressIn,
    delayPressOut,
    delayLongPress,
    disabled,
    focusable,
    onLongPress,
    onPress,
    onPressIn,
    onPressOut,
    rejectResponderTermination
  } = props, hostRef = React.useRef(null), pressConfig = React.useMemo(() => ({
    cancelable: !rejectResponderTermination,
    disabled,
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    onLongPress,
    onPress,
    onPressStart: onPressIn,
    onPressEnd: onPressOut
  }), [disabled, delayPressIn, delayPressOut, delayLongPress, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination]), pressEventHandlers = usePressEvents(hostRef, pressConfig), element = React__namespace.Children.only(props.children), children = [element.props.children], supportedProps = pickProps$2(props);
  supportedProps.accessibilityDisabled = disabled, supportedProps.focusable = !disabled && focusable !== false, supportedProps.ref = useMergeRefs$1(forwardedRef, hostRef, element.ref);
  const elementProps = Object.assign(supportedProps, pressEventHandlers);
  return React__namespace.cloneElement(element, elementProps, ...children);
}
const TouchableWithoutFeedback = React__namespace.memo(React__namespace.forwardRef(TouchableWithoutFeedbackImpl));
TouchableWithoutFeedback.displayName = "TouchableWithoutFeedback";
const createSvgCircle = (style) => /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
  cx: "16",
  cy: "16",
  fill: "none",
  r: "14",
  strokeWidth: "4",
  style
}), ActivityIndicator = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    animating = true,
    color = "#1976D2",
    hidesWhenStopped = true,
    size = "small",
    style
  } = _a, other = __objRest(_a, [
    "animating",
    "color",
    "hidesWhenStopped",
    "size",
    "style"
  ]), svg = /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
    height: "100%",
    viewBox: "0 0 32 32",
    width: "100%",
    children: [createSvgCircle({
      stroke: color,
      opacity: 0.2
    }), createSvgCircle({
      stroke: color,
      strokeDasharray: 80,
      strokeDashoffset: 60
    })]
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues({}, other), {
    accessibilityRole: "progressbar",
    accessibilityValueMax: 1,
    accessibilityValueMin: 0,
    ref: forwardedRef,
    style: [styles$7.container, style],
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
      children: svg,
      style: [typeof size == "number" ? {
        height: size,
        width: size
      } : indicatorSizes[size], styles$7.animation, !animating && styles$7.animationPause, !animating && hidesWhenStopped && styles$7.hidesWhenStopped]
    })
  }));
});
ActivityIndicator.displayName = "ActivityIndicator";
const styles$7 = StyleSheet.create({
  container: {
    alignItems: "center",
    justifyContent: "center"
  },
  hidesWhenStopped: {
    visibility: "hidden"
  },
  animation: {
    animationDuration: "0.75s",
    animationKeyframes: [{
      "0%": {
        transform: [{
          rotate: "0deg"
        }]
      },
      "100%": {
        transform: [{
          rotate: "360deg"
        }]
      }
    }],
    animationTimingFunction: "linear",
    animationIterationCount: "infinite"
  },
  animationPause: {
    animationPlayState: "paused"
  }
}), indicatorSizes = StyleSheet.create({
  small: {
    width: 20,
    height: 20
  },
  large: {
    width: 36,
    height: 36
  }
});
const ERRORED = "ERRORED", LOADED = "LOADED", LOADING = "LOADING", IDLE = "IDLE";
let _filterId = 0;
const svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;
function createTintColorSVG(tintColor, id2) {
  return tintColor && id2 != null ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", {
    style: {
      position: "absolute",
      height: 0,
      visibility: "hidden",
      width: 0
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("defs", {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("filter", {
        id: `tint-${id2}`,
        suppressHydrationWarning: true,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("feFlood", {
          floodColor: `${tintColor}`
        }, tintColor), /* @__PURE__ */ jsxRuntimeExports.jsx("feComposite", {
          in2: "SourceAlpha",
          operator: "atop"
        })]
      })
    })
  }) : null;
}
function getFlatStyle(style, blurRadius, filterId) {
  const flatStyle = StyleSheet.flatten(style), {
    filter,
    resizeMode,
    shadowOffset,
    tintColor
  } = flatStyle, filters = [];
  let _filter = null;
  if (filter && filters.push(filter), blurRadius && filters.push(`blur(${blurRadius}px)`), shadowOffset) {
    const shadowString = createBoxShadowValue(flatStyle);
    shadowString && filters.push(`drop-shadow(${shadowString})`);
  }
  return tintColor && filterId != null && filters.push(`url(#tint-${filterId})`), filters.length > 0 && (_filter = filters.join(" ")), delete flatStyle.blurRadius, delete flatStyle.shadowColor, delete flatStyle.shadowOpacity, delete flatStyle.shadowOffset, delete flatStyle.shadowRadius, delete flatStyle.tintColor, delete flatStyle.overlayColor, delete flatStyle.resizeMode, [flatStyle, resizeMode, _filter, tintColor];
}
function resolveAssetDimensions(source) {
  if (typeof source == "number") {
    const {
      height,
      width
    } = getAssetByID(source);
    return {
      height,
      width
    };
  } else if (source != null && !Array.isArray(source) && typeof source == "object") {
    const {
      height,
      width
    } = source;
    return {
      height,
      width
    };
  }
}
function resolveAssetUri(source) {
  let uri = null;
  if (typeof source == "number") {
    const asset = getAssetByID(source);
    let scale = asset.scales[0];
    if (asset.scales.length > 1) {
      const preferredScale = PixelRatio2.get();
      scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
    }
    const scaleSuffix = scale !== 1 ? `@${scale}x` : "";
    uri = asset ? `${asset.httpServerLocation}/${asset.name}${scaleSuffix}.${asset.type}` : "";
  } else typeof source == "string" ? uri = source : source && typeof source.uri == "string" && (uri = source.uri);
  if (uri) {
    const match = uri.match(svgDataUriPattern);
    if (match) {
      const [, prefix, svg] = match, encodedSvg = encodeURIComponent(svg);
      return `${prefix}${encodedSvg}`;
    }
  }
  return uri;
}
const Image$1 = React__namespace.forwardRef((props, ref) => {
  const _a = props, {
    accessibilityLabel,
    blurRadius,
    defaultSource,
    draggable,
    onError,
    onLayout,
    onLoad,
    onLoadEnd,
    onLoadStart,
    pointerEvents,
    source,
    style
  } = _a, rest = __objRest(_a, [
    "accessibilityLabel",
    "blurRadius",
    "defaultSource",
    "draggable",
    "onError",
    "onLayout",
    "onLoad",
    "onLoadEnd",
    "onLoadStart",
    "pointerEvents",
    "source",
    "style"
  ]);
  if (props.children) throw new Error("The <Image> component cannot contain children. If you want to render content on top of the image, consider using the <ImageBackground> component or absolute positioning.");
  const [state, updateState] = React__namespace.useState(() => {
    const uri2 = resolveAssetUri(source);
    return uri2 != null && ImageLoader.has(uri2) ? LOADED : IDLE;
  }), [layout, updateLayout] = React__namespace.useState({}), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hiddenImageRef = React__namespace.useRef(null), filterRef = React__namespace.useRef(_filterId++), requestRef = React__namespace.useRef(null), shouldDisplaySource = state === LOADED || state === LOADING && defaultSource == null, [flatStyle, _resizeMode, filter, tintColor] = getFlatStyle({}, blurRadius, filterRef.current), resizeMode = props.resizeMode || _resizeMode || "cover", selectedSource = shouldDisplaySource ? source : defaultSource, displayImageUri = resolveAssetUri(selectedSource), imageSizeStyle = resolveAssetDimensions(selectedSource), backgroundImage = displayImageUri ? `url("${displayImageUri}")` : null, backgroundSize = getBackgroundSize(), hiddenImage = displayImageUri ? createElement$1("img", {
    alt: accessibilityLabel || "",
    style: styles$6.accessibilityImage$raw,
    draggable: draggable || false,
    ref: hiddenImageRef,
    src: displayImageUri
  }) : null;
  function getBackgroundSize() {
    if (hiddenImageRef.current != null && (resizeMode === "center" || resizeMode === "repeat")) {
      const {
        naturalHeight,
        naturalWidth
      } = hiddenImageRef.current, {
        height,
        width
      } = layout;
      if (naturalHeight && naturalWidth && height && width) {
        const scaleFactor = Math.min(1, width / naturalWidth, height / naturalHeight), x = Math.ceil(scaleFactor * naturalWidth), y = Math.ceil(scaleFactor * naturalHeight);
        return `${x}px ${y}px`;
      }
    }
  }
  function handleLayout(e2) {
    if (resizeMode === "center" || resizeMode === "repeat" || onLayout) {
      const {
        layout: layout2
      } = e2.nativeEvent;
      onLayout && onLayout(e2), updateLayout(layout2);
    }
  }
  const uri = resolveAssetUri(source);
  return React__namespace.useEffect(() => {
    abortPendingRequest(), uri != null && (updateState(LOADING), onLoadStart && onLoadStart(), requestRef.current = ImageLoader.load(uri, function(e2) {
      updateState(LOADED), onLoad && onLoad(e2), onLoadEnd && onLoadEnd();
    }, function() {
      updateState(ERRORED), onError && onError({
        nativeEvent: {
          error: `Failed to load resource ${uri} (404)`
        }
      }), onLoadEnd && onLoadEnd();
    }));
    function abortPendingRequest() {
      requestRef.current != null && (ImageLoader.abort(requestRef.current), requestRef.current = null);
    }
    return abortPendingRequest;
  }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]), /* @__PURE__ */ jsxRuntimeExports.jsxs(View$1, __spreadProps(__spreadValues({}, rest), {
    accessibilityLabel,
    onLayout: handleLayout,
    pointerEvents,
    ref,
    style: [style, styles$6.root, hasTextAncestor && styles$6.inline, imageSizeStyle, flatStyle],
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
      style: [...[].concat(styles$6.image), resizeModeStyles[resizeMode], {
        backgroundImage,
        filter
      }, backgroundSize != null && {
        backgroundSize
      }],
      suppressHydrationWarning: true
    }), hiddenImage, createTintColorSVG(tintColor, filterRef.current)]
  }));
});
Image$1.displayName = "Image";
const ImageWithStatics = Image$1;
ImageWithStatics.getSize = function(uri, success, failure) {
  ImageLoader.getSize(uri, success, failure);
};
ImageWithStatics.prefetch = function(uri) {
  return ImageLoader.prefetch(uri);
};
ImageWithStatics.queryCache = function(uris) {
  return ImageLoader.queryCache(uris);
};
const styles$6 = StyleSheet.create({
  root: {
    flexBasis: "auto",
    overflow: "hidden",
    zIndex: 0
  },
  inline: {
    display: "inline-flex"
  },
  image: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    backgroundColor: "transparent",
    backgroundPosition: "center",
    backgroundRepeat: "no-repeat",
    backgroundSize: "cover",
    height: "100%",
    width: "100%",
    zIndex: -1
  }),
  accessibilityImage$raw: __spreadProps(__spreadValues({}, StyleSheet.absoluteFillObject), {
    height: "100%",
    opacity: 0,
    width: "100%",
    zIndex: -1
  })
}), resizeModeStyles = StyleSheet.create({
  center: {
    backgroundSize: "auto"
  },
  contain: {
    backgroundSize: "contain"
  },
  cover: {
    backgroundSize: "cover"
  },
  none: {
    backgroundPosition: "0",
    backgroundSize: "auto"
  },
  repeat: {
    backgroundPosition: "0",
    backgroundRepeat: "repeat",
    backgroundSize: "auto"
  },
  stretch: {
    backgroundSize: "100% 100%"
  }
});
const emptyObject$1 = {}, ImageBackground = React.forwardRef((props, forwardedRef) => {
  const _a = props, {
    children,
    style = emptyObject$1,
    imageStyle,
    imageRef
  } = _a, rest = __objRest(_a, [
    "children",
    "style",
    "imageStyle",
    "imageRef"
  ]), {
    height,
    width
  } = StyleSheet.flatten(style);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(View$1, {
    ref: forwardedRef,
    style,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ImageWithStatics, __spreadProps(__spreadValues({}, rest), {
      ref: imageRef,
      style: [{
        // Temporary Workaround:
        // Current (imperfect yet) implementation of <Image> overwrites width and height styles
        // (which is not quite correct), and these styles conflict with explicitly set styles
        // of <ImageBackground> and with our internal layout model here.
        // So, we have to proxy/reapply these styles explicitly for actual <Image> component.
        // This workaround should be removed after implementing proper support of
        // intrinsic content size of the <Image>.
        width,
        height,
        zIndex: -1
      }, StyleSheet.absoluteFill, imageStyle]
    })), children]
  });
});
ImageBackground.displayName = "ImageBackground";
function Pressable(props, forwardedRef) {
  const _a = props, {
    children,
    delayLongPress,
    delayPressIn,
    delayPressOut,
    disabled,
    focusable,
    onBlur,
    onContextMenu,
    onFocus,
    onHoverIn,
    onHoverOut,
    onKeyDown: onKeyDown2,
    onLongPress,
    onPress,
    onPressMove,
    onPressIn,
    onPressOut,
    style,
    testOnly_hovered,
    testOnly_pressed
  } = _a, rest = __objRest(_a, [
    "children",
    "delayLongPress",
    "delayPressIn",
    "delayPressOut",
    "disabled",
    "focusable",
    "onBlur",
    "onContextMenu",
    "onFocus",
    "onHoverIn",
    "onHoverOut",
    "onKeyDown",
    "onLongPress",
    "onPress",
    "onPressMove",
    "onPressIn",
    "onPressOut",
    "style",
    "testOnly_hovered",
    "testOnly_pressed"
  ]), [hovered, setHovered] = useForceableState(testOnly_hovered === true), [focused, setFocused] = useForceableState(false), [pressed, setPressed] = useForceableState(testOnly_pressed === true), hostRef = React.useRef(null), setRef2 = useMergeRefs$1(forwardedRef, hostRef), pressConfig = React.useMemo(() => ({
    delayLongPress,
    delayPressStart: delayPressIn,
    delayPressEnd: delayPressOut,
    disabled,
    onLongPress,
    onPress,
    onPressChange: setPressed,
    onPressStart: onPressIn,
    onPressMove,
    onPressEnd: onPressOut
  }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressMove, onPressOut, setPressed]), pressEventHandlers = usePressEvents(hostRef, pressConfig), {
    onContextMenu: onContextMenuPress,
    onKeyDown: onKeyDownPress
  } = pressEventHandlers;
  useHover(hostRef, {
    contain: true,
    disabled,
    onHoverChange: setHovered,
    onHoverStart: onHoverIn,
    onHoverEnd: onHoverOut
  });
  const interactionState = {
    hovered,
    focused,
    pressed
  }, blurHandler = React__namespace.useCallback((e2) => {
    disabled || e2.nativeEvent.target === hostRef.current && (setFocused(false), onBlur == null ? void 0 : onBlur(e2));
  }, [disabled, hostRef, setFocused, onBlur]), focusHandler = React__namespace.useCallback((e2) => {
    disabled || e2.nativeEvent.target === hostRef.current && (setFocused(true), onFocus == null ? void 0 : onFocus(e2));
  }, [disabled, hostRef, setFocused, onFocus]), contextMenuHandler = React__namespace.useCallback((e2) => {
    onContextMenuPress == null ? void 0 : onContextMenuPress(e2), onContextMenu == null ? void 0 : onContextMenu(e2);
  }, [onContextMenu, onContextMenuPress]), keyDownHandler = React__namespace.useCallback((e2) => {
    onKeyDownPress == null ? void 0 : onKeyDownPress(e2), onKeyDown2 == null ? void 0 : onKeyDown2(e2);
  }, [onKeyDown2, onKeyDownPress]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues(__spreadValues({}, rest), pressEventHandlers), {
    accessibilityDisabled: disabled,
    focusable: !disabled && focusable !== false,
    onBlur: blurHandler,
    onContextMenu: contextMenuHandler,
    onFocus: focusHandler,
    onKeyDown: keyDownHandler,
    pointerEvents: disabled ? "none" : rest.pointerEvents,
    ref: setRef2,
    style: [!disabled && styles$5.root, typeof style == "function" ? style(interactionState) : style],
    children: typeof children == "function" ? children(interactionState) : children
  }));
}
function useForceableState(forced) {
  const [bool, setBool] = React.useState(false);
  return [bool || forced, setBool];
}
const styles$5 = StyleSheet.create({
  root: {
    cursor: "pointer",
    touchAction: "manipulation"
  }
}), PressableComponent = React.memo(React.forwardRef(Pressable));
PressableComponent.displayName = "Pressable";
const cssFunction = canUseDOM$1 && window.CSS && window.CSS.supports && window.CSS.supports("top: constant(safe-area-inset-top)") ? "constant" : "env", SafeAreaView = React__namespace.forwardRef((props, ref) => {
  const _a = props, {
    style
  } = _a, rest = __objRest(_a, [
    "style"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues({}, rest), {
    ref,
    style: StyleSheet.compose(styles$4.root, style)
  }));
});
SafeAreaView.displayName = "SafeAreaView";
const styles$4 = StyleSheet.create({
  root: {
    paddingTop: `${cssFunction}(safe-area-inset-top)`,
    paddingRight: `${cssFunction}(safe-area-inset-right)`,
    paddingBottom: `${cssFunction}(safe-area-inset-bottom)`,
    paddingLeft: `${cssFunction}(safe-area-inset-left)`
  }
});
function normalizeScrollEvent(e2) {
  return {
    nativeEvent: {
      contentOffset: {
        get x() {
          return e2.target.scrollLeft;
        },
        get y() {
          return e2.target.scrollTop;
        }
      },
      contentSize: {
        get height() {
          return e2.target.scrollHeight;
        },
        get width() {
          return e2.target.scrollWidth;
        }
      },
      layoutMeasurement: {
        get height() {
          return e2.target.offsetHeight;
        },
        get width() {
          return e2.target.offsetWidth;
        }
      }
    },
    timeStamp: Date.now()
  };
}
function shouldEmitScrollEvent(lastTick, eventThrottle) {
  const timeSinceLastTick = Date.now() - lastTick;
  return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
}
const ScrollViewBase = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    onScroll,
    onTouchMove,
    onWheel,
    scrollEnabled = true,
    scrollEventThrottle = 0,
    showsHorizontalScrollIndicator,
    showsVerticalScrollIndicator,
    style
  } = _a, rest = __objRest(_a, [
    "onScroll",
    "onTouchMove",
    "onWheel",
    "scrollEnabled",
    "scrollEventThrottle",
    "showsHorizontalScrollIndicator",
    "showsVerticalScrollIndicator",
    "style"
  ]), scrollState = React__namespace.useRef({
    isScrolling: false,
    scrollLastTick: 0
  }), scrollTimeout = React__namespace.useRef(null), scrollRef = React__namespace.useRef(null);
  function createPreventableScrollHandler(handler) {
    return (e2) => {
      scrollEnabled && handler && handler(e2);
    };
  }
  function handleScroll(e2) {
    e2.stopPropagation(), e2.target === scrollRef.current && (e2.persist(), scrollTimeout.current != null && clearTimeout(scrollTimeout.current), scrollTimeout.current = setTimeout(() => {
      handleScrollEnd(e2);
    }, 100), scrollState.current.isScrolling ? shouldEmitScrollEvent(scrollState.current.scrollLastTick, scrollEventThrottle) && handleScrollTick(e2) : handleScrollStart(e2));
  }
  function handleScrollStart(e2) {
    scrollState.current.isScrolling = true, handleScrollTick(e2);
  }
  function handleScrollTick(e2) {
    scrollState.current.scrollLastTick = Date.now(), onScroll && onScroll(normalizeScrollEvent(e2));
  }
  function handleScrollEnd(e2) {
    scrollState.current.isScrolling = false, onScroll && onScroll(normalizeScrollEvent(e2));
  }
  const hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues({}, rest), {
    onScroll: handleScroll,
    onTouchMove: createPreventableScrollHandler(onTouchMove),
    onWheel: createPreventableScrollHandler(onWheel),
    ref: useMergeRefs$1(scrollRef, forwardedRef),
    style: [
      style,
      // @ts-ignore
      !scrollEnabled && styles$3.scrollDisabled,
      // @ts-ignore
      hideScrollbar && styles$3.hideScrollbar
    ]
  }));
}), styles$3 = {
  scrollDisabled: {
    overflowX: "hidden",
    overflowY: "hidden",
    touchAction: "none"
  },
  hideScrollbar: {
    scrollbarWidth: "none"
  }
};
const emptyObject = {}, IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
let ScrollView$1 = class ScrollView2 extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "_scrollNodeRef");
    __publicField(this, "_innerViewRef");
    __publicField(this, "keyboardWillOpenTo", null);
    __publicField(this, "additionalScrollOffset", 0);
    __publicField(this, "preventNegativeScrollOffset", false);
    __publicField(this, "isTouching", false);
    __publicField(this, "lastMomentumScrollBeginTime", 0);
    __publicField(this, "lastMomentumScrollEndTime", 0);
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    __publicField(this, "observedScrollSinceBecomingResponder", false);
    __publicField(this, "becameResponderWhileAnimating", false);
    __publicField(this, "flashScrollIndicators", () => {
      this.scrollResponderFlashScrollIndicators();
    });
    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollTo", (y, x, animated) => {
      typeof y == "number" ? console.warn("`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.") : {
        x,
        y,
        animated
      } = y || emptyObject, this.scrollResponderScrollTo({
        x: x || 0,
        y: y || 0,
        animated: animated !== false
      });
    });
    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */
    __publicField(this, "scrollToEnd", (options) => {
      const animated = (options && options.animated) !== false, {
        horizontal
      } = this.props, scrollResponderNode = this.getScrollableNode(), x = horizontal ? scrollResponderNode.scrollWidth : 0, y = horizontal ? 0 : scrollResponderNode.scrollHeight;
      this.scrollResponderScrollTo({
        x,
        y,
        animated
      });
    });
    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */
    __publicField(this, "scrollResponderScrollTo", (x, y, animated) => {
      typeof x == "number" ? console.warn("`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.") : {
        x,
        y,
        animated
      } = x || emptyObject;
      const node = this.getScrollableNode(), left = x || 0, top = y || 0;
      node != null && (typeof node.scroll == "function" ? node.scroll({
        top,
        left,
        behavior: animated ? "smooth" : "auto"
      }) : (node.scrollLeft = left, node.scrollTop = top));
    });
    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */
    __publicField(this, "scrollResponderZoomTo", (rect, animated) => {
      invariant("zoomToRect is not implemented");
    });
    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */
    __publicField(this, "scrollResponderScrollNativeHandleToKeyboard", (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
      this.additionalScrollOffset = additionalOffset || 0, this.preventNegativeScrollOffset = !!preventNegativeScrollOffset, UIManager.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
    });
    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */
    __publicField(this, "scrollResponderInputMeasureAndScrollToKeyboard", (left, top, width, height) => {
      let keyboardScreenY = Dimensions2.get("window").height;
      this.keyboardWillOpenTo && (keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY);
      let scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;
      this.preventNegativeScrollOffset && (scrollOffsetY = Math.max(0, scrollOffsetY)), this.scrollResponderScrollTo({
        x: 0,
        y: scrollOffsetY,
        animated: true
      }), this.additionalScrollOffset = 0, this.preventNegativeScrollOffset = false;
    });
    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */
    __publicField(this, "scrollResponderKeyboardWillShow", (e2) => {
      this.keyboardWillOpenTo = e2, this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardWillHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidShow", (e2) => {
      e2 && (this.keyboardWillOpenTo = e2), this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e2);
    });
    __publicField(this, "scrollResponderKeyboardDidHide", (e2) => {
      this.keyboardWillOpenTo = null, this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e2);
    });
  }
  /**
   * Returns a reference to the underlying scroll responder, which supports
   * operations like `scrollTo`. All ScrollView-like components should
   * implement this method so that they can be composed while providing access
   * to the underlying scroll responder's methods.
   */
  getScrollResponder() {
    return this;
  }
  getScrollableNode() {
    return this._scrollNodeRef;
  }
  getInnerViewRef() {
    return this._innerViewRef;
  }
  getInnerViewNode() {
    return this._innerViewRef;
  }
  getNativeScrollRef() {
    return this._scrollNodeRef;
  }
  render() {
    const _a = this.props, {
      contentContainerStyle,
      horizontal,
      onContentSizeChange,
      refreshControl,
      stickyHeaderIndices,
      pagingEnabled,
      forwardedRef: forwardedRef,
      keyboardDismissMode,
      onScroll,
      centerContent
    } = _a, other = __objRest(_a, [
      "contentContainerStyle",
      "horizontal",
      "onContentSizeChange",
      "refreshControl",
      "stickyHeaderIndices",
      "pagingEnabled",
      /* eslint-disable */
      "forwardedRef",
      "keyboardDismissMode",
      "onScroll",
      "centerContent"
    ]);
    if (this.props.style) {
      const style = StyleSheet.flatten(this.props.style), childLayoutProps = ["alignItems", "justifyContent"].filter((prop) => style && style[prop] !== void 0);
      invariant(childLayoutProps.length === 0, `ScrollView child layout (${JSON.stringify(childLayoutProps)}) must be applied through the contentContainerStyle prop.`);
    }
    let contentSizeChangeProps = {};
    onContentSizeChange && (contentSizeChangeProps = {
      onLayout: this._handleContentOnLayout.bind(this)
    });
    const hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices), children = hasStickyHeaderIndices || pagingEnabled ? React.Children.map(this.props.children, (child, i) => {
      const isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
      return child != null && (isSticky || pagingEnabled) ? /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
        style: StyleSheet.compose(isSticky && styles$2.stickyHeader, pagingEnabled && styles$2.pagingEnabledChild),
        children: child
      }) : child;
    }) : this.props.children, contentContainer = /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, __spreadProps(__spreadValues({}, contentSizeChangeProps), {
      collapsable: false,
      ref: this._setInnerViewRef.bind(this),
      style: [horizontal && styles$2.contentContainerHorizontal, centerContent && styles$2.contentContainerCenterContent, contentContainerStyle],
      children
    })), baseStyle = horizontal ? styles$2.baseHorizontal : styles$2.baseVertical, pagingEnabledStyle = horizontal ? styles$2.pagingEnabledHorizontal : styles$2.pagingEnabledVertical, props = __spreadProps(__spreadValues({}, other), {
      style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
      onTouchStart: this.scrollResponderHandleTouchStart.bind(this),
      onTouchMove: this.scrollResponderHandleTouchMove.bind(this),
      onTouchEnd: this.scrollResponderHandleTouchEnd.bind(this),
      onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag.bind(this),
      onScrollEndDrag: this.scrollResponderHandleScrollEndDrag.bind(this),
      onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin.bind(this),
      onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd.bind(this),
      onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder.bind(this),
      onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture.bind(this),
      onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder.bind(this),
      onScroll: this._handleScroll.bind(this),
      onResponderGrant: this.scrollResponderHandleResponderGrant.bind(this),
      onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest.bind(this),
      onResponderRelease: this.scrollResponderHandleResponderRelease.bind(this),
      onResponderReject: this.scrollResponderHandleResponderReject.bind(this),
      onResponderTerminate: this.scrollResponderHandleTerminate.bind(this)
    }), ScrollViewClass = ScrollViewBase;
    invariant(ScrollViewClass !== void 0, "ScrollViewClass must not be undefined");
    const scrollView = /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollViewClass, __spreadProps(__spreadValues({}, props), {
      ref: this._setScrollNodeRef.bind(this),
      children: contentContainer
    }));
    return refreshControl ? React.cloneElement(refreshControl, {
      style: props.style
    }, scrollView) : scrollView;
  }
  _handleContentOnLayout(e2) {
    var _a, _b;
    const {
      width,
      height
    } = e2.nativeEvent.layout;
    (_b = (_a = this.props).onContentSizeChange) == null ? void 0 : _b.call(_a, width, height);
  }
  _handleScroll(e2) {
    this.props.onScroll && this.props.scrollEventThrottle == null && console.info("You specified `onScroll` on a <ScrollView> but not `scrollEventThrottle`. You will only receive one event. Using `16` you get all the events but be aware that it may cause frame drops, use a bigger number if you don't need as much precision."), this.props.keyboardDismissMode === "on-drag" && dismissKeyboard(), this.scrollResponderHandleScroll(e2);
  }
  _setInnerViewRef(node) {
    this._innerViewRef = node;
  }
  _setScrollNodeRef(node) {
    this._scrollNodeRef = node, node != null && (node.getScrollResponder = this.getScrollResponder, node.getInnerViewNode = this.getInnerViewNode, node.getInnerViewRef = this.getInnerViewRef, node.getNativeScrollRef = this.getNativeScrollRef, node.getScrollableNode = this.getScrollableNode, node.scrollTo = this.scrollTo, node.scrollToEnd = this.scrollToEnd, node.flashScrollIndicators = this.flashScrollIndicators, node.scrollResponderZoomTo = this.scrollResponderZoomTo, node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard), mergeRefs(this.props.forwardedRef)(node);
  }
  /**
   * Invoke this from an `onScroll` event.
   */
  scrollResponderHandleScrollShouldSetResponder() {
    return this.isTouching;
  }
  /**
   * Merely touch starting is not sufficient for a scroll view to become the
   * responder. Being the "responder" means that the very next touch move/end
   * event will result in an action/movement.
   *
   * Invoke this from an `onStartShouldSetResponder` event.
   *
   * `onStartShouldSetResponder` is used when the next move/end will trigger
   * some UI movement/action, but when you want to yield priority to views
   * nested inside of the view.
   *
   * There may be some cases where scroll views actually should return `true`
   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
   * that gives priority to nested views.
   *
   * - If a single tap on the scroll view triggers an action such as
   *   recentering a map style view yet wants to give priority to interaction
   *   views inside (such as dropped pins or labels), then we would return true
   *   from this method when there is a single touch.
   *
   * - Similar to the previous case, if a two finger "tap" should trigger a
   *   zoom, we would check the `touches` count, and if `>= 2`, we would return
   *   true.
   *
   */
  scrollResponderHandleStartShouldSetResponder() {
    return false;
  }
  /**
   * There are times when the scroll view wants to become the responder
   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
   * that *doesn't* give priority to nested views (hence the capture phase):
   *
   * - Currently animating.
   * - Tapping anywhere that is not the focused input, while the keyboard is
   *   up (which should dismiss the keyboard).
   *
   * Invoke this from an `onStartShouldSetResponderCapture` event.
   */
  scrollResponderHandleStartShouldSetResponderCapture(e2) {
    return this.scrollResponderIsAnimating();
  }
  /**
   * Invoke this from an `onResponderReject` event.
   *
   * Some other element is not yielding its role as responder. Normally, we'd
   * just disable the `UIScrollView`, but a touch has already began on it, the
   * `UIScrollView` will not accept being disabled after that. The easiest
   * solution for now is to accept the limitation of disallowing this
   * altogether. To improve this, find a way to disable the `UIScrollView` after
   * a touch has already started.
   */
  scrollResponderHandleResponderReject() {
    warning();
  }
  /**
   * We will allow the scroll view to give up its lock iff it acquired the lock
   * during an animation. This is a very useful default that happens to satisfy
   * many common user experiences.
   *
   * - Stop a scroll on the left edge, then turn that into an outer view's
   *   backswipe.
   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
   *   view dismiss.
   * - However, without catching the scroll view mid-bounce (while it is
   *   motionless), if you drag far enough for the scroll view to become
   *   responder (and therefore drag the scroll view a bit), any backswipe
   *   navigation of a swipe gesture higher in the view hierarchy, should be
   *   rejected.
   */
  scrollResponderHandleTerminationRequest() {
    return !this.observedScrollSinceBecomingResponder;
  }
  /**
   * Invoke this from an `onTouchEnd` event.
   *
   * @param {SyntheticEvent} e Event.
   */
  scrollResponderHandleTouchEnd(e2) {
    const nativeEvent = e2.nativeEvent;
    this.isTouching = nativeEvent.touches.length !== 0, this.props.onTouchEnd && this.props.onTouchEnd(e2);
  }
  /**
   * Invoke this from an `onResponderRelease` event.
   */
  scrollResponderHandleResponderRelease(e2) {
    this.props.onResponderRelease && this.props.onResponderRelease(e2);
    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
    !this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e2.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating && (this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e2), TextInputState.blurTextInput(currentlyFocusedTextInput));
  }
  scrollResponderHandleScroll(e2) {
    this.observedScrollSinceBecomingResponder = true, this.props.onScroll && this.props.onScroll(e2);
  }
  /**
   * Invoke this from an `onResponderGrant` event.
   */
  scrollResponderHandleResponderGrant(e2) {
    this.observedScrollSinceBecomingResponder = false, this.props.onResponderGrant && this.props.onResponderGrant(e2), this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
  }
  /**
   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
   * animation, and there's not an easy way to distinguish a drag vs. stopping
   * momentum.
   *
   * Invoke this from an `onScrollBeginDrag` event.
   */
  scrollResponderHandleScrollBeginDrag(e2) {
    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e2);
  }
  /**
   * Invoke this from an `onScrollEndDrag` event.
   */
  scrollResponderHandleScrollEndDrag(e2) {
    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollBegin` event.
   */
  scrollResponderHandleMomentumScrollBegin(e2) {
    this.lastMomentumScrollBeginTime = Date.now(), this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e2);
  }
  /**
   * Invoke this from an `onMomentumScrollEnd` event.
   */
  scrollResponderHandleMomentumScrollEnd(e2) {
    this.lastMomentumScrollEndTime = Date.now(), this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e2);
  }
  /**
   * Invoke this from an `onTouchStart` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchStart(e2) {
    this.isTouching = true, this.props.onTouchStart && this.props.onTouchStart(e2);
  }
  /**
   * Invoke this from an `onTouchMove` event.
   *
   * Since we know that the `SimpleEventPlugin` occurs later in the plugin
   * order, after `ResponderEventPlugin`, we can detect that we were *not*
   * permitted to be the responder (presumably because a contained view became
   * responder). The `onResponderReject` won't fire in that case - it only
   * fires when a *current* responder rejects our request.
   *
   * @param {SyntheticEvent} e Touch Start event.
   */
  scrollResponderHandleTouchMove(e2) {
    this.props.onTouchMove && this.props.onTouchMove(e2);
  }
  scrollResponderHandleTerminate(e2) {
    this.props.onResponderTerminate && this.props.onResponderTerminate(e2);
  }
  /**
   * A helper function for this class that lets us quickly determine if the
   * view is currently animating. This is particularly useful to know when
   * a touch has just started or ended.
   */
  scrollResponderIsAnimating() {
    return Date.now() - this.lastMomentumScrollEndTime < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
  }
  /**
   * Displays the scroll indicators momentarily.
   */
  scrollResponderFlashScrollIndicators() {
  }
  scrollResponderTextInputFocusError(e2) {
    console.error("Error measuring text field: ", e2);
  }
};
const commonStyle = {
  flexGrow: 1,
  flexShrink: 1,
  // Enable hardware compositing in modern browsers.
  // Creates a new layer with its own backing surface that can significantly
  // improve scroll performance.
  transform: [{
    translateZ: 0
  }],
  // iOS native scrolling
  WebkitOverflowScrolling: "touch"
}, styles$2 = {
  baseVertical: __spreadProps(__spreadValues({}, commonStyle), {
    flexDirection: "column",
    overflowX: "hidden",
    overflowY: "auto"
  }),
  baseHorizontal: __spreadProps(__spreadValues({}, commonStyle), {
    flexDirection: "row",
    overflowX: "auto",
    overflowY: "hidden"
  }),
  contentContainerHorizontal: {
    flexDirection: "row"
  },
  contentContainerCenterContent: {
    justifyContent: "center",
    flexGrow: 1
  },
  stickyHeader: {
    position: "sticky",
    top: 0,
    zIndex: 10
  },
  pagingEnabledHorizontal: {
    scrollSnapType: "x mandatory"
  },
  pagingEnabledVertical: {
    scrollSnapType: "y mandatory"
  },
  pagingEnabledChild: {
    scrollSnapAlign: "start"
  }
}, ForwardedScrollView = React.forwardRef((props, forwardedRef) => /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollView$1, __spreadProps(__spreadValues({}, props), {
  forwardedRef
})));
ForwardedScrollView.displayName = "ScrollView";
const pickProps$1 = (props) => pick(props, forwardPropsListText), Text$2 = React__namespace.forwardRef((props, forwardedRef) => {
  const _a = props, {
    hrefAttrs,
    numberOfLines,
    onClick,
    onLayout,
    onPress,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture,
    selectable
  } = _a, rest = __objRest(_a, [
    "hrefAttrs",
    "numberOfLines",
    "onClick",
    "onLayout",
    "onPress",
    "onMoveShouldSetResponder",
    "onMoveShouldSetResponderCapture",
    "onResponderEnd",
    "onResponderGrant",
    "onResponderMove",
    "onResponderReject",
    "onResponderRelease",
    "onResponderStart",
    "onResponderTerminate",
    "onResponderTerminationRequest",
    "onScrollShouldSetResponder",
    "onScrollShouldSetResponderCapture",
    "onSelectionChangeShouldSetResponder",
    "onSelectionChangeShouldSetResponderCapture",
    "onStartShouldSetResponder",
    "onStartShouldSetResponderCapture",
    "selectable"
  ]), hasTextAncestor = React__namespace.useContext(TextAncestorContext), hostRef = React__namespace.useRef(null), {
    direction: contextDirection
  } = useLocaleContext();
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  const handleClick = React__namespace.useCallback((e2) => {
    onClick != null ? onClick(e2) : onPress != null && (e2.stopPropagation(), onPress(e2));
  }, [onClick, onPress]);
  let component = hasTextAncestor ? "span" : "div";
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, supportedProps = pickProps$1(rest);
  if (supportedProps.dir = componentDirection, hasTextAncestor || (supportedProps.dir = componentDirection != null ? componentDirection : "auto"), (onClick || onPress) && (supportedProps.onClick = handleClick), supportedProps.style = [numberOfLines != null && numberOfLines > 1 && {
    WebkitLineClamp: numberOfLines
  }, hasTextAncestor === true ? styles$1.textHasAncestor$raw : styles$1.text, numberOfLines === 1 && styles$1.textOneLine, numberOfLines != null && numberOfLines > 1 && styles$1.textMultiLine, props.style, selectable === true && styles$1.selectable, selectable === false && styles$1.notSelectable, onPress && styles$1.pressable], props.href != null && (component = "a", hrefAttrs != null)) {
    const {
      download,
      rel,
      target
    } = hrefAttrs;
    download != null && (supportedProps.download = download), rel != null && (supportedProps.rel = rel), typeof target == "string" && (supportedProps.target = target.charAt(0) !== "_" ? "_" + target : target);
  }
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, forwardedRef);
  supportedProps.ref = setRef2;
  const element = useCreateElement$1(component, supportedProps);
  return hasTextAncestor ? element : /* @__PURE__ */ jsxRuntimeExports.jsx(TextAncestorContext.Provider, {
    value: true,
    children: element
  });
});
Text$2.displayName = "Text";
const textStyle = {
  backgroundColor: "transparent",
  border: "0 solid black",
  boxSizing: "border-box",
  color: "black",
  display: "inline",
  font: "14px System",
  listStyle: "none",
  margin: 0,
  padding: 0,
  textAlign: "inherit",
  textDecoration: "none",
  whiteSpace: "pre-wrap",
  wordWrap: "break-word"
}, styles$1 = {
  text: textStyle,
  textHasAncestor$raw: __spreadProps(__spreadValues({}, textStyle), {
    color: "inherit",
    font: "inherit",
    whiteSpace: "inherit"
  }),
  textOneLine: {
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  },
  // See #13
  textMultiLine: {
    display: "-webkit-box",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    WebkitBoxOrient: "vertical"
  },
  notSelectable: {
    userSelect: "none"
  },
  selectable: {
    userSelect: "text"
  },
  pressable: {
    cursor: "pointer"
  }
};
const isSelectionStale = (node, selection) => {
  const {
    selectionEnd,
    selectionStart
  } = node, {
    start,
    end
  } = selection;
  return start !== selectionStart || end !== selectionEnd;
}, setSelection = (node, selection) => {
  if (isSelectionStale(node, selection)) {
    const {
      start,
      end
    } = selection;
    try {
      node.setSelectionRange(start, end || start);
    } catch (e2) {
    }
  }
}, forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
  autoCapitalize: true,
  className: true,
  autoComplete: true,
  autoCorrect: true,
  autoFocus: true,
  defaultValue: true,
  disabled: true,
  lang: true,
  maxLength: true,
  onChange: true,
  onScroll: true,
  placeholder: true,
  pointerEvents: true,
  readOnly: true,
  rows: true,
  spellCheck: true,
  value: true,
  type: true
}), pickProps = (props) => pick(props, forwardPropsList), useIsomorphicLayoutEffect$1 = typeof window > "u" ? React__namespace.useEffect : React__namespace.useLayoutEffect;
function isEventComposing(nativeEvent) {
  return nativeEvent.isComposing || nativeEvent.keyCode === 229;
}
let focusTimeout = null;
const TextInput = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    autoCapitalize = "sentences",
    autoComplete,
    autoCompleteType,
    autoCorrect = true,
    blurOnSubmit,
    clearTextOnFocus,
    dir,
    editable,
    enterKeyHint,
    inputMode = "text",
    keyboardType,
    multiline = false,
    numberOfLines,
    onBlur,
    onChange,
    onChangeText,
    onContentSizeChange,
    onFocus,
    onKeyPress,
    onLayout,
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChange,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture,
    onSubmitEditing,
    placeholderTextColor,
    readOnly = false,
    returnKeyType,
    rows = 1,
    secureTextEntry = false,
    selection,
    selectTextOnFocus,
    showSoftInputOnFocus,
    caretHidden,
    spellCheck
  } = props;
  let type, _inputMode;
  if (inputMode != null) _inputMode = inputMode, inputMode === "email" ? type = "email" : inputMode === "tel" ? type = "tel" : inputMode === "search" ? type = "search" : inputMode === "url" ? type = "url" : type = "text";
  else if (keyboardType != null) switch (warn("keyboardType", "keyboardType is deprecated. Use inputMode."), keyboardType) {
    case "email-address":
      type = "email";
      break;
    case "number-pad":
    case "numeric":
      _inputMode = "numeric";
      break;
    case "decimal-pad":
      _inputMode = "decimal";
      break;
    case "phone-pad":
      type = "tel";
      break;
    case "search":
    case "web-search":
      type = "search";
      break;
    case "url":
      type = "url";
      break;
    default:
      type = "text";
  }
  secureTextEntry && (type = "password");
  const dimensions2 = React__namespace.useRef({
    height: null,
    width: null
  }), hostRef = React__namespace.useRef(null), handleContentSizeChange = React__namespace.useCallback((hostNode) => {
    if (multiline && onContentSizeChange && hostNode != null) {
      const newHeight = hostNode.scrollHeight, newWidth = hostNode.scrollWidth;
      (newHeight !== dimensions2.current.height || newWidth !== dimensions2.current.width) && (dimensions2.current.height = newHeight, dimensions2.current.width = newWidth, onContentSizeChange({
        nativeEvent: {
          contentSize: {
            height: dimensions2.current.height,
            width: dimensions2.current.width
          }
        }
      }));
    }
  }, [multiline, onContentSizeChange]), imperativeRef = React__namespace.useMemo(() => (hostNode) => {
    hostNode != null && (hostNode.clear = () => {
      hostNode != null && (hostNode.value = "");
    }, hostNode.isFocused = () => hostNode != null && TextInputState.currentlyFocusedField() === hostNode, handleContentSizeChange(hostNode));
  }, [handleContentSizeChange]);
  function handleBlur(e2) {
    TextInputState._currentlyFocusedNode = null, onBlur && (e2.nativeEvent.text = e2.target.value, onBlur(e2));
  }
  function handleChange(e2) {
    const hostNode = e2.target, text = hostNode.value;
    e2.nativeEvent.text = text, handleContentSizeChange(hostNode), onChange && onChange(e2), onChangeText && onChangeText(text);
  }
  function handleFocus(e2) {
    const hostNode = e2.target;
    onFocus && (e2.nativeEvent.text = hostNode.value, onFocus(e2)), hostNode != null && (TextInputState._currentlyFocusedNode = hostNode, clearTextOnFocus && (hostNode.value = ""), selectTextOnFocus && (focusTimeout != null && clearTimeout(focusTimeout), focusTimeout = setTimeout(() => {
      hostNode == null ? void 0 : hostNode.select();
    }, 0)));
  }
  function handleKeyDown(e2) {
    const hostNode = e2.target;
    e2.stopPropagation();
    const shouldBlurOnSubmit = blurOnSubmit != null ? blurOnSubmit : !multiline, nativeEvent = e2.nativeEvent, isComposing = isEventComposing(nativeEvent);
    onKeyPress && onKeyPress(e2), e2.key === "Enter" && !e2.shiftKey && // Do not call submit if composition is occuring.
    !isComposing && !e2.isDefaultPrevented() && ((blurOnSubmit || !multiline) && onSubmitEditing && (e2.preventDefault(), nativeEvent.text = e2.target.value, onSubmitEditing(e2)), shouldBlurOnSubmit && hostNode != null && setTimeout(() => hostNode.blur(), 0));
  }
  function handleSelectionChange(e2) {
    if (onSelectionChange) try {
      const node = e2.target, {
        selectionStart,
        selectionEnd
      } = node;
      e2.nativeEvent.selection = {
        start: selectionStart,
        end: selectionEnd
      }, e2.nativeEvent.text = e2.target.value, onSelectionChange(e2);
    } catch (e3) {
    }
  }
  useIsomorphicLayoutEffect$1(() => {
    const node = hostRef.current;
    node != null && selection != null && setSelection(node, selection), document.activeElement === node && (TextInputState._currentlyFocusedNode = node);
  }, [hostRef, selection]);
  const component = multiline ? "textarea" : "input";
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  const {
    direction: contextDirection
  } = useLocaleContext(), supportedProps = pickProps(props);
  supportedProps.autoCapitalize = autoCapitalize, supportedProps.autoComplete = autoComplete || autoCompleteType || "on", supportedProps.autoCorrect = autoCorrect ? "on" : "off", supportedProps.dir = dir !== void 0 ? dir : "auto", returnKeyType != null && warn("returnKeyType", "returnKeyType is deprecated. Use enterKeyHint."), supportedProps.enterKeyHint = enterKeyHint || returnKeyType, supportedProps.inputMode = _inputMode, supportedProps.onBlur = handleBlur, supportedProps.onChange = handleChange, supportedProps.onFocus = handleFocus, supportedProps.onKeyDown = handleKeyDown, supportedProps.onSelect = handleSelectionChange, editable != null && warn("editable", "editable is deprecated. Use readOnly."), supportedProps.readOnly = readOnly === true || editable === false, numberOfLines != null && warn("numberOfLines", "TextInput numberOfLines is deprecated. Use rows."), supportedProps.rows = multiline ? rows != null ? rows : numberOfLines : 1, supportedProps.spellCheck = spellCheck != null ? spellCheck : autoCorrect, supportedProps.style = [{
    "--placeholderTextColor": placeholderTextColor
  }, styles.textinput$raw, styles.placeholder, props.style, caretHidden && styles.caretHidden], supportedProps.type = multiline ? void 0 : type, supportedProps.virtualkeyboardpolicy = showSoftInputOnFocus === false ? "manual" : "auto";
  const platformMethodsRef = usePlatformMethods(supportedProps), setRef2 = useMergeRefs$1(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
  supportedProps.ref = setRef2;
  const langDirection = props.lang != null ? getLocaleDirection(props.lang) : null;
  props.dir || langDirection || contextDirection;
  return useCreateElement$1(component, supportedProps);
});
function warn(...args) {
  console.warn(...args);
}
TextInput.displayName = "TextInput";
TextInput.State = TextInputState;
const styles = StyleSheet.create({
  textinput$raw: {
    MozAppearance: "textfield",
    WebkitAppearance: "none",
    appearance: "none"
  },
  placeholder: {
    placeholderTextColor: "var(--placeholderTextColor)"
  },
  caretHidden: {
    caretColor: "transparent"
  }
});
function useWindowDimensions$1() {
  const [dims, setDims] = React.useState(() => Dimensions2.get("window"));
  return React.useEffect(() => {
    function handleChange({
      window: window2
    }) {
      window2 != null && setDims(window2);
    }
    return Dimensions2.addEventListener("change", handleChange), setDims(Dimensions2.get("window")), () => {
      Dimensions2.removeEventListener("change", handleChange);
    };
  }, []), dims;
}
const RootTagContext = React.createContext(null);
var IS_REACT_19 = typeof React.use < "u", isWeb = false, isServer = false, isClient = false, useIsomorphicLayoutEffect = React.useLayoutEffect, isChrome = false, isWebTouchable = false, isTouchable = true, isAndroid = process.env.TEST_NATIVE_PLATFORM === "android", isIos = process.env.TEST_NATIVE_PLATFORM === "ios", platforms = {
  ios: "ios",
  android: "android"
}, currentPlatform = platforms[Platform.OS] || "native";
var isServerSide = false;
function useForceUpdate() {
  return React.useReducer(function(x) {
    return Math.random();
  }, 0)[1];
}
var LayoutGroupContext = /* @__PURE__ */ React.createContext({});
function useConstant(fn) {
  if (typeof document > "u") return React__namespace.useMemo(function() {
    return fn();
  }, []);
  var ref = React__namespace.useRef(void 0);
  return ref.current || (ref.current = {
    v: fn()
  }), ref.current.v;
}
var PresenceContext = /* @__PURE__ */ React__namespace.createContext(null), ResetPresence = function(props) {
  var parent = React__namespace.useContext(PresenceContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceContext.Provider, {
    value: props.disable ? parent : null,
    children: props.children
  });
};
function usePresence() {
  var context2 = React__namespace.useContext(PresenceContext);
  if (!context2) return [true, null, context2];
  var {
    id: id2,
    isPresent: isPresent2,
    onExitComplete,
    register
  } = context2;
  React__namespace.useEffect(function() {
    return register(id2);
  }, []);
  var safeToRemove = function() {
    return onExitComplete == null ? void 0 : onExitComplete(id2);
  };
  return !isPresent2 && onExitComplete ? [false, safeToRemove, context2] : [true, void 0, context2];
}
function useIsPresent() {
  return isPresent(React__namespace.useContext(PresenceContext));
}
function isPresent(context2) {
  return context2 === null ? true : context2.isPresent;
}
var PresenceChild = /* @__PURE__ */ React__namespace.memo(function(param) {
  var {
    children,
    initial,
    isPresent: isPresent2,
    onExitComplete,
    exitVariant,
    enterVariant,
    enterExitVariant,
    presenceAffectsLayout,
    custom
  } = param, presenceChildren = useConstant(newChildrenMap), id2 = React.useId() || "", context2 = React__namespace.useMemo(
    function() {
      return {
        id: id2,
        initial,
        isPresent: isPresent2,
        custom,
        exitVariant,
        enterVariant,
        enterExitVariant,
        onExitComplete: function() {
          presenceChildren.set(id2, true);
          var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
          try {
            for (var _iterator = presenceChildren.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var isComplete = _step.value;
              if (!isComplete) return;
            }
          } catch (err) {
            _didIteratorError = true, _iteratorError = err;
          } finally {
            try {
              !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
            } finally {
              if (_didIteratorError) throw _iteratorError;
            }
          }
          onExitComplete == null ? void 0 : onExitComplete();
        },
        register: function() {
          return presenceChildren.set(id2, false), function() {
            return presenceChildren.delete(id2);
          };
        }
      };
    },
    /**
    * If the presence of a child affects the layout of the components around it,
    * we want to make a new context value to ensure they get re-rendered
    * so they can detect that layout change.
    */
    // @ts-expect-error its ok
    presenceAffectsLayout ? void 0 : [isPresent2, exitVariant, enterVariant]
  );
  return React__namespace.useMemo(function() {
    presenceChildren.forEach(function(_, key) {
      return presenceChildren.set(key, false);
    });
  }, [isPresent2]), React__namespace.useEffect(function() {
    !isPresent2 && !presenceChildren.size && (onExitComplete == null ? void 0 : onExitComplete());
  }, [isPresent2]), /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceContext.Provider, {
    value: context2,
    children
  });
});
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
var getChildKey = function(child) {
  return child.key || "";
};
function updateChildLookup(children, allChildren) {
  children.forEach(function(child) {
    var key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  return React.Children.forEach(children, function(child) {
    /* @__PURE__ */ React.isValidElement(child) && filtered.push(child);
  }), filtered;
}
var AnimatePresence = function(param) {
  var {
    children,
    enterVariant,
    exitVariant,
    enterExitVariant,
    initial = true,
    onExitComplete,
    exitBeforeEnter,
    presenceAffectsLayout = true,
    custom,
    passThrough
  } = param, _useContext_forceRender, forceRender = (_useContext_forceRender = React.useContext(LayoutGroupContext).forceRender) !== null && _useContext_forceRender !== void 0 ? _useContext_forceRender : useForceUpdate(), filteredChildren = onlyElements(children), presentChildren = React.useRef(filteredChildren), allChildren = React.useRef(/* @__PURE__ */ new Map()).current, exiting = React.useRef(/* @__PURE__ */ new Set()).current;
  updateChildLookup(filteredChildren, allChildren);
  var isInitialRender = React.useRef(true);
  if (passThrough) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
  if (useIsomorphicLayoutEffect(function() {
    isInitialRender.current = false;
  }, []), isInitialRender.current) return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: filteredChildren.map(function(child) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, {
        isPresent: true,
        enterExitVariant,
        exitVariant,
        enterVariant,
        initial: initial ? void 0 : false,
        presenceAffectsLayout,
        custom,
        children: child
      }, getChildKey(child));
    })
  });
  for (var childrenToRender = [...filteredChildren], presentKeys = presentChildren.current.map(getChildKey), targetKeys = filteredChildren.map(getChildKey), numPresent = presentKeys.length, i = 0; i < numPresent; i++) {
    var key = presentKeys[i];
    targetKeys.indexOf(key) === -1 ? exiting.add(key) : exiting.delete(key);
  }
  return exitBeforeEnter && exiting.size && (childrenToRender = []), exiting.forEach(function(key2) {
    if (targetKeys.indexOf(key2) === -1) {
      var child = allChildren.get(key2);
      if (child) {
        var insertionIndex = presentKeys.indexOf(key2), onExit = function() {
          allChildren.delete(key2), exiting.delete(key2);
          var removeIndex = presentChildren.current.findIndex(function(presentChild) {
            return presentChild.key === key2;
          });
          presentChildren.current.splice(removeIndex, 1), exiting.size || (presentChildren.current = filteredChildren, forceRender(), onExitComplete == null ? void 0 : onExitComplete());
        }, exitingComponent = /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, {
          isPresent: false,
          onExitComplete: onExit,
          presenceAffectsLayout,
          enterExitVariant,
          enterVariant,
          exitVariant,
          custom,
          children: child
        }, getChildKey(child));
        childrenToRender.splice(insertionIndex, 0, exitingComponent);
      }
    }
  }), childrenToRender = childrenToRender.map(function(child) {
    var key2 = child.key;
    return exiting.has(key2) ? child : /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, {
      isPresent: true,
      exitVariant,
      enterVariant,
      enterExitVariant,
      presenceAffectsLayout,
      custom,
      children: child
    }, getChildKey(child));
  }), presentChildren.current = childrenToRender, /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: exiting.size ? childrenToRender : (
      // biome-ignore lint/correctness/useJsxKeyInIterable: <explanation>
      childrenToRender.map(function(child) {
        return /* @__PURE__ */ React.cloneElement(child);
      })
    )
  });
};
AnimatePresence.displayName = "AnimatePresence";
var startTransition = function(callback) {
  callback();
};
var emptyCallbackFn = function(_) {
  return _();
};
function useControllableState(param) {
  var {
    prop,
    defaultProp,
    onChange,
    strategy = "prop-wins",
    preventUpdate,
    transition
  } = param, [state, setState] = React__namespace.useState(prop != null ? prop : defaultProp), previous = React__namespace.useRef(state), propWins = strategy === "prop-wins" && prop !== void 0, value = propWins ? prop : state, onChangeCb = useEvent$1(onChange || idFn), transitionFn = transition ? startTransition : emptyCallbackFn;
  React__namespace.useEffect(function() {
    prop !== void 0 && (previous.current = prop, transitionFn(function() {
      setState(prop);
    }));
  }, [prop]), React__namespace.useEffect(function() {
    propWins || state !== previous.current && (previous.current = state, onChangeCb(state));
  }, [onChangeCb, state, propWins]);
  var setter = useEvent$1(function(next) {
    if (!preventUpdate) if (propWins) {
      var nextValue = typeof next == "function" ? next(previous.current) : next;
      onChangeCb(nextValue);
    } else transitionFn(function() {
      setState(next);
    });
  });
  return [value, setter];
}
var idFn = function() {
};
var COLLAPSIBLE_NAME = "Collapsible", {
  Provider: CollapsibleProvider,
  useStyledContext: useCollapsibleContext
} = createStyledContext(), _Collapsible = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeCollapsible,
    open: openProp,
    defaultOpen,
    disabled,
    onOpenChange
  } = _a, collapsibleProps = __objRest(_a, [
    "__scopeCollapsible",
    "open",
    "defaultOpen",
    "disabled",
    "onOpenChange"
  ]), [open2 = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleProvider, {
    scope: __scopeCollapsible,
    disabled,
    contentId: React__namespace.useId(),
    open: open2,
    onOpenToggle: React__namespace.useCallback(function() {
      return setOpen(function(prevOpen) {
        return !prevOpen;
      });
    }, [setOpen]),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Stack$1, __spreadProps(__spreadValues({
      "data-state": getState$4(open2),
      "data-disabled": disabled ? "" : void 0
    }, collapsibleProps), {
      ref: forwardedRef
    }))
  });
});
_Collapsible.displayName = COLLAPSIBLE_NAME;
var TRIGGER_NAME$4 = "CollapsibleTrigger", CollapsibleTriggerFrame = styled(Stack$1, {
  name: TRIGGER_NAME$4,
  tag: "button"
}), CollapsibleTrigger = CollapsibleTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeCollapsible,
    children
  } = _a, triggerProps = __objRest(_a, [
    "__scopeCollapsible",
    "children"
  ]), context2 = useCollapsibleContext(__scopeCollapsible);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleTriggerFrame, __spreadProps(__spreadValues({
    "aria-controls": context2.contentId,
    "aria-expanded": context2.open || false,
    "data-state": getState$4(context2.open),
    "data-disabled": context2.disabled ? "" : void 0,
    disabled: context2.disabled
  }, triggerProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers(props.onPress, context2.onOpenToggle),
    children: typeof children == "function" ? children({
      open: context2.open
    }) : children
  }));
});
CollapsibleTrigger.displayName = TRIGGER_NAME$4;
var CONTENT_NAME$3 = "CollapsibleContent", CollapsibleContentFrame = styled(Stack$1, {
  name: CONTENT_NAME$3
}), CollapsibleContent = CollapsibleContentFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    forceMount,
    children,
    __scopeCollapsible: __scopeCollapsible
  } = _a, contentProps = __objRest(_a, [
    "forceMount",
    "children",
    // @ts-expect-error
    "__scopeCollapsible"
  ]), context2 = useCollapsibleContext(__scopeCollapsible);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, __spreadProps(__spreadValues({}, contentProps), {
    children: forceMount || context2.open ? /* @__PURE__ */ jsxRuntimeExports.jsx(CollapsibleContentFrame, __spreadProps(__spreadValues({
      ref: forwardedRef
    }, contentProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence, {
        children
      })
    })) : null
  }));
});
CollapsibleContent.displayName = CONTENT_NAME$3;
function getState$4(open2) {
  return open2 ? "open" : "closed";
}
var Collapsible = withStaticProperties(_Collapsible, {
  Trigger: CollapsibleTrigger,
  Content: CollapsibleContent
});
var RE_MEDIA_QUERY = /(?:(only|not)?\s*([^\s\(\)]+)(?:\s*and)?\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\(\s*([^\s\:\)]+)\s*(?:\:\s*([^\s\)]+))?\s*\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;
function matchQuery(mediaQuery, values) {
  return parseQuery(mediaQuery).some(function(query2) {
    if (query2) {
      var inverse = query2.inverse, typeMatch = query2.type === "all" || values.type === query2.type;
      if (typeMatch && inverse || !(typeMatch || inverse)) return false;
      var expressionsMatch = query2.expressions.every(function(expression) {
        var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];
        if (!value) return false;
        switch (feature) {
          case "orientation":
          case "scan":
            return value.toLowerCase() === expValue.toLowerCase();
          case "width":
          case "height":
          case "device-width":
          case "device-height":
            expValue = toPx(expValue), value = toPx(value);
            break;
          case "resolution":
            expValue = toDpi(expValue), value = toDpi(value);
            break;
          case "aspect-ratio":
          case "device-aspect-ratio":
          case /* Deprecated */
          "device-pixel-ratio":
            expValue = toDecimal(expValue), value = toDecimal(value);
            break;
          case "grid":
          case "color":
          case "color-index":
          case "monochrome":
            expValue = Number.parseInt(expValue, 10) || 1, value = Number.parseInt(value, 10) || 0;
            break;
        }
        switch (modifier) {
          case "min":
            return value >= expValue;
          case "max":
            return value <= expValue;
          default:
            return value === expValue;
        }
      });
      return expressionsMatch && !inverse || !expressionsMatch && inverse;
    }
  });
}
function parseQuery(mediaQuery) {
  return mediaQuery.split(",").map(function(query2) {
    query2 = query2.trim();
    var captures = query2.match(RE_MEDIA_QUERY);
    if (!captures) return null;
    var modifier = captures[1], type = captures[2], expressionsCapture = captures[3] || "", expressions = expressionsCapture.match(/\([^\)]+\)/g) || [];
    return {
      inverse: !!modifier && modifier.toLowerCase() === "not",
      type: type ? type.toLowerCase() : "all",
      expressions: expressions.map(function(expression) {
        var captures2 = expression.match(RE_MQ_EXPRESSION), feature = captures2[1].toLowerCase().match(RE_MQ_FEATURE);
        return {
          modifier: feature[1],
          feature: feature[2],
          value: captures2[2]
        };
      })
    };
  });
}
function toDecimal(ratio) {
  var decimal = Number(ratio), numbers;
  return decimal || (numbers = ratio.match(/^(\d+)\s*\/\s*(\d+)$/), decimal = numbers[1] / numbers[2]), decimal;
}
function toDpi(resolution) {
  var _String_match, value = Number.parseFloat(resolution), units = (_String_match = String(resolution).match(RE_RESOLUTION_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "dpcm":
      return value / 2.54;
    case "dppx":
      return value * 96;
    default:
      return value;
  }
}
function toPx(length) {
  var _String_match, value = Number.parseFloat(length), units = (_String_match = String(length).match(RE_LENGTH_UNIT)) === null || _String_match === void 0 ? void 0 : _String_match[1];
  switch (units) {
    case "em":
      return value * 16;
    case "rem":
      return value * 16;
    case "cm":
      return value * 96 / 2.54;
    case "mm":
      return value * 96 / 2.54 / 10;
    case "in":
      return value * 96;
    case "pt":
      return value * 72;
    case "pc":
      return value * 72 / 12;
    default:
      return value;
  }
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), Constructor;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: true,
    configurable: true,
    writable: true
  }) : obj[key] = value, obj;
}
var NativeMediaQueryList = /* @__PURE__ */ (function() {
  function NativeMediaQueryList2(query2) {
    var _this = this;
    _class_call_check(this, NativeMediaQueryList2), _define_property(this, "query", void 0), _define_property(this, "listeners", void 0), this.query = query2, this.listeners = [], this.notify(), Dimensions2.addEventListener("change", function() {
      _this.notify();
    });
  }
  return _create_class(NativeMediaQueryList2, [{
    key: "orientation",
    get: function() {
      var windowDimensions = Dimensions2.get("window");
      return windowDimensions.height > windowDimensions.width ? "portrait" : "landscape";
    }
  }, {
    key: "notify",
    value: function() {
      var _this = this;
      this.listeners.forEach(function(listener) {
        listener(_this.orientation);
      });
    }
  }, {
    key: "addListener",
    value: function(listener) {
      this.listeners.push(listener);
    }
  }, {
    key: "removeListener",
    value: function(listener) {
      var index2 = this.listeners.indexOf(listener);
      index2 !== -1 && this.listeners.splice(index2, 1);
    }
  }, {
    key: "match",
    value: function(query2, param) {
      var {
        width,
        height
      } = param;
      return matchQuery(query2, {
        type: "screen",
        orientation: height > width ? "portrait" : "landscape",
        "device-width": width,
        "device-height": height
      });
    }
  }, {
    key: "matches",
    get: function() {
      var windowDimensions = Dimensions2.get("window"), matches = matchQuery(this.query, __spreadProps(__spreadValues({
        type: "screen",
        orientation: this.orientation
      }, windowDimensions), {
        "device-width": windowDimensions.width,
        "device-height": windowDimensions.height
      }));
      return matches;
    }
  }]), NativeMediaQueryList2;
})();
var matchMedia = function(query2) {
  return new NativeMediaQueryList(query2);
};
function createMedia(media) {
  return setupMatchMedia(matchMedia), media;
}
function getBaseViews() {
  var _native_default, _native_default1, _native_default2, _native_default3, native = require("react-native");
  return {
    View: native.View || ((_native_default = native.default) === null || _native_default === void 0 ? void 0 : _native_default.View),
    Text: native.Text || ((_native_default1 = native.default) === null || _native_default1 === void 0 ? void 0 : _native_default1.Text),
    TextAncestor: native.unstable_TextAncestorContext,
    StyleSheet: native.StyleSheet || ((_native_default2 = native.default) === null || _native_default2 === void 0 ? void 0 : _native_default2.StyleSheet),
    Pressable: native.Pressable || ((_native_default3 = native.default) === null || _native_default3 === void 0 ? void 0 : _native_default3.Pressable)
  };
}
require("react-native/Libraries/Pressability/Pressability").default;
var usePressability = require("react-native/Libraries/Pressability/usePressability").default;
var TamaguiProvider$1 = function(props) {
  return useIsomorphicLayoutEffect(function() {
    enable();
  }, []), /* @__PURE__ */ jsxRuntimeExports.jsx(TamaguiProvider$2, __spreadValues({}, props));
}, createTamagui$1 = function(conf2) {
  return conf2.media && (conf2.media = createMedia(conf2.media)), createTamagui$2(conf2);
};
getBaseViews();
setupHooks({
  getBaseViews,
  setElementProps: function(node) {
  },
  usePropsTransform(elementType, propsIn, stateRef, willHydrate) {
  },
  useEvents(viewProps, events, splitStyles, setStateShallow, staticConfig) {
    if (events && (events.onFocus && (viewProps.onFocus = events.onFocus), events.onBlur && (viewProps.onBlur = events.onBlur)), staticConfig.isInput) {
      if (events) {
        var {
          onPressIn,
          onPressOut,
          onPress
        } = events, inputEvents = {
          onPressIn,
          onPressOut: onPressOut || onPress
        };
        onPressOut && onPress && (inputEvents.onPressOut = composeEventHandlers(onPress, onPressOut)), Object.assign(viewProps, inputEvents);
      }
    } else {
      events && viewProps.hitSlop && (events.hitSlop = viewProps.hitSlop);
      var pressability = usePressability(events);
      if (events && events.onPress) for (var key in pressability) {
        var og = viewProps[key], val = pressability[key];
        viewProps[key] = og && !dontComposePressabilityKeys[key] ? composeEventHandlers(og, val) : val;
      }
    }
  },
  useChildren(elementType, children, viewProps) {
  }
});
var dontComposePressabilityKeys = {
  onClick: true
}, View = View$3, Stack = Stack$1, Text$1 = Text$4;
function createCollection(name) {
  var {
    Provider: CollectionProviderImpl,
    useStyledContext: useCollectionContext
  } = createStyledContext({
    collectionRef: {
      current: void 0
    },
    itemMap: /* @__PURE__ */ new Map()
  }, "Toast"), CollectionProvider = function(props) {
    var {
      scope,
      children
    } = props, ref = React.useRef(void 0), itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref,
      children
    });
  };
  CollectionProvider.displayName = "CollectionProvider";
  var COLLECTION_SLOT_NAME = name + "CollectionSlot", CollectionSlot = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
    var {
      scope,
      children
    } = props, context2 = useCollectionContext(scope), composedRefs = useComposedRefs(forwardedRef, context2.collectionRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, {
      ref: composedRefs,
      children
    });
  });
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  var ITEM_SLOT_NAME = name + "CollectionItemSlot", ITEM_DATA_ATTR = "data-collection-item", CollectionItemSlot = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
    var _a = props, {
      scope,
      children
    } = _a, itemData = __objRest(_a, [
      "scope",
      "children"
    ]), ref = React.useRef(void 0), composedRefs = useComposedRefs(forwardedRef, ref), context2 = useCollectionContext(scope);
    return React.useEffect(function() {
      return context2.itemMap.set(ref, __spreadValues({
        ref
      }, itemData)), function() {
        return void context2.itemMap.delete(ref);
      };
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs,
      children
    });
  });
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    var context2 = useCollectionContext(scope), getItems = React.useCallback(function() {
      return [];
    }, [context2.collectionRef, context2.itemMap]);
    return getItems;
  }
  return [{
    Provider: CollectionProvider,
    Slot: CollectionSlot,
    ItemSlot: CollectionItemSlot
  }, useCollection2];
}
var getElevation = function(size, extras) {
  if (size) {
    var {
      tokens
    } = extras, token = tokens.size[size], sizeNum = isVariable(token) ? +token.val : size;
    return getSizedElevation(sizeNum, extras);
  }
}, getSizedElevation = function(val, param) {
  var {
    theme,
    tokens
  } = param, num = 0;
  if (val === true) {
    var _$val = getVariableValue(tokens.size.true);
    typeof _$val == "number" ? num = _$val : num = 10;
  } else num = +val;
  if (num !== 0) {
    var [height, shadowRadius] = [Math.round(num / 4 + 1), Math.round(num / 2 + 2)], shadow = __spreadValues({
      shadowColor: theme.shadowColor,
      shadowRadius,
      shadowOffset: {
        height,
        width: 0
      }
    }, isAndroid ? {
      elevationAndroid: 2 * height
    } : {});
    return shadow;
  }
};
function _type_of$3(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var fullscreenStyle = {
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
}, getInset = function(val) {
  return val && (typeof val > "u" ? "undefined" : _type_of$3(val)) === "object" ? val : {
    top: val,
    left: val,
    bottom: val,
    right: val
  };
}, variants = {
  fullscreen: {
    true: fullscreenStyle
  },
  elevation: {
    "...size": getElevation,
    ":number": getElevation
  },
  inset: getInset
}, YStack = styled(View, {
  flexDirection: "column",
  variants
});
YStack.displayName = "YStack";
var XStack = styled(View, {
  flexDirection: "row",
  variants
});
XStack.displayName = "XStack";
var ZStack = styled(YStack, {
  position: "relative"
}, {
  neverFlatten: true,
  isZStack: true
});
ZStack.displayName = "ZStack";
var defaultOptions = {
  shift: 0,
  bounds: [0]
}, getSize = function(size, options) {
  return getTokenRelative("size", size, options);
}, getSpace = function(space, options) {
  return getTokenRelative("space", space, options);
}, cacheVariables = {}, cacheWholeVariables = {}, cacheKeys = {}, cacheWholeKeys = {}, stepTokenUpOrDown = function(type, current) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOptions, _options_bounds, _options_bounds1, tokens = getTokens({
    prefixed: true
  })[type];
  if (!(type in cacheVariables)) {
    cacheKeys[type] = [], cacheVariables[type] = [], cacheWholeKeys[type] = [], cacheWholeVariables[type] = [];
    var sorted = Object.keys(tokens).map(function(k) {
      return tokens[k];
    }).sort(function(a, b2) {
      return a.val - b2.val;
    }), _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = sorted[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var token = _step.value;
        cacheKeys[type].push(token.key), cacheVariables[type].push(token);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError) throw _iteratorError;
      }
    }
    var sortedExcludingHalfSteps = sorted.filter(function(x) {
      return !x.key.endsWith(".5");
    }), _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = void 0;
    try {
      for (var _iterator1 = sortedExcludingHalfSteps[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true) {
        var token1 = _step1.value;
        cacheWholeKeys[type].push(token1.key), cacheWholeVariables[type].push(token1);
      }
    } catch (err) {
      _didIteratorError1 = true, _iteratorError1 = err;
    } finally {
      try {
        !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
      } finally {
        if (_didIteratorError1) throw _iteratorError1;
      }
    }
  }
  var isString = typeof current == "string", cache2 = options.excludeHalfSteps ? isString ? cacheWholeKeys : cacheWholeVariables : isString ? cacheKeys : cacheVariables, tokensOrdered = cache2[type], _options_bounds_, min2 = (_options_bounds_ = (_options_bounds = options.bounds) === null || _options_bounds === void 0 ? void 0 : _options_bounds[0]) !== null && _options_bounds_ !== void 0 ? _options_bounds_ : 0, _options_bounds_1, max2 = (_options_bounds_1 = (_options_bounds1 = options.bounds) === null || _options_bounds1 === void 0 ? void 0 : _options_bounds1[1]) !== null && _options_bounds_1 !== void 0 ? _options_bounds_1 : tokensOrdered.length - 1, currentIndex = tokensOrdered.indexOf(current), shift2 = options.shift || 0;
  shift2 && (current === "$true" || isVariable(current) && current.name === "true") && (shift2 += shift2 > 0 ? 1 : -1);
  var index2 = Math.min(max2, Math.max(min2, currentIndex + shift2)), found = tokensOrdered[index2], result = (typeof found == "string" ? tokens[found] : found) || tokens.$true;
  return result;
}, getTokenRelative = stepTokenUpOrDown;
var getButtonSized = function(val, param) {
  var {
    tokens,
    props
  } = param;
  if (!(!val || props.circular)) {
    if (typeof val == "number") return {
      paddingHorizontal: val * 0.25,
      height: val,
      borderRadius: props.circular ? 1e5 : val * 0.2
    };
    var xSize = getSpace(val), _tokens_radius_val, radiusToken = (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : tokens.radius.$true;
    return {
      paddingHorizontal: xSize,
      height: val,
      borderRadius: props.circular ? 1e5 : radiusToken
    };
  }
};
var elevate = {
  true: function(_, extras) {
    return getElevation(extras.props.size, extras);
  }
}, bordered = function(val, param) {
  var {
    props
  } = param;
  return __spreadValues(__spreadValues(__spreadValues({
    // TODO size it with size in '...size'
    borderWidth: typeof val == "number" ? val : 1,
    borderColor: "$borderColor"
  }, props.hoverTheme && {
    hoverStyle: {
      borderColor: "$borderColorHover"
    }
  }), props.pressTheme && {
    pressStyle: {
      borderColor: "$borderColorPress"
    }
  }), props.focusTheme && {
    focusStyle: {
      borderColor: "$borderColorFocus"
    }
  });
}, padded = {
  true: function(_, extras) {
    var {
      tokens,
      props
    } = extras;
    return {
      padding: tokens.space[props.size] || tokens.space.$true
    };
  }
}, radiused = {
  true: function(_, extras) {
    var {
      tokens,
      props
    } = extras;
    return {
      borderRadius: tokens.radius[props.size] || tokens.radius.$true
    };
  }
}, circularStyle = {
  borderRadius: 1e5,
  padding: 0
}, circular = {
  true: function(_, param) {
    var {
      props,
      tokens
    } = param;
    if (!("size" in props)) return circularStyle;
    var size = typeof props.size == "number" ? props.size : tokens.size[props.size];
    return __spreadProps(__spreadValues({}, circularStyle), {
      width: size,
      height: size,
      maxWidth: size,
      maxHeight: size,
      minWidth: size,
      minHeight: size
    });
  }
}, hoverTheme = {
  true: {
    hoverStyle: {
      backgroundColor: "$backgroundHover",
      borderColor: "$borderColorHover"
    }
  },
  false: {}
}, pressTheme = {
  true: {
    cursor: "pointer",
    pressStyle: {
      backgroundColor: "$backgroundPress",
      borderColor: "$borderColorPress"
    }
  },
  false: {}
}, focusTheme = {
  true: {
    focusStyle: {
      backgroundColor: "$backgroundFocus",
      borderColor: "$borderColorFocus"
    }
  },
  false: {}
};
var SizableStack = styled(XStack, {
  name: "SizableStack",
  variants: {
    unstyled: {
      true: {
        hoverTheme: false,
        pressTheme: false,
        focusTheme: false,
        elevate: false,
        bordered: false
      }
    },
    hoverTheme,
    pressTheme,
    focusTheme,
    circular,
    elevate,
    bordered,
    size: {
      "...size": function(val, extras) {
        return getButtonSized(val, extras);
      }
    }
  }
});
var chromelessStyle = {
  backgroundColor: "transparent",
  borderColor: "transparent",
  shadowColor: "transparent",
  hoverStyle: {
    borderColor: "transparent"
  }
}, themeableVariants = {
  backgrounded: {
    true: {
      backgroundColor: "$background"
    }
  },
  radiused,
  hoverTheme,
  pressTheme,
  focusTheme,
  circular,
  padded,
  elevate,
  bordered,
  transparent: {
    true: {
      backgroundColor: "transparent"
    }
  },
  chromeless: {
    true: chromelessStyle,
    all: __spreadProps(__spreadValues({}, chromelessStyle), {
      hoverStyle: chromelessStyle,
      pressStyle: chromelessStyle,
      focusStyle: chromelessStyle
    })
  }
}, ThemeableStack = styled(YStack, {
  variants: themeableVariants
});
var ButtonNestingContext = /* @__PURE__ */ React.createContext(false);
function _type_of$2(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var getFontSized = function() {
  var sizeTokenIn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "$true", {
    font,
    fontFamily,
    props
  } = arguments.length > 1 ? arguments[1] : void 0, _font_lineHeight, _font_weight, _font_letterSpacing, _font_transform, _font_style, _font_color;
  if (!font) return {
    fontSize: sizeTokenIn
  };
  var sizeToken = sizeTokenIn === "$true" ? getDefaultSizeToken(font) : sizeTokenIn, style = {}, fontSize = font.size[sizeToken], lineHeight = (_font_lineHeight = font.lineHeight) === null || _font_lineHeight === void 0 ? void 0 : _font_lineHeight[sizeToken], fontWeight = (_font_weight = font.weight) === null || _font_weight === void 0 ? void 0 : _font_weight[sizeToken], letterSpacing = (_font_letterSpacing = font.letterSpacing) === null || _font_letterSpacing === void 0 ? void 0 : _font_letterSpacing[sizeToken], textTransform = (_font_transform = font.transform) === null || _font_transform === void 0 ? void 0 : _font_transform[sizeToken], _props_fontStyle, fontStyle = (_props_fontStyle = props.fontStyle) !== null && _props_fontStyle !== void 0 ? _props_fontStyle : (_font_style = font.style) === null || _font_style === void 0 ? void 0 : _font_style[sizeToken], _props_color, color = (_props_color = props.color) !== null && _props_color !== void 0 ? _props_color : (_font_color = font.color) === null || _font_color === void 0 ? void 0 : _font_color[sizeToken];
  return fontStyle && (style.fontStyle = fontStyle), textTransform && (style.textTransform = textTransform), fontFamily && (style.fontFamily = fontFamily), fontWeight && (style.fontWeight = fontWeight), letterSpacing && (style.letterSpacing = letterSpacing), fontSize && (style.fontSize = fontSize), lineHeight && (style.lineHeight = lineHeight), color && (style.color = color), style;
};
styled(Text$4, {
  name: "SizableText",
  fontFamily: "$body",
  variants: {
    size: {
      "...fontSize": getFontSized
    }
  },
  defaultVariants: {
    size: "$true"
  }
});
var cache = /* @__PURE__ */ new WeakMap();
function getDefaultSizeToken(font) {
  if ((typeof font > "u" ? "undefined" : _type_of$2(font)) === "object" && cache.has(font)) return cache.get(font);
  var sizeTokens = "$true" in font.size ? font.size : getTokens().size, sizeDefault = sizeTokens.$true, sizeDefaultSpecific = sizeDefault ? Object.keys(sizeTokens).find(function(x) {
    return x !== "$true" && sizeTokens[x].val === sizeDefault.val;
  }) : null;
  return !sizeDefault || !sizeDefaultSpecific ? Object.keys(font.size)[3] : (cache.set(font, sizeDefaultSpecific), sizeDefaultSpecific);
}
var SizableText = styled(Text$4, {
  name: "SizableText",
  fontFamily: "$body",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        color: "$color"
      }
    },
    size: getFontSized
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
SizableText.staticConfig.variants.fontFamily = {
  "...": function(val, extras) {
    if (val === "inherit") return {
      fontFamily: "inherit"
    };
    var sizeProp = extras.props.size, fontSizeProp = extras.props.fontSize, size = sizeProp === "$true" && fontSizeProp ? fontSizeProp : extras.props.size || "$true";
    return getFontSized(size, extras);
  }
};
var Paragraph = styled(SizableText, {
  name: "Paragraph",
  tag: "p",
  userSelect: "auto",
  color: "$color",
  size: "$true",
  whiteSpace: "normal"
});
var Heading = styled(Paragraph, {
  tag: "span",
  name: "Heading",
  accessibilityRole: "header",
  fontFamily: "$heading",
  size: "$8",
  margin: 0
}), H1 = styled(Heading, {
  name: "H1",
  tag: "h1",
  variants: {
    unstyled: {
      false: {
        size: "$10"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H2 = styled(Heading, {
  name: "H2",
  tag: "h2",
  variants: {
    unstyled: {
      false: {
        size: "$9"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H3 = styled(Heading, {
  name: "H3",
  tag: "h3",
  variants: {
    unstyled: {
      false: {
        size: "$8"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H4 = styled(Heading, {
  name: "H4",
  tag: "h4",
  variants: {
    unstyled: {
      false: {
        size: "$7"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H5 = styled(Heading, {
  name: "H5",
  tag: "h5",
  variants: {
    unstyled: {
      false: {
        size: "$6"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), H6 = styled(Heading, {
  name: "H6",
  tag: "h6",
  variants: {
    unstyled: {
      false: {
        size: "$5"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
function wrapChildrenInText(TextComponent, propsIn, extraProps) {
  var {
    children,
    textProps,
    size,
    noTextWrap,
    color,
    fontFamily,
    fontSize,
    fontWeight,
    letterSpacing,
    textAlign,
    fontStyle,
    maxFontSizeMultiplier
  } = propsIn;
  if (noTextWrap || !children) return [children];
  var props = __spreadValues({}, extraProps);
  return color && (props.color = color), fontFamily && (props.fontFamily = fontFamily), fontSize && (props.fontSize = fontSize), fontWeight && (props.fontWeight = fontWeight), letterSpacing && (props.letterSpacing = letterSpacing), textAlign && (props.textAlign = textAlign), size && (props.size = size), fontStyle && (props.fontStyle = fontStyle), maxFontSizeMultiplier && (props.maxFontSizeMultiplier = maxFontSizeMultiplier), React.Children.toArray(children).map(function(child, index2) {
    return typeof child == "string" ? (
      // so "data-disable-theme" is a hack to fix themeInverse, don't ask me why
      /* @__PURE__ */ jsxRuntimeExports.jsx(TextComponent, __spreadProps(__spreadValues(__spreadValues({}, props), textProps), {
        children: child
      }), index2)
    ) : child;
  });
}
var DirectionContext = /* @__PURE__ */ React__namespace.createContext(void 0);
function useDirection(localDir) {
  var globalDir = React__namespace.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var ACCORDION_NAME = "Accordion", ACCORDION_KEYS = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"], [Collection, useCollection] = createCollection(ACCORDION_NAME), ACCORDION_CONTEXT = "Accordion", AccordionComponent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    type
  } = _a, accordionProps = __objRest(_a, [
    "type"
  ]), singleProps = accordionProps, multipleProps = accordionProps;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, {
    scope: props.__scopeAccordion || ACCORDION_CONTEXT,
    children: type === "multiple" ? /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplMultiple, __spreadProps(__spreadValues({}, multipleProps), {
      ref: forwardedRef
    })) : /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplSingle, __spreadProps(__spreadValues({}, singleProps), {
      ref: forwardedRef
    }))
  });
});
AccordionComponent.displayName = ACCORDION_NAME;
AccordionComponent.propTypes = {
  type(props) {
    var value = props.value || props.defaultValue;
    return props.type && !["single", "multiple"].includes(props.type) ? new Error("Invalid prop `type` supplied to `Accordion`. Expected one of `single | multiple`.") : props.type === "multiple" && typeof value == "string" ? new Error("Invalid prop `type` supplied to `Accordion`. Expected `single` when `defaultValue` or `value` is type `string`.") : props.type === "single" && Array.isArray(value) ? new Error("Invalid prop `type` supplied to `Accordion`. Expected `multiple` when `defaultValue` or `value` is type `string[]`.") : null;
  }
};
var {
  Provider: AccordionValueProvider,
  useStyledContext: useAccordionValueContext
} = createStyledContext(), {
  Provider: AccordionCollapsibleProvider,
  useStyledContext: useAccordionCollapsibleContext
} = createStyledContext(), AccordionImplSingle = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    control,
    onValueChange = function() {
    },
    collapsible = false
  } = _a, accordionSingleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "control",
    "onValueChange",
    "collapsible"
  ]), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2 || "",
    onChange: onValueChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionValueProvider, {
    scope: props.__scopeAccordion,
    value: value ? [value] : [],
    onItemOpen: setValue,
    onItemClose: React__namespace.useCallback(function() {
      return collapsible && setValue("");
    }, [setValue, collapsible]),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionCollapsibleProvider, {
      scope: props.__scopeAccordion,
      collapsible,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImpl, __spreadProps(__spreadValues({}, accordionSingleProps), {
        ref: forwardedRef
      }))
    })
  });
}), AccordionImplMultiple = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange = function() {
    }
  } = _a, accordionMultipleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange"
  ]), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2 || [],
    onChange: onValueChange
  }), handleItemOpen = React__namespace.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return [...prevValue, itemValue];
    });
  }, [setValue]), handleItemClose = React__namespace.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return prevValue.filter(function(value2) {
        return value2 !== itemValue;
      });
    });
  }, [setValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionValueProvider, {
    scope: props.__scopeAccordion,
    value: value || [],
    onItemOpen: handleItemOpen,
    onItemClose: handleItemClose,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionCollapsibleProvider, {
      scope: props.__scopeAccordion,
      collapsible: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImpl, __spreadProps(__spreadValues({}, accordionMultipleProps), {
        ref: forwardedRef
      }))
    })
  });
}), {
  Provider: AccordionImplProvider,
  useStyledContext: useAccordionContext
} = createStyledContext(), AccordionImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion,
    disabled,
    dir,
    orientation = "vertical"
  } = _a, accordionProps = __objRest(_a, [
    "__scopeAccordion",
    "disabled",
    "dir",
    "orientation"
  ]), accordionRef = React__namespace.useRef(null), composedRef = useComposedRefs(accordionRef, forwardedRef), getItems = useCollection(__scopeAccordion || ACCORDION_CONTEXT), direction = useDirection(dir), isDirectionLTR = direction === "ltr";
  composeEventHandlers(props.onKeyDown, function(event) {
    var _triggerCollection_clampedIndex_ref_current;
    if (ACCORDION_KEYS.includes(event.key)) {
      var target = event.target, triggerCollection = getItems().filter(function(item) {
        var el = item.ref.current;
        return !(el == null ? void 0 : el.disabled);
      }), triggerIndex = triggerCollection.findIndex(function(item) {
        return item.ref.current === target;
      }), triggerCount = triggerCollection.length;
      if (triggerIndex !== -1) {
        event.preventDefault();
        var nextIndex = triggerIndex, homeIndex = 0, endIndex = triggerCount - 1, moveNext = function() {
          nextIndex = triggerIndex + 1, nextIndex > endIndex && (nextIndex = homeIndex);
        }, movePrev = function() {
          nextIndex = triggerIndex - 1, nextIndex < homeIndex && (nextIndex = endIndex);
        };
        switch (event.key) {
          case "Home":
            nextIndex = homeIndex;
            break;
          case "End":
            nextIndex = endIndex;
            break;
          case "ArrowRight":
            orientation === "horizontal" && (isDirectionLTR ? moveNext() : movePrev());
            break;
          case "ArrowDown":
            orientation === "vertical" && moveNext();
            break;
          case "ArrowLeft":
            orientation === "horizontal" && (isDirectionLTR ? movePrev() : moveNext());
            break;
          case "ArrowUp":
            orientation === "vertical" && movePrev();
            break;
        }
        var clampedIndex = nextIndex % triggerCount;
        (_triggerCollection_clampedIndex_ref_current = triggerCollection[clampedIndex].ref.current) === null || _triggerCollection_clampedIndex_ref_current === void 0 || _triggerCollection_clampedIndex_ref_current.focus();
      }
    }
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionImplProvider, {
    scope: __scopeAccordion,
    disabled,
    direction: dir,
    orientation,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, {
      scope: __scopeAccordion || ACCORDION_CONTEXT,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, __spreadValues(__spreadValues({
        "data-orientation": orientation,
        ref: composedRef
      }, accordionProps), isWeb))
    })
  });
}), ITEM_NAME$2 = "AccordionItem", {
  Provider: AccordionItemProvider,
  useStyledContext: useAccordionItemContext
} = createStyledContext(), AccordionItem = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion,
    value
  } = _a, accordionItemProps = __objRest(_a, [
    "__scopeAccordion",
    "value"
  ]), accordionContext = useAccordionContext(__scopeAccordion), valueContext = useAccordionValueContext(__scopeAccordion), triggerId = React__namespace.useId(), open2 = value && valueContext.value.includes(value) || false, disabled = accordionContext.disabled || props.disabled;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionItemProvider, {
    scope: __scopeAccordion,
    open: open2,
    disabled,
    triggerId,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collapsible, __spreadProps(__spreadValues({
      "data-orientation": accordionContext.orientation,
      "data-state": open2 ? "open" : "closed",
      __scopeCollapsible: __scopeAccordion || ACCORDION_CONTEXT
    }, accordionItemProps), {
      ref: forwardedRef,
      disabled,
      open: open2,
      onOpenChange: function(open22) {
        open22 ? valueContext.onItemOpen(value) : valueContext.onItemClose(value);
      }
    }))
  });
});
AccordionItem.displayName = ITEM_NAME$2;
var HEADER_NAME = "AccordionHeader", AccordionHeader = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion
  } = _a, headerProps = __objRest(_a, [
    "__scopeAccordion"
  ]), accordionContext = useAccordionContext(__scopeAccordion), itemContext = useAccordionItemContext(__scopeAccordion);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(H1, __spreadProps(__spreadValues({
    "data-orientation": accordionContext.orientation,
    "data-state": getState$3(itemContext.open),
    "data-disabled": itemContext.disabled ? "" : void 0
  }, headerProps), {
    ref: forwardedRef
  }));
});
AccordionHeader.displayName = HEADER_NAME;
var AccordionTriggerFrame = styled(Collapsible.Trigger, {
  variants: {
    unstyled: {
      false: {
        cursor: "pointer",
        backgroundColor: "$background",
        borderColor: "$borderColor",
        borderWidth: 1,
        padding: "$true",
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          backgroundColor: "$backgroundFocus"
        },
        pressStyle: {
          backgroundColor: "$backgroundPress"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), AccordionTrigger = AccordionTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion
  } = _a, triggerProps = __objRest(_a, [
    "__scopeAccordion"
  ]), accordionContext = useAccordionContext(__scopeAccordion), itemContext = useAccordionItemContext(__scopeAccordion), collapsibleContext = useAccordionCollapsibleContext(__scopeAccordion);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, {
    scope: __scopeAccordion || ACCORDION_CONTEXT,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionTriggerFrame, __spreadProps(__spreadValues({
      //   @ts-ignore
      __scopeCollapsible: __scopeAccordion || ACCORDION_CONTEXT,
      "aria-disabled": itemContext.open && !collapsibleContext.collapsible || void 0,
      "data-orientation": accordionContext.orientation,
      id: itemContext.triggerId
    }, triggerProps), {
      ref: forwardedRef
    }))
  });
}), AccordionContentFrame = styled(Collapsible.Content, {
  variants: {
    unstyled: {
      false: {
        padding: "$true",
        backgroundColor: "$background"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), AccordionContent = AccordionContentFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeAccordion
  } = _a, contentProps = __objRest(_a, [
    "__scopeAccordion"
  ]), accordionContext = useAccordionContext(__scopeAccordion), itemContext = useAccordionItemContext(__scopeAccordion);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionContentFrame, __spreadProps(__spreadValues({
    role: "region",
    "aria-labelledby": itemContext.triggerId,
    "data-orientation": accordionContext.orientation,
    // @ts-ignore
    __scopeCollapsible: __scopeAccordion || ACCORDION_CONTEXT
  }, contentProps), {
    ref: forwardedRef
  }));
}), HeightAnimator = View.styleable(function(props, ref) {
  var itemContext = useAccordionItemContext(), _a = props, {
    children
  } = _a, rest = __objRest(_a, [
    "children"
  ]), [height, setHeight] = React__namespace.useState(0);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadProps(__spreadValues({
    ref,
    height: itemContext.open ? height : 0
  }, rest), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(View, {
      position: "absolute",
      width: "100%",
      onLayout: function(param) {
        var {
          nativeEvent
        } = param;
        nativeEvent.layout.height && setHeight(nativeEvent.layout.height);
      },
      children
    })
  }));
});
function getState$3(open2) {
  return open2 ? "open" : "closed";
}
var Accordion = withStaticProperties(AccordionComponent, {
  Trigger: AccordionTrigger,
  Header: AccordionHeader,
  Content: AccordionContent,
  Item: AccordionItem,
  HeightAnimator
});
var ZIndexStackContext = React.createContext(1), ZIndexHardcodedContext = React.createContext(void 0);
var ZIndicesByContext = {}, CurrentPortalZIndices = {}, useStackedZIndex = function(props) {
  if (process.env.TAMAGUI_STACK_Z_INDEX_GLOBAL) {
    var {
      stackZIndex,
      zIndex: zIndexProp
    } = props, id2 = React.useId(), zIndex = React.useMemo(function() {
      if (stackZIndex && stackZIndex !== "global" && zIndexProp === void 0) {
        var highest = Object.values(CurrentPortalZIndices).reduce(function(acc, cur) {
          return Math.max(acc, cur);
        }, 0);
        return Math.max(stackZIndex === true ? 1 : stackZIndex, highest + 1);
      }
      return zIndexProp != null ? zIndexProp : 1e3;
    }, [stackZIndex]);
    return React.useEffect(function() {
      if (typeof stackZIndex == "number") return CurrentPortalZIndices[id2] = stackZIndex, function() {
        delete CurrentPortalZIndices[id2];
      };
    }, [stackZIndex]), zIndex;
  } else {
    var _ZIndicesByContext, _stackLayer, {
      stackZIndex: stackZIndex1,
      zIndex: zIndexProp1
    } = props, id1 = React.useId(), stackingContextLevel = React.useContext(ZIndexStackContext), stackLayer = stackZIndex1 === "global" ? 0 : stackingContextLevel, hardcoded = React.useContext(ZIndexHardcodedContext);
    (_ZIndicesByContext = ZIndicesByContext)[_stackLayer = stackLayer] || (_ZIndicesByContext[_stackLayer] = {});
    var stackContext = ZIndicesByContext[stackLayer], zIndex1 = React.useMemo(function() {
      if (typeof zIndexProp1 == "number") return zIndexProp1;
      if (stackZIndex1) {
        if (hardcoded) return hardcoded + 1;
        var entries = Object.values(stackContext), baseForLayer = stackLayer * 5e3, nextLayerBase = (stackLayer + 1) * 5e3, validEntries = entries.filter(function(z) {
          return z < nextLayerBase;
        }), highest = validEntries.length > 0 ? Math.max(...validEntries) : baseForLayer, nextZIndex = highest === baseForLayer ? baseForLayer + 1 : highest + 1;
        return typeof stackZIndex1 == "number" ? stackZIndex1 + nextZIndex : nextZIndex;
      }
      return 1;
    }, [stackLayer, zIndexProp1, stackZIndex1]);
    return React.useEffect(function() {
      if (stackZIndex1) return stackContext[id1] = zIndex1, function() {
        delete stackContext[id1];
      };
    }, [zIndex1]), zIndex1;
  }
};
var StackZIndexContext = function(param) {
  var {
    children,
    zIndex
  } = param, existing = React.useContext(ZIndexStackContext), content = /* @__PURE__ */ jsxRuntimeExports.jsx(ZIndexStackContext.Provider, {
    value: existing + 1,
    children
  });
  return typeof zIndex < "u" && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ZIndexHardcodedContext.Provider, {
    value: zIndex,
    children: content
  })), content;
};
var _global__IS_FABRIC, IS_FABRIC = typeof global < "u" && !!((_global__IS_FABRIC = global._IS_FABRIC) !== null && _global__IS_FABRIC !== void 0 ? _global__IS_FABRIC : global.nativeFabricUIManager), USE_NATIVE_PORTAL = process.env.TAMAGUI_USE_NATIVE_PORTAL && process.env.TAMAGUI_USE_NATIVE_PORTAL !== "false" ? true : !isAndroid && !IS_FABRIC, allPortalHosts = /* @__PURE__ */ new Map(), portalListeners = {};
var ACTIONS = /* @__PURE__ */ (function(ACTIONS2) {
  return ACTIONS2[ACTIONS2.REGISTER_HOST = 0] = "REGISTER_HOST", ACTIONS2[ACTIONS2.DEREGISTER_HOST = 1] = "DEREGISTER_HOST", ACTIONS2[ACTIONS2.ADD_UPDATE_PORTAL = 2] = "ADD_UPDATE_PORTAL", ACTIONS2[ACTIONS2.REMOVE_PORTAL = 3] = "REMOVE_PORTAL", ACTIONS2;
})(ACTIONS || {}), INITIAL_STATE = {};
var registerHost = function(state, hostName) {
  return hostName in state || (state[hostName] = []), state;
}, deregisterHost = function(state, hostName) {
  return delete state[hostName], state;
}, addUpdatePortal = function(state, hostName, portalName, node) {
  hostName in state || (state = registerHost(state, hostName));
  var index2 = state[hostName].findIndex(function(item) {
    return item.name === portalName;
  });
  return index2 !== -1 ? state[hostName][index2].node = node : state[hostName].push({
    name: portalName,
    node
  }), state;
}, removePortal = function(state, hostName, portalName) {
  if (!(hostName in state)) return console.info(`Failed to remove portal '${portalName}', '${hostName}' was not registered!`), state;
  var index2 = state[hostName].findIndex(function(item) {
    return item.name === portalName;
  });
  return index2 !== -1 && state[hostName].splice(index2, 1), state;
}, reducer = function(state, action) {
  var {
    type
  } = action;
  switch (type) {
    case 0:
      return registerHost(__spreadValues({}, state), action.hostName);
    case 1:
      return deregisterHost(__spreadValues({}, state), action.hostName);
    case 2:
      return addUpdatePortal(__spreadValues({}, state), action.hostName, action.portalName, action.node);
    case 3:
      return removePortal(__spreadValues({}, state), action.hostName, action.portalName);
    default:
      return state;
  }
}, PortalStateContext = /* @__PURE__ */ React.createContext(null), PortalDispatchContext = /* @__PURE__ */ React.createContext(null), usePortalState = function(hostName) {
  var state = React.useContext(PortalStateContext);
  if (state === null) throw new Error("'PortalStateContext' cannot be null, please add 'PortalProvider' to the root component.");
  return state[hostName] || [];
}, usePortal = function() {
  var hostName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "root", dispatch = React.useContext(PortalDispatchContext);
  if (dispatch === null) throw new Error("'PortalDispatchContext' cannot be null, please add 'PortalProvider' to the root component.");
  var registerHost2 = React.useCallback(function() {
    dispatch({
      type: 0,
      hostName
    });
  }, []), deregisterHost2 = React.useCallback(function() {
    dispatch({
      type: 1,
      hostName
    });
  }, []), addUpdatePortal2 = React.useCallback(function(name, node) {
    dispatch({
      type: 2,
      hostName,
      portalName: name,
      node
    });
  }, []), removePortal2 = React.useCallback(function(name) {
    dispatch({
      type: 3,
      hostName,
      portalName: name
    });
  }, []);
  return {
    registerHost: registerHost2,
    deregisterHost: deregisterHost2,
    addPortal: addUpdatePortal2,
    updatePortal: addUpdatePortal2,
    removePortal: removePortal2
  };
}, PortalProviderComponent = function(param) {
  var {
    rootHostName = "root",
    shouldAddRootHost = true,
    children
  } = param, [state, dispatch] = React.useReducer(reducer, INITIAL_STATE), transitionDispatch = React.useMemo(function() {
    var next = function(value) {
      startTransition(function() {
        dispatch(value);
      });
    };
    return next;
  }, [dispatch]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalDispatchContext.Provider, {
    value: transitionDispatch,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(PortalStateContext.Provider, {
      value: state,
      children: [children, shouldAddRootHost && /* @__PURE__ */ jsxRuntimeExports.jsx(PortalHost, {
        name: rootHostName
      })]
    })
  });
}, PortalProvider = /* @__PURE__ */ React.memo(PortalProviderComponent);
PortalProvider.displayName = "PortalProvider";
var defaultRenderer = function(children) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
}, PortalHost = /* @__PURE__ */ React.memo(function(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalHostNonNative, __spreadValues({}, props));
});
function PortalHostNonNative(props) {
  var {
    name,
    forwardProps,
    render = defaultRenderer
  } = props, state = usePortalState(name), {
    registerHost: registerHost2,
    deregisterHost: deregisterHost2
  } = usePortal(props.name);
  return useIsomorphicLayoutEffect(function() {
    if (!(typeof window > "u")) return registerHost2(), function() {
      deregisterHost2();
    };
  }, []), render(forwardProps ? state.map(function(item) {
    var next = item.node, _a = forwardProps, {
      children
    } = _a, restForwardProps = __objRest(_a, [
      "children"
    ]);
    return forwardProps ? React.Children.map(next, function(child) {
      return /* @__PURE__ */ React.isValidElement(child) ? /* @__PURE__ */ React.cloneElement(child, __spreadValues({
        key: child.key
      }, restForwardProps)) : child;
    }) : next;
  }) : state.map(function(item) {
    return item.node;
  }));
}
var GorhomPortalItem = function(props) {
  var {
    name: _providedName,
    hostName,
    handleOnMount: _providedHandleOnMount,
    handleOnUnmount: _providedHandleOnUnmount,
    handleOnUpdate: _providedHandleOnUpdate,
    children,
    passThrough
  } = props, {
    addPortal: addUpdatePortal2,
    removePortal: removePortal2
  } = usePortal(hostName), id2 = React.useId(), name = _providedName || id2, handleOnMount = useEvent$1(function() {
    _providedHandleOnMount ? _providedHandleOnMount(function() {
      return addUpdatePortal2(name, children);
    }) : addUpdatePortal2(name, children);
  }), handleOnUnmount = useEvent$1(function() {
    _providedHandleOnUnmount ? _providedHandleOnUnmount(function() {
      return removePortal2(name);
    }) : removePortal2(name);
  }), handleOnUpdate = useEvent$1(function() {
    _providedHandleOnUpdate ? _providedHandleOnUpdate(function() {
      return addUpdatePortal2(name, children);
    }) : addUpdatePortal2(name, children);
  });
  return useIsomorphicLayoutEffect(function() {
    if (!passThrough) return handleOnMount(), function() {
      handleOnUnmount();
    };
  }, []), React.useEffect(function() {
    passThrough || handleOnUpdate();
  }, [children]), passThrough ? children : null;
};
var getStackedZIndexProps = function(propsIn) {
  return {
    stackZIndex: propsIn.stackZIndex,
    zIndex: resolveViewZIndex(propsIn.zIndex)
  };
}, resolveViewZIndex = function(zIndex) {
  return typeof zIndex > "u" || zIndex === "unset" ? void 0 : typeof zIndex == "number" ? zIndex : getTokenValue(zIndex, "zIndex");
};
var createPortal = (function() {
  if (IS_FABRIC) try {
    var _ReactFabricShimModule_default, ReactFabricShimModule = require("react-native/Libraries/Renderer/shims/ReactFabric"), _ReactFabricShimModule_default_createPortal;
    return (_ReactFabricShimModule_default_createPortal = ReactFabricShimModule == null || (_ReactFabricShimModule_default = ReactFabricShimModule.default) === null || _ReactFabricShimModule_default === void 0 ? void 0 : _ReactFabricShimModule_default.createPortal) !== null && _ReactFabricShimModule_default_createPortal !== void 0 ? _ReactFabricShimModule_default_createPortal : ReactFabricShimModule.createPortal;
  } catch (err) {
    return console.info("Note: error importing portal, defaulting to non-native portals", err), null;
  }
  try {
    var _ReactNativeShimModule_default, ReactNativeShimModule = require("react-native/Libraries/Renderer/shims/ReactNative"), _ReactNativeShimModule_default_createPortal;
    return (_ReactNativeShimModule_default_createPortal = ReactNativeShimModule == null || (_ReactNativeShimModule_default = ReactNativeShimModule.default) === null || _ReactNativeShimModule_default === void 0 ? void 0 : _ReactNativeShimModule_default.createPortal) !== null && _ReactNativeShimModule_default_createPortal !== void 0 ? _ReactNativeShimModule_default_createPortal : ReactNativeShimModule.createPortal;
  } catch (err) {
    return console.info("Note: error importing portal, defaulting to non-native portals", err), null;
  }
})(), Portal = function(propsIn) {
  var rootTag = React__namespace.useContext(RootTagContext), zIndex = useStackedZIndex(getStackedZIndexProps(propsIn)), {
    children,
    passThrough
  } = propsIn, contents = /* @__PURE__ */ jsxRuntimeExports.jsx(View, {
    pointerEvents: "box-none",
    position: "absolute",
    inset: 0,
    maxWidth: "100%",
    zIndex,
    passThrough,
    children
  });
  return !createPortal || !USE_NATIVE_PORTAL || !rootTag ? /* @__PURE__ */ jsxRuntimeExports.jsx(GorhomPortalItem, {
    passThrough,
    hostName: "root",
    children: contents
  }) : createPortal(contents, rootTag);
};
var AdaptContext = createStyledContext({
  Contents: null,
  scopeName: "",
  portalName: "",
  platform: null,
  setPlatform: function(x) {
  },
  when: null,
  setChildren: null,
  setWhen: function() {
  }
}), LastAdaptContextScope = /* @__PURE__ */ React.createContext(""), ProvideAdaptContext = function(param) {
  var _a = param, {
    children
  } = _a, context2 = __objRest(_a, [
    "children"
  ]), scope = context2.scopeName || "", lastScope = React.useContext(LastAdaptContextScope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LastAdaptContextScope.Provider, {
    value: lastScope || context2.lastScope || "",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptContext.Provider, __spreadProps(__spreadValues({
      scope,
      lastScope: lastScope || context2.lastScope
    }, context2), {
      children
    }))
  });
}, useAdaptContext = function(scope) {
  var lastScope = React.useContext(LastAdaptContextScope), adaptScope = scope != null ? scope : lastScope;
  return AdaptContext.useStyledContext(adaptScope);
}, AdaptPortals = /* @__PURE__ */ new Map(), AdaptParent = function(param) {
  var {
    children,
    Contents,
    scope,
    portal
  } = param, id2 = React.useId(), portalName = `AdaptPortal${scope}${id2}`, FinalContents = React.useMemo(function() {
    if (Contents) return Contents;
    if (AdaptPortals.has(portalName)) return AdaptPortals.get(portalName);
    var element = function() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalHost, {
        name: portalName,
        forwardProps: typeof portal == "boolean" ? void 0 : portal == null ? void 0 : portal.forwardProps
      }, id2);
    };
    return AdaptPortals.set(portalName, element), element;
  }, [portalName, Contents]);
  useIsomorphicLayoutEffect(function() {
    return AdaptPortals.set(portalName, FinalContents), function() {
      AdaptPortals.delete(portalName);
    };
  }, [portalName]);
  var [when, setWhen] = React.useState(null), [platform2, setPlatform] = React.useState(null), [children2, setChildren] = React.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LastAdaptContextScope.Provider, {
    value: scope,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, {
      Contents: FinalContents,
      when,
      platform: platform2,
      setPlatform,
      setWhen,
      setChildren,
      portalName,
      scopeName: scope,
      children
    })
  });
}, AdaptContents = function(param) {
  var _a = param, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = useAdaptContext(scope);
  if (!(context2 == null ? void 0 : context2.Contents)) throw new Error("You're rendering a Tamagui <Adapt /> component without nesting it inside a parent that is able to adapt.");
  return /* @__PURE__ */ React.createElement(context2.Contents, __spreadProps(__spreadValues({}, rest), {
    key: "stable"
  }));
};
AdaptContents.shouldForwardSpace = true;
var Adapt = withStaticProperties(function(props) {
  var {
    platform: platform2,
    when,
    children,
    scope
  } = props, context2 = useAdaptContext(scope), enabled = useAdaptIsActiveGiven(props);
  useIsomorphicLayoutEffect(function() {
    var _context_setWhen, _context_setPlatform;
    context2 == null || (_context_setWhen = context2.setWhen) === null || _context_setWhen === void 0 || _context_setWhen.call(context2, when || enabled), context2 == null || (_context_setPlatform = context2.setPlatform) === null || _context_setPlatform === void 0 || _context_setPlatform.call(context2, platform2 || null);
  }, [when, platform2, enabled, context2.setWhen, context2.setPlatform]), useIsomorphicLayoutEffect(function() {
    return function() {
      var _context_setWhen, _context_setPlatform;
      context2 == null || (_context_setWhen = context2.setWhen) === null || _context_setWhen === void 0 || _context_setWhen.call(context2, null), context2 == null || (_context_setPlatform = context2.setPlatform) === null || _context_setPlatform === void 0 || _context_setPlatform.call(context2, null);
    };
  }, []);
  var output;
  if (typeof children == "function") {
    var Component = context2 == null ? void 0 : context2.Contents;
    output = children(Component ? /* @__PURE__ */ jsxRuntimeExports.jsx(Component, {}) : null);
  } else output = children;
  return useIsomorphicLayoutEffect(function() {
    typeof children == "function" && output !== void 0 && (context2 == null ? void 0 : context2.setChildren(output));
  }, [output]), /* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
    children: enabled ? output : null
  });
}, {
  Contents: AdaptContents
}), AdaptPortalContents = function(props) {
  var isActive = useAdaptIsActive(props.scope), {
    portalName
  } = useAdaptContext(props.scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GorhomPortalItem, {
    passThrough: !isActive,
    hostName: portalName,
    children: props.children
  });
}, useAdaptIsActiveGiven = function(param) {
  var {
    when,
    platform: platform2
  } = param, media = useMedia();
  if (when == null && platform2 == null) return false;
  if (when === true) return true;
  var enabled = false;
  return platform2 === "touch" ? enabled = isTouchable : platform2 === "native" ? enabled = !isWeb : platform2 === "web" ? enabled = isWeb : platform2 === "ios" ? enabled = isIos : platform2 === "android" && (enabled = isAndroid), platform2 && enabled == false ? false : (when && typeof when == "string" && (enabled = media[when]), enabled);
}, useAdaptIsActive = function(scope) {
  var props = useAdaptContext(scope);
  return useAdaptIsActiveGiven(props);
};
function createContext(rootComponentName, defaultContext) {
  var Context = /* @__PURE__ */ React__namespace.createContext(defaultContext);
  function Provider(props) {
    var _a = props, {
      children
    } = _a, context2 = __objRest(_a, [
      "children"
    ]), value = React__namespace.useMemo(function() {
      return context2;
    }, Object.values(context2));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, {
      value,
      children
    });
  }
  function useContext(consumerName) {
    var context2 = React__namespace.useContext(Context);
    if (context2) return context2;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext];
}
function createContextScope(scopeName) {
  var createContextScopeDeps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], defaultContexts = [];
  function createContext2(rootComponentName, defaultContext) {
    var BaseContext = /* @__PURE__ */ React__namespace.createContext(defaultContext), index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider(props) {
      var _scope_scopeName, _a = props, {
        scope,
        children
      } = _a, context2 = __objRest(_a, [
        "scope",
        "children"
      ]), Context = (scope == null || (_scope_scopeName = scope[scopeName]) === null || _scope_scopeName === void 0 ? void 0 : _scope_scopeName[index2]) || BaseContext, value = React__namespace.useMemo(function() {
        return context2;
      }, Object.values(context2));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, {
        value,
        children
      });
    }
    function useContext(consumerName, scope, options) {
      var _scope_scopeName, Context = (scope == null || (_scope_scopeName = scope[scopeName]) === null || _scope_scopeName === void 0 ? void 0 : _scope_scopeName[index2]) || BaseContext, context2 = React__namespace.useContext(Context);
      if (context2) return context2;
      if (defaultContext !== void 0) return defaultContext;
      var missingContextMessage = `\`${consumerName}\` must be used within \`${rootComponentName}\``;
      if (options == null ? void 0 : options.fallback) return (options == null ? void 0 : options.warn) !== false && console.warn(missingContextMessage), options.fallback;
      throw new Error(missingContextMessage);
    }
    return [Provider, useContext];
  }
  var createScope = function() {
    var scopeContexts = defaultContexts.map(function(defaultContext) {
      return /* @__PURE__ */ React__namespace.createContext(defaultContext);
    });
    return function(scope) {
      var contexts = (scope == null ? void 0 : scope[scopeName]) || scopeContexts;
      return React__namespace.useMemo(function() {
        return {
          [`__scope${scopeName}`]: __spreadProps(__spreadValues({}, scope), {
            [scopeName]: contexts
          })
        };
      }, [scope, contexts]);
    };
  };
  return createScope.scopeName = scopeName, [createContext2, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes() {
  for (var _len = arguments.length, scopes = new Array(_len), _key = 0; _key < _len; _key++) scopes[_key] = arguments[_key];
  var baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  var createScope = function() {
    var scopeHooks = scopes.map(function(createScope2) {
      return {
        useScope: createScope2(),
        scopeName: createScope2.scopeName
      };
    });
    return function(overrideScopes) {
      var nextScopes = scopeHooks.reduce(function(nextScopes2, param) {
        var {
          useScope,
          scopeName
        } = param, scopeProps = useScope(overrideScopes), currentScope = scopeProps[`__scope${scopeName}`];
        return __spreadValues(__spreadValues({}, nextScopes2), currentScope);
      }, {});
      return React__namespace.useMemo(function() {
        return {
          [`__scope${baseScope.scopeName}`]: nextScopes
        };
      }, [nextScopes]);
    };
  };
  return createScope.scopeName = baseScope.scopeName, createScope;
}
var FOCUS_SCOPE_CONTROLLER_NAME = "FocusScopeController", [createFocusScopeControllerContext, createFocusScopeControllerScope] = createContextScope(FOCUS_SCOPE_CONTROLLER_NAME), [FocusScopeControllerProvider, useFocusScopeControllerContext] = createFocusScopeControllerContext(FOCUS_SCOPE_CONTROLLER_NAME);
function FocusScopeController(props) {
  var {
    __scopeFocusScope,
    children,
    enabled,
    loop,
    trapped,
    onMountAutoFocus,
    onUnmountAutoFocus,
    forceUnmount,
    focusOnIdle
  } = props, stableOnMountAutoFocus = useEvent$1(onMountAutoFocus), stableOnUnmountAutoFocus = useEvent$1(onUnmountAutoFocus), contextValue = React__namespace.useMemo(function() {
    return {
      enabled,
      loop,
      trapped,
      onMountAutoFocus: stableOnMountAutoFocus,
      onUnmountAutoFocus: stableOnUnmountAutoFocus,
      forceUnmount,
      focusOnIdle
    };
  }, [enabled, loop, trapped, stableOnMountAutoFocus, stableOnUnmountAutoFocus, forceUnmount, focusOnIdle]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FocusScopeControllerProvider, __spreadProps(__spreadValues({
    scope: __scopeFocusScope
  }, contextValue), {
    children
  }));
}
var FocusScopeControllerComponent = FocusScopeController;
var RemoveScroll = function(props) {
  return props.children;
};
var SHEET_NAME = "Sheet", SHEET_HANDLE_NAME = "SheetHandle", SHEET_OVERLAY_NAME = "SheetOverlay";
var [createSheetContext, createSheetScope] = createContextScope(SHEET_NAME), [SheetProvider, useSheetContext] = createSheetContext(SHEET_NAME, {});
var useSheetController = function() {
  var controller = React.useContext(SheetControllerContext), isHidden = controller == null ? void 0 : controller.hidden, isShowingNonSheet = isHidden && (controller == null ? void 0 : controller.open);
  return {
    controller,
    isHidden,
    isShowingNonSheet,
    disableDrag: controller == null ? void 0 : controller.disableDrag
  };
}, SheetControllerContext = /* @__PURE__ */ React.createContext(null);
var useSheetOpenState = function(props) {
  var {
    isHidden,
    controller
  } = useSheetController(), onOpenChangeInternal = function(val) {
    var _controller_onOpenChange, _props_onOpenChange;
    controller == null || (_controller_onOpenChange = controller.onOpenChange) === null || _controller_onOpenChange === void 0 || _controller_onOpenChange.call(controller, val), (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
  }, _controller_open, _props_open, propVal = props.preferAdaptParentOpenState ? (_controller_open = controller == null ? void 0 : controller.open) !== null && _controller_open !== void 0 ? _controller_open : props.open : (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : controller == null ? void 0 : controller.open, _props_defaultOpen, [open2, setOpen] = useControllableState({
    prop: propVal,
    defaultProp: (_props_defaultOpen = props.defaultOpen) !== null && _props_defaultOpen !== void 0 ? _props_defaultOpen : false,
    onChange: onOpenChangeInternal,
    strategy: "most-recent-wins"
  });
  return {
    open: open2,
    setOpen,
    isHidden,
    controller
  };
};
function useSheetProviderProps(props, state) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, handleRef = React.useRef(null), contentRef = React.useRef(null), [frameSize, setFrameSize] = React.useState(0), [maxContentSize, setMaxContentSize] = React.useState(0), _props_snapPointsMode, snapPointsMode = (_props_snapPointsMode = props.snapPointsMode) !== null && _props_snapPointsMode !== void 0 ? _props_snapPointsMode : "percent", _props_snapPoints, snapPointsProp = (_props_snapPoints = props.snapPoints) !== null && _props_snapPoints !== void 0 ? _props_snapPoints : snapPointsMode === "percent" ? [80] : snapPointsMode === "constant" ? [256] : ["fit"], hasFit = snapPointsProp[0] === "fit", snapPoints = React.useMemo(function() {
    return props.dismissOnSnapToBottom ? [...snapPointsProp, 0] : snapPointsProp;
  }, [JSON.stringify(snapPointsProp), props.dismissOnSnapToBottom]), [position_, setPositionImmediate] = useControllableState({
    prop: props.position,
    defaultProp: props.defaultPosition || (state.open ? 0 : -1),
    onChange: props.onPositionChange,
    strategy: "most-recent-wins"
  }), position = state.open === false ? -1 : position_, {
    open: open2
  } = state, setPosition = React.useCallback(function(next) {
    props.dismissOnSnapToBottom && next === snapPoints.length - 1 ? state.setOpen(false) : setPositionImmediate(next);
  }, [props.dismissOnSnapToBottom, snapPoints.length, setPositionImmediate, state.setOpen]);
  open2 && props.dismissOnSnapToBottom && position === snapPoints.length - 1 && setPositionImmediate(0);
  var shouldSetPositionOpen = open2 && position < 0;
  React.useEffect(function() {
    shouldSetPositionOpen && setPosition(0);
  }, [setPosition, shouldSetPositionOpen]);
  var {
    animationDriver
  } = useConfiguration();
  if (!animationDriver) throw new Error("Must set animations in tamagui.config.ts");
  var scrollBridge = useConstant(function() {
    var parentDragListeners = /* @__PURE__ */ new Set(), bridge = {
      hasScrollableContent: false,
      enabled: false,
      y: 0,
      paneY: 0,
      paneMinY: 0,
      scrollStartY: -1,
      drag: function() {
      },
      release: function() {
      },
      scrollLock: false,
      isParentDragging: false,
      onParentDragging: function(cb) {
        return parentDragListeners.add(cb), function() {
          parentDragListeners.delete(cb);
        };
      },
      setParentDragging: function(val) {
        val !== bridge.isParentDragging && (bridge.isParentDragging = val, parentDragListeners.forEach(function(cb) {
          return cb(val);
        }));
      }
    };
    return bridge;
  }), _props_forceRemoveScrollEnabled, removeScrollEnabled = (_props_forceRemoveScrollEnabled = props.forceRemoveScrollEnabled) !== null && _props_forceRemoveScrollEnabled !== void 0 ? _props_forceRemoveScrollEnabled : open2 && props.modal, maxSnapPoint = snapPoints[0], screenSize = snapPointsMode === "percent" ? frameSize / ((typeof maxSnapPoint == "number" ? maxSnapPoint : 100) / 100) : maxContentSize, _props_dismissOnOverlayPress, _props_dismissOnSnapToBottom, providerProps = {
    screenSize,
    maxSnapPoint,
    removeScrollEnabled,
    scrollBridge,
    modal: !!props.modal,
    open: state.open,
    setOpen: state.setOpen,
    hidden: !!state.isHidden,
    contentRef,
    handleRef,
    frameSize,
    setFrameSize,
    dismissOnOverlayPress: (_props_dismissOnOverlayPress = props.dismissOnOverlayPress) !== null && _props_dismissOnOverlayPress !== void 0 ? _props_dismissOnOverlayPress : true,
    dismissOnSnapToBottom: (_props_dismissOnSnapToBottom = props.dismissOnSnapToBottom) !== null && _props_dismissOnSnapToBottom !== void 0 ? _props_dismissOnSnapToBottom : false,
    onOverlayComponent: options.onOverlayComponent,
    scope: props.__scopeSheet,
    hasFit,
    position,
    snapPoints,
    snapPointsMode,
    setMaxContentSize,
    setPosition,
    setPositionImmediate,
    onlyShowFrame: false
  };
  return providerProps;
}
var nativeSheets = {
  ios: null
};
function getNativeSheet(platform2) {
  return nativeSheets[platform2];
}
function setupNativeSheet(platform2, RNIOSModal) {
  var {
    ModalSheetView,
    ModalSheetViewMainContent
  } = RNIOSModal;
  platform2 === "ios" && (nativeSheets[platform2] = function(props) {
    var state = useSheetOpenState(props), providerProps = useSheetProviderProps(props, state), {
      open: open2,
      setOpen
    } = state, ref = React.useRef(void 0);
    React.useEffect(function() {
      if (open2) {
        var _ref_current;
        (_ref_current = ref.current) === null || _ref_current === void 0 || _ref_current.presentModal();
      } else {
        var _ref_current1;
        (_ref_current1 = ref.current) === null || _ref_current1 === void 0 || _ref_current1.dismissModal();
      }
    }, [open2]);
    function setOpenInternal(next) {
      var _props_onOpenChange;
      (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, open2), setOpen(next);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(SheetProvider, __spreadProps(__spreadValues({
        setHasScrollView: emptyFn
      }, providerProps), {
        onlyShowFrame: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ModalSheetView, {
            ref,
            onModalDidDismiss: function() {
              return setOpenInternal(false);
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModalSheetViewMainContent, {
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
                style: {
                  flex: 1
                },
                children: props.children
              })
            })
          }),
          /* for some reason select triggers wont show on native if this isn't inside the actual tree not inside implementation... */
          /* so just hiding it here for now... not great... */
          /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, {
            position: "absolute",
            opacity: 0,
            pointerEvents: "none",
            width: 0,
            height: 0,
            children: props.children
          })
        ]
      }))
    });
  });
}
var emptyFn = function() {
};
var ParentSheetContext = React.createContext({
  zIndex: 1e5
}), SheetInsideSheetContext = React.createContext(null);
function resisted(y, minY) {
  if (y >= minY) return y;
  var pastBoundary = minY - y, resistedDistance = Math.sqrt(pastBoundary) * 2;
  return minY - resistedDistance;
}
var hiddenSize = 10000.1, relativeDimensionTo = "screen", SheetImplementationCustom = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var parentSheet = React.useContext(ParentSheetContext), {
    animation,
    animationConfig: animationConfigProp,
    modal = false,
    zIndex = parentSheet.zIndex + 1,
    moveOnKeyboardChange = false,
    unmountChildrenWhenHidden = false,
    portalProps,
    containerComponent: ContainerComponent = React.Fragment
  } = props, state = useSheetOpenState(props), [overlayComponent, setOverlayComponent] = React.useState(null), providerProps = useSheetProviderProps(props, state, {
    onOverlayComponent: setOverlayComponent
  }), {
    frameSize,
    setFrameSize,
    snapPoints,
    snapPointsMode,
    hasFit,
    position,
    setPosition,
    scrollBridge,
    screenSize,
    setMaxContentSize,
    maxSnapPoint
  } = providerProps, {
    open: open2,
    controller,
    isHidden
  } = state, sheetRef = React.useRef(void 0), ref = useComposedRefs(forwardedRef, sheetRef, providerProps.contentRef), {
    animationDriver
  } = useConfiguration();
  if (!animationDriver) throw new Error("Sheet reqiures an animation driver to be set");
  var animationConfig = (function() {
    var _animationDriver_animations;
    if (animationConfigProp) return animationConfigProp;
    var [animationProp, animationPropConfig] = animation ? Array.isArray(animation) ? animation : [animation] : [];
    return animationProp && !((_animationDriver_animations = animationDriver.animations) === null || _animationDriver_animations === void 0) && _animationDriver_animations[animationProp] ? __spreadValues(__spreadValues({}, animationDriver.animations[animationProp]), animationPropConfig) : null;
  })(), [isShowingInnerSheet, setIsShowingInnerSheet] = React.useState(false), shouldHideParentSheet = modal && isShowingInnerSheet && // if not using weird portal limitation we dont need to hide parent sheet
  USE_NATIVE_PORTAL, sheetInsideSheet = React.useContext(SheetInsideSheetContext), onInnerSheet = React.useCallback(function(hasChild) {
    setIsShowingInnerSheet(hasChild);
  }, []), stableFrameSize = React.useRef(frameSize);
  React.useEffect(function() {
    open2 && frameSize && (stableFrameSize.current = frameSize);
  }, [open2, frameSize]);
  var positions = React.useMemo(function() {
    return snapPoints.map(function(point) {
      return (
        // FIX: Use stable frameSize when closing to prevent position jumps
        getYPositions(snapPointsMode, point, screenSize, open2 ? frameSize : stableFrameSize.current)
      );
    });
  }, [screenSize, frameSize, snapPoints, snapPointsMode, open2]), {
    useAnimatedNumber,
    useAnimatedNumberStyle,
    useAnimatedNumberReaction
  } = animationDriver, _animationDriver_View, AnimatedView = (_animationDriver_View = animationDriver.View) !== null && _animationDriver_View !== void 0 ? _animationDriver_View : Stack;
  useIsomorphicLayoutEffect(function() {
    if (sheetInsideSheet && open2) return sheetInsideSheet(true), function() {
      sheetInsideSheet(false);
    };
  }, [sheetInsideSheet, open2]);
  var nextParentContext = React.useMemo(function() {
    return {
      zIndex
    };
  }, [zIndex]);
  useDidFinishSSR();
  var startPosition = screenSize ? screenSize : hiddenSize, animatedNumber = useAnimatedNumber(startPosition), at = React.useRef(startPosition), hasntMeasured = at.current === hiddenSize, [disableAnimation, setDisableAnimation] = React.useState(hasntMeasured), hasScrollView = React.useRef(false);
  useAnimatedNumberReaction({
    value: animatedNumber,
    hostRef: sheetRef
  }, React.useCallback(function(value) {
    at.current = value, scrollBridge.paneY = value;
  }, [animationDriver]));
  function stopSpring() {
    animatedNumber.stop(), scrollBridge.onFinishAnimate && (scrollBridge.onFinishAnimate(), scrollBridge.onFinishAnimate = void 0);
  }
  var animateTo = useEvent$1(function(position2) {
    if (frameSize !== 0) {
      var toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
      at.current !== toValue && (at.current = toValue, stopSpring(), animatedNumber.setValue(toValue, __spreadValues({
        type: "spring"
      }, animationConfig)));
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (hasntMeasured && screenSize && frameSize) {
      at.current = screenSize, animatedNumber.setValue(screenSize, {
        type: "timing",
        duration: 0
      }, function() {
        setTimeout(function() {
          setDisableAnimation(false);
        }, 10);
      });
      return;
    }
    disableAnimation || !frameSize || !screenSize || isHidden || hasntMeasured && !open2 || (animateTo(position), position === -1 && (scrollBridge.scrollLock = false, scrollBridge.scrollStartY = -1));
  }, [hasntMeasured, disableAnimation, isHidden, frameSize, screenSize, open2, position]);
  var _props_disableDrag, disableDrag = (_props_disableDrag = props.disableDrag) !== null && _props_disableDrag !== void 0 ? _props_disableDrag : controller == null ? void 0 : controller.disableDrag, themeName = useThemeName(), [isDragging, setIsDragging] = React.useState(false), panResponder = React.useMemo(function() {
    if (disableDrag || !frameSize || isShowingInnerSheet) return;
    var minY = positions[0];
    scrollBridge.paneMinY = minY;
    var startY = at.current;
    function setPanning(val) {
      setIsDragging(val);
    }
    var release = function(param) {
      var {
        vy,
        dragAt
      } = param;
      if (scrollBridge.setParentDragging(false), !scrollBridge.scrollLock) {
        isExternalDrag = false, setPanning(false);
        for (var at2 = dragAt + startY, end = at2 + frameSize * vy * 0.2, closestPoint = 0, dist = Number.POSITIVE_INFINITY, i = 0; i < positions.length; i++) {
          var position2 = positions[i], curDist = end > position2 ? end - position2 : position2 - end;
          curDist < dist && (dist = curDist, closestPoint = i);
        }
        setPosition(closestPoint), animateTo(closestPoint);
      }
    }, finish = function(_e, state2) {
      release({
        vy: state2.vy,
        dragAt: state2.dy
      });
    }, onMoveShouldSet = function(e2, param) {
      var {
        dy
      } = param;
      function getShouldSet() {
        if (e2.target === providerProps.handleRef.current) return true;
        if (scrollBridge.hasScrollableContent === true) {
          if (scrollBridge.scrollLock) return false;
          var isScrolled = scrollBridge.y !== 0, isDraggingUp = dy < 0, isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
          if (isScrolled) return false;
          if (isNearTop && hasScrollView.current && isDraggingUp) return false;
        }
        return Math.abs(dy) > 10;
      }
      var granted = getShouldSet();
      return granted && scrollBridge.setParentDragging(true), granted;
    }, grant = function() {
      setPanning(true), stopSpring(), startY = at.current;
    }, isExternalDrag = false;
    return scrollBridge.drag = function(dy) {
      isExternalDrag || (isExternalDrag = true, grant());
      var to = dy + startY;
      animatedNumber.setValue(resisted(to, minY), {
        type: "direct"
      });
    }, scrollBridge.release = release, PanResponder_default.create({
      onMoveShouldSetPanResponder: onMoveShouldSet,
      onPanResponderGrant: grant,
      onPanResponderMove: function(_e, param) {
        var {
          dy
        } = param, toFull = dy + startY, to = resisted(toFull, minY), isAtTop = to <= minY;
        isAtTop ? scrollBridge.setParentDragging(false) : scrollBridge.setParentDragging(true), animatedNumber.setValue(to, {
          type: "direct"
        });
      },
      onPanResponderEnd: finish,
      onPanResponderTerminate: finish,
      onPanResponderRelease: finish
    });
  }, [disableDrag, isShowingInnerSheet, animateTo, frameSize, positions, setPosition]), handleAnimationViewLayout = React.useCallback(function(e2) {
    var _e_nativeEvent;
    if (!(!open2 && stableFrameSize.current !== 0)) {
      var next = Math.min((_e_nativeEvent = e2.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions2.get(relativeDimensionTo).height);
      next && setFrameSize(next);
    }
  }, [open2]), handleMaxContentViewLayout = React.useCallback(function(e2) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e2.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions2.get(relativeDimensionTo).height);
    next && setMaxContentSize(next);
  }, []), animatedStyle = useAnimatedNumberStyle(animatedNumber, function(val) {
    "worklet";
    var translateY = frameSize === 0 ? hiddenSize : val;
    return {
      transform: [{
        translateY
      }]
    };
  }), sizeBeforeKeyboard = React.useRef(null);
  React.useEffect(function() {
    if (!!moveOnKeyboardChange) {
      var keyboardShowListener = Keyboard.addListener(currentPlatform === "ios" ? "keyboardWillShow" : "keyboardDidShow", function(e2) {
        sizeBeforeKeyboard.current === null && (sizeBeforeKeyboard.current = isHidden || position === -1 ? screenSize : positions[position], animatedNumber.setValue(Math.max(sizeBeforeKeyboard.current - e2.endCoordinates.height, 0), {
          type: "timing",
          duration: 250
        }));
      }), keyboardDidHideListener = Keyboard.addListener("keyboardDidHide", function() {
        sizeBeforeKeyboard.current !== null && (animatedNumber.setValue(sizeBeforeKeyboard.current, {
          type: "timing",
          duration: 250
        }), sizeBeforeKeyboard.current = null);
      });
      return function() {
        keyboardDidHideListener.remove(), keyboardShowListener.remove();
      };
    }
  }, [moveOnKeyboardChange, positions, position, isHidden]);
  var [opacity, setOpacity] = React.useState(open2 ? 1 : 0);
  open2 && opacity === 0 && setOpacity(1), React.useEffect(function() {
    if (!open2) {
      var tm = setTimeout(function() {
        setOpacity(0);
      }, 400);
      return function() {
        clearTimeout(tm);
      };
    }
  }, [open2]);
  var forcedContentHeight = hasFit ? void 0 : snapPointsMode === "percent" ? `${maxSnapPoint}${"%"}` : maxSnapPoint, setHasScrollView = React.useCallback(function(val) {
    hasScrollView.current = val;
  }, []), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMeasurementController, {
    disable: !open2,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ParentSheetContext.Provider, {
      value: nextParentContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(SheetProvider, __spreadProps(__spreadValues({}, providerProps), {
        setHasScrollView,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, {
          custom: {
            open: open2
          },
          children: shouldHideParentSheet || !open2 ? null : overlayComponent
        }), snapPointsMode !== "percent" && /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
          style: {
            opacity: 0,
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            pointerEvents: "none"
          },
          onLayout: handleMaxContentViewLayout
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedView, __spreadProps(__spreadValues({
          ref
        }, panResponder == null ? void 0 : panResponder.panHandlers), {
          onLayout: handleAnimationViewLayout,
          // @ts-ignore for CSS driver this is necessary to attach the transition
          // also motion driver at least though i suspect all drivers?
          animation: isDragging || disableAnimation ? null : animation,
          // @ts-ignore
          disableClassName: true,
          style: [__spreadValues({
            position: "absolute",
            zIndex,
            width: "100%",
            height: forcedContentHeight,
            minHeight: forcedContentHeight,
            opacity: shouldHideParentSheet ? 0 : opacity
          }, (shouldHideParentSheet || !open2) && {
            pointerEvents: "none"
          }), animatedStyle],
          children: (
            /* <AdaptProvider>{props.children}</AdaptProvider> */
            props.children
          )
        }))]
      }))
    })
  });
  if (!USE_NATIVE_PORTAL) {
    var adaptContext = useAdaptContext();
    contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, __spreadProps(__spreadValues({}, adaptContext), {
      children: (
        /* @ts-ignore */
        contents
      )
    }));
  }
  var shouldMountChildren = unmountChildrenWhenHidden ? !!opacity : true;
  if (modal) {
    var modalContents = /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, __spreadProps(__spreadValues({
      stackZIndex: zIndex
    }, portalProps), {
      children: shouldMountChildren && /* @__PURE__ */ jsxRuntimeExports.jsx(ContainerComponent, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
          contain: true,
          forceClassName: true,
          name: themeName,
          children: contents
        })
      })
    }));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetInsideSheetContext.Provider, {
      value: onInnerSheet,
      children: modalContents
    });
  }
  return contents;
});
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize) return 0;
  if (mode === "mixed") {
    if (typeof point == "number") return screenSize - Math.min(screenSize, Math.max(0, point));
    if (point === "fit") return screenSize - Math.min(screenSize, frameSize);
    if (point.endsWith("%")) {
      var pct = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct)) return console.warn("Invalid snapPoint percentage string"), 0;
      var next = Math.round(screenSize - pct * screenSize);
      return next;
    }
    return console.warn("Invalid snapPoint unknown value"), 0;
  }
  if (mode === "fit") return point === 0 ? screenSize : screenSize - Math.min(screenSize, frameSize);
  if (mode === "constant" && typeof point == "number") return screenSize - Math.min(screenSize, Math.max(0, point));
  var pct1 = Math.min(100, Math.max(0, Number(point))) / 100;
  return Number.isNaN(pct1) ? (console.warn("Invalid snapPoint percentage"), 0) : Math.round(screenSize - pct1 * screenSize);
}
var ScrollView3 = styled(ForwardedScrollView, {
  name: "ScrollView",
  scrollEnabled: true,
  variants: {
    fullscreen: {
      true: fullscreenStyle
    }
  }
}, {
  accept: {
    contentContainerStyle: "style"
  }
});
var SHEET_SCROLL_VIEW_NAME = "SheetScrollView", SheetScrollView = /* @__PURE__ */ React.forwardRef(
  // we disallow customizing it because we want to let people know it doens't work well with out measuring of inner content
  // height using a view
  function(param, ref) {
    var _a = param, {
      __scopeSheet,
      children,
      onScroll,
      scrollEnabled: scrollEnabledProp
    } = _a, props = __objRest(_a, [
      "__scopeSheet",
      "children",
      "onScroll",
      "scrollEnabled"
    ]), context2 = useSheetContext(SHEET_SCROLL_VIEW_NAME, __scopeSheet), {
      scrollBridge,
      setHasScrollView
    } = context2, [scrollEnabled, setScrollEnabled_] = useControllableState({
      prop: scrollEnabledProp,
      defaultProp: true
    }), scrollRef = React.useRef(null), setScrollEnabled = function(next) {
      var _scrollRef_current_setNativeProps, _scrollRef_current;
      (_scrollRef_current = scrollRef.current) === null || _scrollRef_current === void 0 || (_scrollRef_current_setNativeProps = _scrollRef_current.setNativeProps) === null || _scrollRef_current_setNativeProps === void 0 || _scrollRef_current_setNativeProps.call(_scrollRef_current, {
        scrollEnabled: next
      }), setScrollEnabled_(next);
    }, state = React.useRef({
      lastPageY: 0,
      dragAt: 0,
      dys: [],
      // store a few recent dys to get velocity on release
      isScrolling: false,
      isDraggingScrollArea: false
    });
    React.useEffect(function() {
      return setHasScrollView(true), function() {
        setHasScrollView(false);
      };
    }, []);
    var release = function() {
      if (state.current.isDraggingScrollArea) {
        state.current.isDraggingScrollArea = false, scrollBridge.scrollStartY = -1, scrollBridge.scrollLock = false, state.current.isScrolling = false, setScrollEnabled(true);
        var vy = 0;
        if (state.current.dys.length) {
          var recentDys = state.current.dys.slice(-10), dist = recentDys.length ? recentDys.reduce(function(a, b2) {
            return a + b2;
          }, 0) : 0, avgDy = dist / recentDys.length;
          vy = avgDy * 0.04;
        }
        state.current.dys = [], scrollBridge.release({
          dragAt: state.current.dragAt,
          vy
        });
      }
    }, scrollable = scrollEnabled;
    React.useEffect(function() {
    }, [scrollRef]);
    var [hasScrollableContent, setHasScrollableContent] = React.useState(true), parentHeight = React.useRef(0), contentHeight = React.useRef(0), setIsScrollable = function() {
      parentHeight.current && contentHeight.current && setHasScrollableContent(contentHeight.current > parentHeight.current);
    };
    return React.useEffect(function() {
      scrollBridge.hasScrollableContent = hasScrollableContent;
    }, [hasScrollableContent]), /* @__PURE__ */ jsxRuntimeExports.jsxs(ScrollView3, __spreadProps(__spreadValues({
      onLayout: function(e2) {
        parentHeight.current = Math.ceil(e2.nativeEvent.layout.height), setIsScrollable();
      },
      ref: composeRefs(scrollRef, ref),
      flex: 1,
      scrollEventThrottle: 8,
      onResponderRelease: release,
      className: "_ovs-contain",
      scrollEnabled: scrollable,
      // {...(Platform.OS === 'android' && {
      //   pointerEvents: scrollable ? undefined : 'none',
      // })}
      onScroll: function(e2) {
        var {
          y
        } = e2.nativeEvent.contentOffset;
        scrollBridge.y = y, y > 0 && (scrollBridge.scrollStartY = -1), onScroll == null ? void 0 : onScroll(e2);
      },
      // This assures that we do not skip the "scrollBridge" values processing
      // when passing this prop into a <Sheet.ScrollView /> overriding it here
      // Useful when using this ScrollView with lists such as "FlashList", i.e.
      // ```
      // renderScrollComponent={Sheet.ScrollView}
      // ```
      onStartShouldSetResponder: function() {
        return scrollBridge.scrollStartY = -1, state.current.isDraggingScrollArea = true, scrollable;
      },
      // setting to false while onResponderMove is disabled
      onMoveShouldSetResponder: function(e2) {
        return scrollable;
      },
      contentContainerStyle: {
        minHeight: "100%"
      },
      onResponderMove: function(e2) {
      }
    }, props), {
      children: [
        /* content height measurer */
        /* @__PURE__ */ jsxRuntimeExports.jsx(View, {
          position: "absolute",
          inset: 0,
          pointerEvents: "none",
          zIndex: -1,
          onLayout: function(e2) {
            contentHeight.current = Math.floor(e2.nativeEvent.layout.height), setIsScrollable();
          }
        }),
        children
      ]
    }));
  }
);
var useSheetOffscreenSize = function(param) {
  var {
    snapPoints,
    position,
    screenSize,
    frameSize,
    snapPointsMode
  } = param;
  if (snapPointsMode === "fit") return 0;
  if (snapPointsMode === "constant") {
    var maxSize = Number(snapPoints[0]), _snapPoints_position, currentSize = Number((_snapPoints_position = snapPoints[position]) !== null && _snapPoints_position !== void 0 ? _snapPoints_position : 0), offscreenSize = maxSize - currentSize;
    return offscreenSize;
  }
  if (snapPointsMode === "percent") {
    var maxPercentOpened = Number(snapPoints[0]) / 100, _snapPoints_position1, percentOpened = Number((_snapPoints_position1 = snapPoints[position]) !== null && _snapPoints_position1 !== void 0 ? _snapPoints_position1 : 0) / 100, percentHidden = maxPercentOpened - percentOpened, offscreenSize1 = percentHidden * screenSize;
    return offscreenSize1;
  }
  var maxSnapPoint = snapPoints[0];
  if (maxSnapPoint === "fit") return 0;
  var maxSize1 = typeof maxSnapPoint == "string" ? Number(maxSnapPoint.slice(0, -1)) / 100 * screenSize : maxSnapPoint, _snapPoints_position2, currentSnapPoint = (_snapPoints_position2 = snapPoints[position]) !== null && _snapPoints_position2 !== void 0 ? _snapPoints_position2 : 0, currentSize1 = typeof currentSnapPoint == "string" ? Number(currentSnapPoint.slice(0, -1)) / 100 * screenSize : currentSnapPoint, offscreenSize2 = maxSize1 - currentSize1;
  return Number.isNaN(offscreenSize2) ? 0 : offscreenSize2;
};
function createSheet(param) {
  var {
    Handle: Handle2,
    Frame: Frame2,
    Overlay: Overlay2
  } = param, SheetHandle = Handle2.styleable(function(param2, forwardedRef) {
    var _a = param2, {
      __scopeSheet
    } = _a, props = __objRest(_a, [
      "__scopeSheet"
    ]), context2 = useSheetContext(SHEET_HANDLE_NAME, __scopeSheet), composedRef = useComposedRefs(context2.handleRef, forwardedRef);
    return context2.onlyShowFrame ? null : (
      // @ts-ignore
      /* @__PURE__ */ jsxRuntimeExports.jsx(Handle2, __spreadValues({
        ref: composedRef,
        onPress: function() {
          var max2 = context2.snapPoints.length + (context2.dismissOnSnapToBottom ? -1 : 0), nextPos = (context2.position + 1) % max2;
          context2.setPosition(nextPos);
        },
        open: context2.open
      }, props))
    );
  }), SheetOverlay = Overlay2.extractable(/* @__PURE__ */ React.memo(function(propsIn) {
    var _a = propsIn, {
      __scopeSheet
    } = _a, props = __objRest(_a, [
      "__scopeSheet"
    ]), context2 = useSheetContext(SHEET_OVERLAY_NAME, __scopeSheet), element = React.useMemo(function() {
      return (
        // @ts-ignore
        /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay2, __spreadProps(__spreadValues({}, props), {
          onPress: composeEventHandlers(props.onPress, context2.dismissOnOverlayPress ? function() {
            context2.setOpen(false);
          } : void 0)
        }))
      );
    }, [props.onPress, props.opacity, context2.dismissOnOverlayPress]);
    return useIsomorphicLayoutEffect(function() {
      var _context_onOverlayComponent;
      (_context_onOverlayComponent = context2.onOverlayComponent) === null || _context_onOverlayComponent === void 0 || _context_onOverlayComponent.call(context2, element);
    }, [element]), context2.onlyShowFrame, null;
  })), SheetFrame = Frame2.extractable(/* @__PURE__ */ React.forwardRef(function(param2, forwardedRef) {
    var _a = param2, {
      __scopeSheet,
      adjustPaddingForOffscreenContent,
      disableHideBottomOverflow,
      children
    } = _a, props = __objRest(_a, [
      "__scopeSheet",
      "adjustPaddingForOffscreenContent",
      "disableHideBottomOverflow",
      "children"
    ]), context2 = useSheetContext(SHEET_NAME, __scopeSheet), {
      hasFit,
      removeScrollEnabled = true,
      frameSize,
      contentRef,
      open: open2
    } = context2, composedContentRef = useComposedRefs(forwardedRef, contentRef), offscreenSize = useSheetOffscreenSize(context2), stableFrameSize = React.useRef(frameSize);
    React.useEffect(function() {
      open2 && frameSize && (stableFrameSize.current = frameSize);
    }, [open2, frameSize]);
    var sheetContents = React.useMemo(function() {
      var shouldUseFixedHeight = hasFit && !open2 && stableFrameSize.current;
      return (
        // @ts-expect-error
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Frame2, __spreadProps(__spreadValues({
          ref: composedContentRef,
          flex: hasFit && open2 ? 0 : 1,
          height: shouldUseFixedHeight ? stableFrameSize.current : hasFit ? void 0 : frameSize,
          pointerEvents: open2 ? "auto" : "none",
          "data-state": open2 ? "open" : "closed"
        }, props), {
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
            zIndex: resolveViewZIndex(props.zIndex),
            children
          }), adjustPaddingForOffscreenContent && /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, {
            "data-sheet-offscreen-pad": true,
            height: offscreenSize,
            width: "100%"
          })]
        }))
      );
    }, [open2, props, frameSize, offscreenSize, adjustPaddingForOffscreenContent, hasFit]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(RemoveScroll, {
          enabled: removeScrollEnabled && context2.open,
          children: sheetContents
        }),
        /* below frame hide when bouncing past 100% */
        !disableHideBottomOverflow && // @ts-ignore
        /* @__PURE__ */ jsxRuntimeExports.jsx(Frame2, __spreadProps(__spreadValues({}, props), {
          "data-testid": "ensure-sheet-cover-not-overlapping",
          componentName: "SheetCover",
          // biome-ignore lint/correctness/noChildrenProp: <explanation>
          children: null,
          position: "absolute",
          bottom: "-100%",
          zIndex: -1,
          height: context2.frameSize,
          left: 0,
          right: 0,
          borderWidth: 0,
          borderRadius: 0,
          shadowOpacity: 0
        }))
      ]
    });
  })), Sheet2 = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    useDidFinishSSR();
    var {
      isShowingNonSheet
    } = useSheetController(), SheetImplementation = SheetImplementationCustom;
    if (props.native && Platform.OS === "ios") ;
    return isShowingNonSheet || false ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(SheetImplementation, __spreadValues({
      ref
    }, props));
  }), components = {
    Frame: SheetFrame,
    Overlay: SheetOverlay,
    Handle: SheetHandle,
    ScrollView: SheetScrollView
  }, Controlled = withStaticProperties(Sheet2, components);
  return withStaticProperties(Sheet2, __spreadProps(__spreadValues({}, components), {
    Controlled
  }));
}
var Handle = styled(XStack, {
  name: SHEET_HANDLE_NAME,
  variants: {
    open: {
      true: {
        opacity: 1,
        pointerEvents: "auto"
      },
      false: {
        opacity: 0,
        pointerEvents: "none"
      }
    },
    unstyled: {
      false: {
        height: 10,
        borderRadius: 100,
        backgroundColor: "$background",
        zIndex: 10,
        marginHorizontal: "35%",
        marginBottom: "$2",
        opacity: 0.5,
        hoverStyle: {
          opacity: 0.7
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Overlay = styled(ThemeableStack, {
  name: SHEET_OVERLAY_NAME,
  variants: {
    open: {
      true: {
        pointerEvents: "auto"
      },
      false: {
        pointerEvents: "none"
      }
    },
    unstyled: {
      false: {
        fullscreen: true,
        position: "absolute",
        backgrounded: true,
        zIndex: 99999,
        pointerEvents: "auto"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Frame = styled(YStack, {
  name: SHEET_NAME,
  variants: {
    unstyled: {
      false: {
        flex: 1,
        backgroundColor: "$background",
        borderTopLeftRadius: "$true",
        borderTopRightRadius: "$true",
        width: "100%",
        maxHeight: "100%",
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Sheet = createSheet({
  Frame,
  Handle,
  Overlay
}), SheetOverlayFrame = Overlay, SheetHandleFrame = Handle;
var useSheet = function() {
  return useSheetContext("", void 0);
};
var SheetController = function(param) {
  var {
    children,
    onOpenChange: onOpenChangeProp,
    open: open2,
    hidden,
    disableDrag
  } = param, onOpenChange = useEvent$1(onOpenChangeProp), id2 = React.useId(), memoValue = React.useMemo(function() {
    return {
      id: id2,
      open: open2,
      hidden,
      disableDrag,
      onOpenChange
    };
  }, [id2, onOpenChange, open2, hidden, disableDrag]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetControllerContext.Provider, {
    value: memoValue,
    children
  });
};
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
var DialogContext = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "Dialog__"
), {
  useStyledContext: useDialogContext,
  Provider: DialogProvider
} = DialogContext, DialogTriggerFrame = styled(View, {
  name: "DialogTrigger"
}), DialogTrigger = DialogTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, triggerProps = __objRest(_a, [
    "scope"
  ]), isInsideButton = React__namespace.useContext(ButtonNestingContext), context2 = useDialogContext(scope), composedTriggerRef = useComposedRefs(forwardedRef, context2.triggerRef);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonNestingContext.Provider, {
    value: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTriggerFrame, __spreadProps(__spreadValues({
      tag: isInsideButton ? "span" : "button",
      "aria-haspopup": "dialog",
      "aria-expanded": context2.open,
      "aria-controls": context2.contentId,
      "data-state": getState$2(context2.open)
    }, triggerProps), {
      ref: composedTriggerRef,
      onPress: composeEventHandlers(props.onPress, context2.onOpenToggle)
    }))
  });
}), DialogPortalFrame = styled(YStack, {
  pointerEvents: "none",
  tag: "dialog",
  variants: {
    unstyled: {
      false: {
        alignItems: "center",
        justifyContent: "center",
        fullscreen: true,
        "$platform-web": {
          // undo dialog styles
          borderWidth: 0,
          backgroundColor: "transparent",
          color: "inherit",
          maxInlineSize: "none",
          margin: 0,
          width: "auto",
          height: "auto",
          // ensure always in frame and right height
          maxHeight: "100vh",
          position: "fixed",
          // ensure dialog inherits stacking context from portal wrapper
          zIndex: 1
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), needsRepropagation$1 = isAndroid || isIos && !USE_NATIVE_PORTAL, DialogPortalItem = function(param) {
  var {
    context: context2,
    children
  } = param, themeName = useThemeName(), isAdapted = useAdaptIsActive(context2.adaptScope), adaptContext = useAdaptContext(context2.adaptScope), content = /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
    name: themeName,
    children
  });
  return needsRepropagation$1 && (content = /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, __spreadProps(__spreadValues({}, adaptContext), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, __spreadProps(__spreadValues({}, context2), {
      children: content
    }))
  }))), isAdapted ? /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
    scope: context2.adaptScope,
    children: content
  }) : context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(GorhomPortalItem, {
    hostName: context2.modal ? "root" : context2.adaptScope,
    children: content
  }) : content;
}, DialogPortal = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardRef) {
  var _a = props, {
    scope,
    forceMount,
    children
  } = _a, frameProps = __objRest(_a, [
    "scope",
    "forceMount",
    "children"
  ]), dialogRef = React__namespace.useRef(null), ref = composeRefs(dialogRef, forwardRef), context2 = useDialogContext(scope), isMountedOrOpen = forceMount || context2.open, [isFullyHidden, setIsFullyHidden] = React__namespace.useState(!isMountedOrOpen), isAdapted = useAdaptIsActive(context2.adaptScope);
  isMountedOrOpen && isFullyHidden && setIsFullyHidden(false);
  var handleExitComplete = React__namespace.useCallback(function() {
    setIsFullyHidden(true);
  }, []), zIndex = getExpandedShorthand("zIndex", props), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
    zIndex: resolveViewZIndex(zIndex),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, {
      passThrough: isAdapted,
      onExitComplete: handleExitComplete,
      children: isMountedOrOpen || isAdapted ? children : null
    })
  }), framedContents = (
    // NOTE: we remove the inner frame, but not the portal itself
    // saw a bug when we removed and re-added portals that caused stale inner contents of the portal
    // seems like a React bug itself but leaving this for now as it fixes
    isFullyHidden && !isAdapted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMeasurementController, {
      disable: !isMountedOrOpen,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortalFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
        ref
      }, isWeb), {
        // passThrough={isAdapted}
        pointerEvents: isMountedOrOpen ? "auto" : "none"
      }), frameProps), {
        className: "_no_backdrop " + (frameProps.className || ""),
        children: contents
      }))
    })
  );
  return isAdapted ? framedContents : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortalItem, {
    context: context2,
    children: framedContents
  });
}), OVERLAY_NAME$1 = "DialogOverlay", DialogOverlayFrame = styled(Overlay, {
  name: OVERLAY_NAME$1
}), DialogOverlay = DialogOverlayFrame.styleable(function(param, forwardedRef) {
  var _a = param, {
    scope
  } = _a, props = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope), _b = props, {
    forceMount = context2.forceMount
  } = _b, overlayProps = __objRest(_b, [
    "forceMount"
  ]), isAdapted = useAdaptIsActive(context2.adaptScope);
  return !forceMount && (!context2.modal || isAdapted) ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayFrame, __spreadProps(__spreadValues({
    "data-state": getState$2(context2.open),
    // TODO: this will be apply for v2
    // onPress={() => {
    //   // if the overlay is pressed, close the dialog
    //   context.onOpenChange(false)
    // }}
    // We re-enable pointer-events prevented by `Dialog.Content` to allow scrolling the overlay.
    pointerEvents: context2.open ? "auto" : "none"
  }, overlayProps), {
    ref: forwardedRef
  }));
}), CONTENT_NAME$2 = "DialogContent", DialogContentFrame = styled(ThemeableStack, {
  name: CONTENT_NAME$2,
  variants: {
    size: {
      "...size": function(val, extras) {
        return {};
      }
    },
    unstyled: {
      false: {
        position: "relative",
        backgrounded: true,
        padded: true,
        radiused: true,
        elevate: true,
        zIndex: 1e5
      }
    }
  },
  defaultVariants: {
    size: "$true",
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), DialogContent = DialogContentFrame.styleable(function(param, forwardedRef) {
  var _a = param, {
    scope
  } = _a, props = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope), _b = props, {
    forceMount = context2.forceMount
  } = _b, contentProps = __objRest(_b, [
    "forceMount"
  ]), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: context2.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, __spreadProps(__spreadValues({
      context: context2
    }, contentProps), {
      ref: forwardedRef
    })) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, __spreadProps(__spreadValues({
      context: context2
    }, contentProps), {
      ref: forwardedRef
    }))
  });
  return contents;
}), DialogContentModal = /* @__PURE__ */ React__namespace.forwardRef(function(param, forwardedRef) {
  var _a = param, {
    children,
    context: context2
  } = _a, props = __objRest(_a, [
    "children",
    "context"
  ]), contentRef = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, context2.contentRef, contentRef);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentImpl, __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, props), {
    context: context2,
    ref: composedRefs,
    // we make sure focus isn't trapped once `DialogContent` has been closed
    // (closed !== unmounted when animating out)
    trapFocus: context2.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, function(event) {
      var _context_triggerRef_current;
      event.preventDefault(), (_context_triggerRef_current = context2.triggerRef.current) === null || _context_triggerRef_current === void 0 || _context_triggerRef_current.focus();
    }),
    onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, function(event) {
      var originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClick && event.preventDefault();
    }),
    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    onFocusOutside: composeEventHandlers(props.onFocusOutside, function(event) {
      return event.preventDefault();
    })
  }), !props.unstyled && {
    outlineStyle: "none"
  }), {
    children
  }));
}), DialogContentNonModal = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var hasInteractedOutsideRef = React__namespace.useRef(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentImpl, __spreadProps(__spreadValues({}, props), {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: function(event) {
      var _props_onCloseAutoFocus;
      if ((_props_onCloseAutoFocus = props.onCloseAutoFocus) === null || _props_onCloseAutoFocus === void 0 || _props_onCloseAutoFocus.call(props, event), !event.defaultPrevented) {
        if (!hasInteractedOutsideRef.current) {
          var _props_context_triggerRef_current;
          (_props_context_triggerRef_current = props.context.triggerRef.current) === null || _props_context_triggerRef_current === void 0 || _props_context_triggerRef_current.focus();
        }
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: function(event) {
      var _props_onInteractOutside;
      (_props_onInteractOutside = props.onInteractOutside) === null || _props_onInteractOutside === void 0 || _props_onInteractOutside.call(props, event), event.defaultPrevented || (hasInteractedOutsideRef.current = true);
      var target = event.target, trigger = props.context.triggerRef.current;
      if (_instanceof(trigger, HTMLElement)) {
        var targetIsTrigger = trigger.contains(target);
        targetIsTrigger && event.preventDefault();
      }
    }
  }));
}), DialogContentImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    trapFocus,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    context: context2
  } = _a, contentProps = __objRest(_a, [
    "trapFocus",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "disableOutsidePointerEvents",
    "onEscapeKeyDown",
    "onPointerDownOutside",
    "onFocusOutside",
    "onInteractOutside",
    "context"
  ]), contentRef = React__namespace.useRef(
    // TODO react 19 type workaround
    void 0
  ), composedRefs = useComposedRefs(forwardedRef, contentRef), isAdapted = useAdaptIsActive(context2.adaptScope);
  if (isAdapted) return !context2.open ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortalItem, {
    context: context2,
    children: contentProps.children
  });
  var contents = /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentFrame, __spreadValues({
    ref: composedRefs,
    id: context2.contentId,
    "aria-describedby": context2.descriptionId,
    "aria-labelledby": context2.titleId,
    "data-state": getState$2(context2.open)
  }, contentProps));
  return contents;
}), DialogTitleFrame = styled(H2, {
  name: "DialogTitle"
}), DialogTitle = DialogTitleFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, titleProps = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleFrame, __spreadProps(__spreadValues({
    id: context2.titleId
  }, titleProps), {
    ref: forwardedRef
  }));
}), DialogDescriptionFrame = styled(Paragraph, {
  name: "DialogDescription"
}), DialogDescription = DialogDescriptionFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, descriptionProps = __objRest(_a, [
    "scope"
  ]), context2 = useDialogContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescriptionFrame, __spreadProps(__spreadValues({
    id: context2.descriptionId
  }, descriptionProps), {
    ref: forwardedRef
  }));
}), CLOSE_NAME = "DialogClose", DialogCloseFrame = styled(View, {
  name: CLOSE_NAME,
  tag: "button"
}), DialogClose = DialogCloseFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope,
    displayWhenAdapted
  } = _a, closeProps = __objRest(_a, [
    "scope",
    "displayWhenAdapted"
  ]), context2 = useDialogContext(scope), isAdapted = useAdaptIsActive(context2.adaptScope), isInsideButton = React__namespace.useContext(ButtonNestingContext);
  return isAdapted && !displayWhenAdapted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogCloseFrame, __spreadProps(__spreadValues({
    accessibilityLabel: "Dialog Close",
    tag: isInsideButton ? "span" : "button"
  }, closeProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers(props.onPress, function() {
      context2.onOpenChange(false);
    })
  }));
});
function getState$2(open2) {
  return open2 ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning", [DialogWarningProvider, useWarningContext] = createContext(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$2,
  titleName: "DialogTitle",
  docsSlug: "dialog"
}), Dialog = withStaticProperties(/* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
  var {
    scope = "",
    children,
    open: openProp,
    defaultOpen = false,
    onOpenChange,
    modal = true,
    disableRemoveScroll = false
  } = props, baseId = React__namespace.useId(), dialogId = `Dialog-${scope}-${baseId}`, contentId = `${dialogId}-content`, titleId = `${dialogId}-title`, descriptionId = `${dialogId}-description`, triggerRef = React__namespace.useRef(null), contentRef = React__namespace.useRef(null), [open2, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  }), onOpenToggle = React__namespace.useCallback(function() {
    setOpen(function(prevOpen) {
      return !prevOpen;
    });
  }, [setOpen]), adaptScope = `DialogAdapt${scope}`, context2 = {
    dialogScope: scope,
    adaptScope,
    triggerRef,
    contentRef,
    contentId,
    titleId,
    descriptionId,
    open: open2,
    onOpenChange: setOpen,
    onOpenToggle,
    modal,
    disableRemoveScroll
  };
  return React__namespace.useImperativeHandle(ref, function() {
    return {
      open: setOpen
    };
  }, [setOpen]), /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptParent, {
    scope: adaptScope,
    portal: {
      forwardProps: props
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogProvider, __spreadProps(__spreadValues({
      scope
    }, context2), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogSheetController, {
        onOpenChange: setOpen,
        scope,
        children
      })
    }))
  });
}), {
  Trigger: DialogTrigger,
  Portal: DialogPortal,
  Overlay: DialogOverlay,
  Content: DialogContent,
  Title: DialogTitle,
  Description: DialogDescription,
  Close: DialogClose,
  Sheet: Sheet.Controlled,
  FocusScope: FocusScopeControllerComponent,
  Adapt
});
var DialogSheetController = function(props) {
  var context2 = useDialogContext(props.scope), isAdapted = useAdaptIsActive(context2.adaptScope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetController, {
    onOpenChange: function(val) {
      if (isAdapted) {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
      }
    },
    open: context2.open,
    hidden: !isAdapted,
    children: props.children
  });
};
var getAlertDialogScope = function(scope) {
  return scope;
}, ROOT_NAME = "AlertDialog", TRIGGER_NAME$3 = "AlertDialogTrigger", NativeAlertDialogTriggerFrame = styled(View, {
  name: TRIGGER_NAME$3
}), AlertDialogTrigger = NativeAlertDialogTriggerFrame.styleable(function(props, forwardedRef) {
  if (props.__native) {
    var _a = props, {
      __native,
      onPress,
      __onPress
    } = _a, rest = __objRest(_a, [
      "__native",
      "onPress",
      "__onPress"
    ]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(NativeAlertDialogTriggerFrame, __spreadProps(__spreadValues({}, rest), {
      onPress: composeEventHandlers(onPress, __onPress)
    }));
  }
  var _b = props, {
    scope
  } = _b, triggerProps = __objRest(_b, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, triggerProps), {
    ref: forwardedRef
  }));
});
var AlertDialogPortal = function(props) {
  var _a = props, {
    scope
  } = _a, portalProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPortal, __spreadValues({
    scope: getAlertDialogScope(scope)
  }, portalProps));
}, OVERLAY_NAME = "AlertDialogOverlay", AlertDialogOverlayFrame = styled(DialogOverlayFrame, {
  name: OVERLAY_NAME
}), AlertDialogOverlay = AlertDialogOverlayFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, overlayProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, overlayProps), {
    ref: forwardedRef
  }));
}), CONTENT_NAME$1 = "AlertDialogContent", {
  Provider: AlertDialogContextProvider,
  useStyledContext: useAlertDialogContentContext
} = createStyledContext({}, "AlertDialogContext"), AlertDialogContent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope,
    children
  } = _a, contentProps = __objRest(_a, [
    "scope",
    "children"
  ]), dialogScope = getAlertDialogScope(scope), contentRef = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), cancelRef = React__namespace.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogWarningProvider, {
    contentName: CONTENT_NAME$1,
    titleName: TITLE_NAME,
    docsSlug: "alert-dialog",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogContextProvider, {
      scope,
      cancelRef,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, __spreadProps(__spreadValues({
        role: "alertdialog",
        "aria-modal": true,
        scope: dialogScope
      }, contentProps), {
        ref: composedRefs,
        onOpenAutoFocus: composeEventHandlers(contentProps.onOpenAutoFocus, function(event) {
          if (event.preventDefault(), isWeb) ;
        }),
        onPointerDownOutside: function(event) {
          return event.preventDefault();
        },
        onInteractOutside: function(event) {
          return event.preventDefault();
        },
        children: [
          /**
          * We have to use `Slottable` here as we cannot wrap the `AlertDialogContentProvider`
          * around everything, otherwise the `DescriptionWarning` would be rendered straight away.
          * This is because we want the accessibility checks to run only once the content is actually
          * open and that behaviour is already encapsulated in `DialogContent`.
          */
          /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, {
            children
          }),
          false
        ]
      }))
    })
  });
}), TITLE_NAME = "AlertDialogTitle", AlertDialogTitleFrame = styled(View, {
  name: TITLE_NAME
}), AlertDialogTitle = AlertDialogTitleFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, titleProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, titleProps), {
    ref: forwardedRef
  }));
}), DESCRIPTION_NAME = "AlertDialogDescription", AlertDialogDescriptionFrame = styled(View, {
  name: DESCRIPTION_NAME
}), AlertDialogDescription = AlertDialogDescriptionFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, descriptionProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, descriptionProps), {
    ref: forwardedRef
  }));
}), ACTION_NAME = "AlertDialogAction", AlertDialogActionFrame = styled(View, {
  name: ACTION_NAME
}), AlertDialogAction = AlertDialogActionFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, actionProps = __objRest(_a, [
    "scope"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, actionProps), {
    ref: forwardedRef
  }));
}), CANCEL_NAME = "AlertDialogCancel", AlertDialogCancelFrame = styled(View, {
  name: CANCEL_NAME
}), AlertDialogCancel = AlertDialogCancelFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, cancelProps = __objRest(_a, [
    "scope"
  ]), {
    cancelRef
  } = useAlertDialogContentContext(scope), ref = useComposedRefs(forwardedRef, cancelRef);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogClose, __spreadProps(__spreadValues({
    scope: getAlertDialogScope(scope)
  }, cancelProps), {
    ref
  }));
}), AlertDialogInner = function(props) {
  var _a = props, {
    scope,
    native
  } = _a, alertDialogProps = __objRest(_a, [
    "scope",
    "native"
  ]), dialogScope = getAlertDialogScope(scope), [open2, setOpen] = useControllableState({
    prop: props.open,
    defaultProp: props.defaultOpen || false,
    onChange: props.onOpenChange,
    transition: true
  }), triggerElement = null, title = "", description = "", buttons = [];
  return forEachChildDeep(React__namespace.Children.toArray(props.children), function(child) {
    if (!/* @__PURE__ */ React__namespace.isValidElement(child)) return false;
    var name = isTamaguiElement(child) ? child.type.staticConfig.componentName : child.type.displayName;
    switch (name) {
      case TRIGGER_NAME$3:
        return triggerElement = /* @__PURE__ */ React__namespace.cloneElement(child, {
          __native: true
        }), false;
      case TITLE_NAME:
        return title = getStringChildren(child), false;
      case DESCRIPTION_NAME:
        return description = getStringChildren(child), false;
      case ACTION_NAME:
      case CANCEL_NAME: {
        var style = name === ACTION_NAME ? "default" : "cancel", text = getStringChildren(child), onPress = function() {
          var _childProps_onPress, childProps = child.props;
          childProps == null || (_childProps_onPress = childProps.onPress) === null || _childProps_onPress === void 0 || _childProps_onPress.call(childProps, {
            native: true
          }), setOpen(false);
        };
        return buttons.push({
          style,
          text,
          // @ts-ignore
          onPress
        }), false;
      }
      default:
        return true;
    }
  }), useIsomorphicLayoutEffect(function() {
  }, [native, open2]), native ? /* @__PURE__ */ React__namespace.cloneElement(triggerElement, {
    __onPress: function() {
      setOpen(true);
    }
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, __spreadProps(__spreadValues({
    scope: dialogScope
  }, alertDialogProps), {
    modal: true
  }));
};
function forEachChildDeep(children, onChild) {
  var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var child = _step.value;
      if (/* @__PURE__ */ React__namespace.isValidElement(child) && onChild(child)) {
        var childProps = child.props;
        childProps.children && forEachChildDeep(React__namespace.Children.toArray(childProps.children), onChild);
      }
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
}
function getStringChildren(child) {
  var string = "";
  return forEachChildDeep(React__namespace.Children.toArray(child), function(child2) {
    return typeof child2.props.children == "string" ? (string = child2.props.children, false) : true;
  }), string;
}
var AlertDialog = withStaticProperties(AlertDialogInner, {
  Trigger: AlertDialogTrigger,
  Portal: AlertDialogPortal,
  Overlay: AlertDialogOverlay,
  Content: AlertDialogContent,
  Action: AlertDialogAction,
  Cancel: AlertDialogCancel,
  Title: AlertDialogTitle,
  Description: AlertDialogDescription
});
AlertDialog.displayName = ROOT_NAME;
function _type_of$1(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var StyledImage = styled(ImageWithStatics, {
  name: "Image"
}), Image = StyledImage.styleable(function(inProps, ref) {
  var [props, style] = usePropsAndStyle(inProps), _a = props, {
    src,
    source,
    objectFit
  } = _a, rest = __objRest(_a, [
    "src",
    "source",
    "objectFit"
  ]);
  var finalSource = typeof src == "string" ? __spreadValues({
    uri: src
  }, isWeb) : source != null ? source : src;
  if (finalSource && (typeof finalSource > "u" ? "undefined" : _type_of$1(finalSource)) === "object") {
    if (!Array.isArray(finalSource) && typeof finalSource.uri == "number" && (finalSource = finalSource.uri, source && (typeof source > "u" ? "undefined" : _type_of$1(source)) === "object" && !Array.isArray(source))) {
      var _style, _style1, _width;
      (_width = (_style = style).width) !== null && _width !== void 0 || (_style.width = source.width);
      var _height;
      (_height = (_style1 = style).height) !== null && _height !== void 0 || (_style1.height = source.height);
    }
    finalSource.default && (finalSource = finalSource.default);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageWithStatics, __spreadValues({
    resizeMode: objectFit,
    ref,
    source: finalSource,
    style
  }, rest));
});
Image.getSize = ImageWithStatics.getSize;
Image.getSizeWithHeaders = ImageWithStatics.getSizeWithHeaders;
Image.prefetch = ImageWithStatics.prefetch;
Image.prefetchWithMetadata = ImageWithStatics.prefetchWithMetadata;
Image.abortPrefetch = ImageWithStatics.abortPrefetch;
Image.queryCache = ImageWithStatics.queryCache;
var getShapeSize = function(size, param) {
  var {
    tokens
  } = param, _tokens_size_size, width = (_tokens_size_size = tokens.size[size]) !== null && _tokens_size_size !== void 0 ? _tokens_size_size : size, _tokens_size_size1, height = (_tokens_size_size1 = tokens.size[size]) !== null && _tokens_size_size1 !== void 0 ? _tokens_size_size1 : size;
  return {
    width,
    height,
    minWidth: width,
    maxWidth: width,
    maxHeight: height,
    minHeight: height
  };
};
var Square = styled(ThemeableStack, {
  name: "Square",
  alignItems: "center",
  justifyContent: "center",
  variants: {
    size: {
      "...size": getShapeSize,
      ":number": getShapeSize
    }
  }
}, {
  memo: true
});
var Circle = styled(Square, {
  name: "Circle",
  circular: true
});
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
var AVATAR_NAME = "Avatar", [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME), [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME), IMAGE_NAME = "AvatarImage", AvatarImage = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _getShapeSize, _a = props, {
    __scopeAvatar,
    src,
    source,
    onLoadingStatusChange = function() {
    }
  } = _a, imageProps = __objRest(_a, [
    "__scopeAvatar",
    "src",
    "source",
    "onLoadingStatusChange"
  ]), context2 = useAvatarContext(IMAGE_NAME, __scopeAvatar), [status, setStatus] = React__namespace.useState("idle"), shapeSize = getVariableValue((_getShapeSize = getShapeSize(
    context2.size,
    // @ts-expect-error
    {
      tokens: getTokens()
    }
  )) === null || _getShapeSize === void 0 ? void 0 : _getShapeSize.width), resolvedSrc = src || (source && (typeof source > "u" ? "undefined" : _type_of(source)) === "object" && "uri" in source ? source.uri : source);
  return React__namespace.useEffect(function() {
    setStatus(resolvedSrc ? "idle" : "error");
  }, [resolvedSrc]), React__namespace.useEffect(function() {
    onLoadingStatusChange(status), context2.onImageLoadingStatusChange(status);
  }, [status]), resolvedSrc ? /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, {
    fullscreen: true,
    zIndex: 1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, __spreadProps(__spreadValues(__spreadValues({
      fullscreen: true
    }, typeof shapeSize == "number" && !Number.isNaN(shapeSize) && {
      width: shapeSize,
      height: shapeSize
    }), imageProps), {
      // @ts-ignore
      ref: forwardedRef,
      // @ts-ignore
      src: resolvedSrc,
      // onLoadStart={() => {
      //   // setStatus('loading')
      // }}
      onError: function() {
        setStatus("error");
      },
      onLoad: function() {
        setStatus("loaded");
      }
    }))
  }) : null;
});
AvatarImage.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback", AvatarFallbackFrame = styled(YStack, {
  name: FALLBACK_NAME,
  position: "absolute",
  fullscreen: true,
  zIndex: 0
}), AvatarFallback = AvatarFallbackFrame.extractable(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAvatar,
    delayMs
  } = _a, fallbackProps = __objRest(_a, [
    "__scopeAvatar",
    "delayMs"
  ]), context2 = useAvatarContext(FALLBACK_NAME, __scopeAvatar), [canRender, setCanRender] = React__namespace.useState(delayMs === void 0);
  return React__namespace.useEffect(function() {
    if (delayMs !== void 0) {
      var timerId = setTimeout(function() {
        return setCanRender(true);
      }, delayMs);
      return function() {
        return clearTimeout(timerId);
      };
    }
  }, [delayMs]), canRender && context2.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallbackFrame, __spreadProps(__spreadValues({}, fallbackProps), {
    ref: forwardedRef
  })) : null;
}));
AvatarFallback.displayName = FALLBACK_NAME;
var AvatarFrame = styled(Square, {
  name: AVATAR_NAME,
  position: "relative",
  overflow: "hidden"
}), Avatar = withStaticProperties(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeAvatar,
    size = "$true"
  } = _a, avatarProps = __objRest(_a, [
    "__scopeAvatar",
    "size"
  ]), [imageLoadingStatus, setImageLoadingStatus] = React__namespace.useState("idle");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarProvider, {
    size,
    scope: __scopeAvatar,
    imageLoadingStatus,
    onImageLoadingStatusChange: setImageLoadingStatus,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFrame, __spreadProps(__spreadValues({
      size
    }, avatarProps), {
      ref: forwardedRef
    }))
  });
}), {
  Image: AvatarImage,
  Fallback: AvatarFallback
});
Avatar.displayName = AVATAR_NAME;
var getFontSize = function(inSize, opts2) {
  var res = getFontSizeVariable(inSize, opts2);
  return isVariable(res) ? +res.val : res ? +res : 16;
}, getFontSizeVariable = function(inSize, opts2) {
  var token = getFontSizeToken(inSize, opts2);
  if (!token) return inSize;
  var conf2 = getConfig(), font = conf2.fontsParsed[(opts2 == null ? void 0 : opts2.font) || conf2.defaultFontToken];
  return font == null ? void 0 : font.size[token];
}, getFontSizeToken = function(inSize, opts2) {
  if (typeof inSize == "number") return null;
  var relativeSize = (opts2 == null ? void 0 : opts2.relativeSize) || 0, conf2 = getConfig(), font = conf2.fontsParsed[(opts2 == null ? void 0 : opts2.font) || conf2.defaultFontToken], fontSize = (font == null ? void 0 : font.size) || // fallback to size tokens
  conf2.tokensParsed.size, _ref, size = (_ref = inSize === "$true" && !("$true" in fontSize) ? "$4" : inSize) !== null && _ref !== void 0 ? _ref : "$true" in fontSize ? "$true" : "$4", sizeTokens = Object.keys(fontSize), foundIndex = sizeTokens.indexOf(size);
  foundIndex === -1 && size.endsWith(".5") && (foundIndex = sizeTokens.indexOf(size.replace(".5", "")));
  var tokenIndex = Math.min(Math.max(0, foundIndex + relativeSize), sizeTokens.length - 1), _sizeTokens_tokenIndex;
  return (_sizeTokens_tokenIndex = sizeTokens[tokenIndex]) !== null && _sizeTokens_tokenIndex !== void 0 ? _sizeTokens_tokenIndex : size;
};
var prevent = function(e2) {
  return [e2.preventDefault(), e2.stopPropagation()];
};
var useCurrentColor = function(colorProp) {
  var _theme_colorProp, _theme_color, theme = useTheme(), out = colorProp ? getVariable(colorProp) : ((_theme_colorProp = theme[colorProp]) === null || _theme_colorProp === void 0 ? void 0 : _theme_colorProp.get()) || ((_theme_color = theme.color) === null || _theme_color === void 0 ? void 0 : _theme_color.get());
  return out;
};
var useGetThemedIcon = function(props) {
  var color = useCurrentColor(props.color);
  return function(el) {
    return el && (/* @__PURE__ */ React.isValidElement(el) ? /* @__PURE__ */ React.cloneElement(el, __spreadValues(__spreadProps(__spreadValues({}, props), {
      color
    }), el.props)) : /* @__PURE__ */ React.createElement(el, props));
  };
};
var ButtonContext = createStyledContext({
  // keeping these here means they work with styled() passing down color to text
  color: void 0,
  ellipse: void 0,
  fontFamily: void 0,
  fontSize: void 0,
  fontStyle: void 0,
  fontWeight: void 0,
  letterSpacing: void 0,
  maxFontSizeMultiplier: void 0,
  size: void 0,
  textAlign: void 0,
  variant: void 0
}), BUTTON_NAME = "Button", ButtonFrame = styled(ThemeableStack, {
  name: BUTTON_NAME,
  tag: "button",
  context: ButtonContext,
  role: "button",
  focusable: true,
  // forces runtime pressStyle so it passes through context text colors
  disableClassName: true,
  variants: {
    unstyled: {
      false: {
        size: "$true",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "nowrap",
        flexDirection: "row",
        cursor: "pointer",
        hoverTheme: true,
        pressTheme: true,
        backgrounded: true,
        borderWidth: 1,
        borderColor: "transparent",
        focusVisibleStyle: {
          outlineColor: "$outlineColor",
          outlineStyle: "solid",
          outlineWidth: 2
        }
      }
    },
    variant: {
      outlined: {
        backgroundColor: "transparent",
        borderWidth: 2,
        borderColor: "$borderColor",
        hoverStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorHover"
        },
        pressStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorPress"
        },
        focusVisibleStyle: {
          backgroundColor: "transparent",
          borderColor: "$borderColorFocus"
        }
      }
    },
    size: {
      "...size": getButtonSized,
      ":number": getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ButtonText = styled(SizableText, {
  name: "Button",
  context: ButtonContext,
  variants: {
    unstyled: {
      false: {
        userSelect: "none",
        cursor: "pointer",
        // flexGrow 1 leads to inconsistent native style where text pushes to start of view
        flexGrow: 0,
        flexShrink: 1,
        ellipse: true,
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ButtonIcon = function(props) {
  var {
    children,
    scaleIcon = 1
  } = props, {
    size,
    color
  } = React.useContext(ButtonContext), iconSize = (typeof size == "number" ? size * 0.5 : getFontSize(size)) * scaleIcon, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color
  });
  return getThemedIcon(children);
}, ButtonComponent = ButtonFrame.styleable(function(props, ref) {
  var {
    props: buttonProps
  } = useButton(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonFrame, __spreadProps(__spreadValues({
    "data-disable-theme": true
  }, buttonProps), {
    ref
  }));
}), Button2 = withStaticProperties(ButtonComponent, {
  Text: ButtonText,
  Icon: ButtonIcon
});
function useButton(param) {
  var _a = param, {
    textProps
  } = _a, propsIn = __objRest(_a, [
    "textProps"
  ]), {
    Text: Text2 = Button2.Text
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    Text: Button2.Text
  }, isNested = React.useContext(ButtonNestingContext), propsActive = useProps(propsIn, {
    noNormalize: true,
    noExpand: true
  }), _b = propsActive, {
    icon,
    iconAfter,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 0.66,
    separator,
    noTextWrap,
    fontFamily,
    fontSize,
    fontWeight,
    fontStyle,
    letterSpacing,
    tag,
    ellipse,
    maxFontSizeMultiplier
  } = _b, restProps = __objRest(_b, [
    "icon",
    "iconAfter",
    "space",
    "spaceFlex",
    "scaleIcon",
    "scaleSpace",
    "separator",
    "noTextWrap",
    "fontFamily",
    "fontSize",
    "fontWeight",
    "fontStyle",
    "letterSpacing",
    "tag",
    "ellipse",
    "maxFontSizeMultiplier"
  ]), size = propsActive.size || (propsActive.unstyled ? void 0 : "$true"), color = propsActive.color, iconSize = (typeof size == "number" ? size * 0.5 : getFontSize(size, {
    font: (fontFamily == null ? void 0 : fontFamily[0]) === "$" ? fontFamily : void 0
  })) * scaleIcon, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color
  }), [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon), spaceSize = space != null ? space : getVariableValue(iconSize) * scaleSpace, contents = noTextWrap ? [propsIn.children] : wrapChildrenInText(Text2, {
    children: propsIn.children,
    color,
    fontFamily,
    fontSize,
    textProps,
    fontWeight,
    fontStyle,
    letterSpacing,
    maxFontSizeMultiplier
  }, Text2 === ButtonText && propsActive.unstyled !== true ? {
    unstyled: process.env.TAMAGUI_HEADLESS === "1",
    size
  } : void 0), inner = spacedChildren({
    // a bit arbitrary but scaling to font size is necessary so long as button does
    space: spaceSize === false ? 0 : spaceSize == true ? "$true" : spaceSize,
    spaceFlex,
    ensureKeys: true,
    separator,
    direction: propsActive.flexDirection === "column" || propsActive.flexDirection === "column-reverse" ? "vertical" : "horizontal",
    // for keys to stay the same we keep indices as similar a possible
    // so even if icons are undefined we still pass them
    children: [themedIcon, ...contents, themedIconAfter]
  }), props = __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    size
  }, propsIn.disabled && {
    // in rnw - false still has keyboard tabIndex, undefined = not actually focusable
    focusable: void 0,
    // even with tabIndex unset, it will keep focusVisibleStyle on web so disable it here
    focusVisibleStyle: {
      borderColor: "$background"
    }
  }), {
    // fixes SSR issue + DOM nesting issue of not allowing button in button
    tag: tag != null ? tag : isNested ? "span" : (
      // defaults to <a /> when accessibilityRole = link
      // see https://github.com/tamagui/tamagui/issues/505
      propsActive.accessibilityRole === "link" || propsActive.role === "link" ? "a" : "button"
    )
  }), restProps), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonNestingContext.Provider, {
      value: true,
      children: inner
    }),
    // forces it to be a runtime pressStyle so it passes through context text colors
    disableClassName: true
  });
  return {
    spaceSize,
    isNested,
    props
  };
}
var CardContext = createStyledContext({
  size: "$true"
}), CardFrame = styled(ThemeableStack, {
  name: "Card",
  context: CardContext,
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        position: "relative"
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param, _tokens_radius_val;
        return {
          borderRadius: (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : val
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CardHeader = styled(ThemeableStack, {
  name: "CardHeader",
  context: CardContext,
  variants: {
    unstyled: {
      false: {
        zIndex: 10,
        backgroundColor: "transparent",
        marginBottom: "auto"
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param, _tokens_space_val;
        return {
          padding: (_tokens_space_val = tokens.space[val]) !== null && _tokens_space_val !== void 0 ? _tokens_space_val : val
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CardFooter = styled(CardHeader, {
  name: "CardFooter",
  variants: {
    unstyled: {
      false: {
        zIndex: 5,
        flexDirection: "row",
        marginTop: "auto",
        marginBottom: 0
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CardBackground = styled(ThemeableStack, {
  name: "CardBackground",
  variants: {
    unstyled: {
      false: {
        zIndex: 0,
        fullscreen: true,
        overflow: "hidden",
        pointerEvents: "none",
        padding: 0
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Card = withStaticProperties(CardFrame, {
  Header: CardHeader,
  Footer: CardFooter,
  Background: CardBackground
});
var CheckboxStyledContext = createStyledContext({
  size: "$true",
  scaleIcon: 1
});
var INDICATOR_NAME$1 = "CheckboxIndicator", CheckboxIndicatorFrame = styled(ThemeableStack, {
  // use Checkbox for easier themes
  name: INDICATOR_NAME$1,
  context: CheckboxStyledContext,
  variants: {
    unstyled: {
      false: {}
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CHECKBOX_NAME = "Checkbox", CheckboxFrame = styled(ThemeableStack, {
  name: CHECKBOX_NAME,
  tag: "button",
  context: CheckboxStyledContext,
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        pressTheme: true,
        focusable: true,
        borderWidth: 1,
        borderColor: "$borderColor",
        hoverStyle: {
          borderColor: "$borderColorHover"
        },
        focusStyle: {
          borderColor: "$borderColorFocus"
        },
        focusVisibleStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$outlineColor"
        }
      }
    },
    disabled: {
      true: {
        pointerEvents: "none",
        userSelect: "none",
        cursor: "not-allowed",
        hoverStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        pressStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        focusStyle: {
          outlineWidth: 0
        }
      }
    },
    size: {
      "...size": function(val) {
        var radiusToken = getVariableValue(getSize(val)) / 8;
        return {
          borderRadius: radiusToken
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
var InputsMap = /* @__PURE__ */ new Map(), registerFocusable = function(id2, input) {
  return InputsMap.set(id2, input), function() {
    InputsMap.delete(id2);
  };
}, focusFocusable = function(id2) {
  var select = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, input = InputsMap.get(id2);
  if (!input) {
    return;
  }
  select || !input.focusAndSelect ? input.focus() : input.focusAndSelect();
};
var NAME$2 = "Label", [LabelProvider, useLabelContextImpl] = createContext(NAME$2, {
  id: void 0,
  controlRef: {
    current: null
  }
}), LabelFrame = styled(SizableText, {
  name: "Label",
  tag: "label",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        color: "$color",
        backgroundColor: "transparent",
        display: "flex",
        alignItems: "center",
        userSelect: "none",
        cursor: "default",
        pressStyle: {
          color: "$colorPress"
        }
      }
    },
    size: {
      "...size": function(val, extras) {
        var buttonStyle = getButtonSized(val, extras), buttonHeight = buttonStyle == null ? void 0 : buttonStyle.height, fontStyle = getFontSized(val, extras);
        return __spreadProps(__spreadValues({}, fontStyle), {
          lineHeight: buttonHeight ? extras.tokens.size[buttonHeight] : void 0
        });
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), LabelComponent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    htmlFor,
    id: idProp
  } = _a, labelProps = __objRest(_a, [
    "htmlFor",
    "id"
  ]), controlRef = React__namespace.useRef(null), ref = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, ref), backupId = React__namespace.useId(), id2 = idProp != null ? idProp : backupId;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LabelProvider, {
    id: id2,
    controlRef,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(LabelFrame, __spreadProps(__spreadValues({
      id: id2,
      // @ts-ignore
      htmlFor
    }, labelProps), {
      ref: composedRefs,
      onMouseDown: function(event) {
        var _props_onMouseDown;
        (_props_onMouseDown = props.onMouseDown) === null || _props_onMouseDown === void 0 || _props_onMouseDown.call(props, event), !event.defaultPrevented && event.detail > 1 && event.preventDefault();
      },
      onPress: function(event) {
        var _props_onPress;
        if ((_props_onPress = props.onPress) === null || _props_onPress === void 0 || _props_onPress.call(props, event), isWeb) ;
        else props.htmlFor && focusFocusable(props.htmlFor);
      }
    }))
  });
});
LabelComponent.displayName = NAME$2;
var Label = LabelFrame.extractable(themeable(LabelComponent)), useLabelContext = function(element) {
  var context2 = useLabelContextImpl("LabelConsumer"), {
    controlRef
  } = context2;
  return React__namespace.useEffect(function() {
    element && (controlRef.current = element);
  }, [element, controlRef]), context2.id;
};
function usePrevious(value) {
  var ref = React__namespace.useRef({
    value,
    previous: value
  });
  return React__namespace.useMemo(function() {
    return ref.current.value !== value && (ref.current.previous = ref.current.value, ref.current.value = value), ref.current.previous;
  }, [value]);
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function useCheckbox(props, param, ref) {
  var [checked, setChecked] = param, _a = props, {
    labelledBy: ariaLabelledby,
    name,
    required,
    disabled,
    value = "on",
    onCheckedChange
  } = _a, checkboxProps = __objRest(_a, [
    "labelledBy",
    "name",
    "required",
    "disabled",
    "value",
    "onCheckedChange"
  ]), [button, setButton] = React.useState(null), composedRefs = useComposedRefs(ref, setButton);
  React.useRef(false);
  var isFormControl = false, labelId = useLabelContext(button), labelledBy = ariaLabelledby || labelId, parentKeyDown = props.onKeyDown;
  React.useMemo(function() {
    return composeEventHandlers(parentKeyDown, function(event) {
      event.key === "Enter" && event.preventDefault();
    });
  }, [parentKeyDown]);
  var handlePress = React.useMemo(function() {
    return composeEventHandlers(props.onPress, function(event) {
      setChecked(function(prevChecked) {
        return isIndeterminate(prevChecked) ? true : !prevChecked;
      });
    });
  }, [isFormControl]);
  return {
    bubbleInput: null,
    checkboxRef: composedRefs,
    checkboxProps: __spreadProps(__spreadValues(__spreadValues({
      role: "checkbox",
      "aria-labelledby": labelledBy,
      "aria-checked": isIndeterminate(checked) ? "mixed" : checked
    }, checkboxProps), isWeb), {
      onPress: disabled ? void 0 : handlePress
    })
  };
}
var CheckboxContext = /* @__PURE__ */ React.createContext({
  checked: false,
  disabled: false
}), ensureContext$1 = function(x) {
  x.context || (x.context = CheckboxContext);
};
function createCheckbox(createProps) {
  var {
    disableActiveTheme,
    Frame: Frame2 = CheckboxFrame,
    Indicator = CheckboxIndicatorFrame
  } = createProps;
  ensureContext$1(Frame2), ensureContext$1(Indicator);
  var FrameComponent = Frame2.styleable(function(_props, forwardedRef) {
    var _a = _props, {
      scaleSize = 0.45,
      sizeAdjust = 0,
      scaleIcon,
      checked: checkedProp,
      defaultChecked,
      onCheckedChange,
      native,
      unstyled = false
    } = _a, props = __objRest(_a, [
      "scaleSize",
      "sizeAdjust",
      "scaleIcon",
      "checked",
      "defaultChecked",
      "onCheckedChange",
      "native",
      "unstyled"
    ]), propsActive = useProps(props), styledContext = React.useContext(CheckboxStyledContext), adjustedSize = 0, size = 0;
    if (!unstyled) {
      var _propsActive_size, _ref;
      adjustedSize = getVariableValue(getSize((_ref = (_propsActive_size = propsActive.size) !== null && _propsActive_size !== void 0 ? _propsActive_size : styledContext == null ? void 0 : styledContext.size) !== null && _ref !== void 0 ? _ref : "$true", {
        shift: sizeAdjust
      })), size = scaleSize ? Math.round(adjustedSize * scaleSize) : adjustedSize;
    }
    var [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    }), {
      checkboxProps,
      checkboxRef,
      bubbleInput
    } = useCheckbox(
      // @ts-ignore
      propsActive,
      [checked, setChecked],
      forwardedRef
    );
    React.useEffect(function() {
      if (props.id && !props.disabled) return registerFocusable(props.id, {
        focusAndSelect: function() {
          setChecked == null ? void 0 : setChecked(function(value) {
            return !value;
          });
        },
        focus: function() {
        }
      });
    }, [props.id, props.disabled]);
    var renderNative = shouldRenderNativePlatform(native);
    if (renderNative === "web") return /* @__PURE__ */ jsxRuntimeExports.jsx("input", {
      type: "checkbox",
      defaultChecked: isIndeterminate(checked) ? false : checked,
      tabIndex: -1,
      ref: checkboxRef,
      disabled: checkboxProps.disabled,
      style: __spreadValues({
        appearance: "auto",
        accentColor: "var(--color6)"
      }, checkboxProps.style)
    });
    var memoizedContext = React.useMemo(function() {
      return {
        checked,
        disabled: checkboxProps.disabled
      };
    }, [checked, checkboxProps.disabled]), _propsActive_size1, _ref1, _ref2;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxContext.Provider, {
      value: memoizedContext,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxStyledContext.Provider, {
        size: (_ref1 = (_propsActive_size1 = propsActive.size) !== null && _propsActive_size1 !== void 0 ? _propsActive_size1 : styledContext == null ? void 0 : styledContext.size) !== null && _ref1 !== void 0 ? _ref1 : "$true",
        scaleIcon: (_ref2 = scaleIcon != null ? scaleIcon : styledContext == null ? void 0 : styledContext.scaleIcon) !== null && _ref2 !== void 0 ? _ref2 : 1,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Frame2, __spreadProps(__spreadValues(__spreadProps(__spreadValues(__spreadProps(__spreadValues({}, !unstyled && {
          width: size,
          height: size
        }), {
          tag: "button",
          ref: checkboxRef,
          unstyled
        }), unstyled === false && {
          size,
          theme: checked ? "active" : null
        }), {
          // potential variant
          checked,
          disabled: checkboxProps.disabled
        }), checkboxProps), {
          // react 76 style prop mis-match, but should be fine
          style: checkboxProps.style,
          children: propsActive.children
        })), bubbleInput]
      })
    });
  }), IndicatorComponent = Indicator.styleable(function(props, forwardedRef) {
    var _a = props, {
      children: childrenProp,
      forceMount,
      disablePassStyles,
      unstyled = false
    } = _a, indicatorProps = __objRest(_a, [
      // __scopeCheckbox,
      "children",
      "forceMount",
      "disablePassStyles",
      "unstyled"
    ]), styledContext = React.useContext(CheckboxStyledContext), children = childrenProp;
    if (!unstyled) {
      var iconSize = (typeof styledContext.size == "number" ? styledContext.size * 0.65 : getFontSize(styledContext.size)) * styledContext.scaleIcon, theme = useTheme(), getThemedIcon = useGetThemedIcon({
        size: iconSize,
        color: theme.color
      }), childrens = React.Children.toArray(childrenProp);
      children = childrens.map(function(child) {
        return disablePassStyles || !/* @__PURE__ */ React.isValidElement(child) ? child : getThemedIcon(child);
      });
    }
    var context2 = React.useContext(CheckboxContext);
    return forceMount || isIndeterminate(context2.checked) || context2.checked === true ? /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, __spreadProps(__spreadValues({
      pointerEvents: "none"
    }, indicatorProps), {
      ref: forwardedRef,
      children
    })) : null;
  });
  return withStaticProperties(FrameComponent, {
    Indicator: IndicatorComponent
  });
}
var Checkbox = createCheckbox({
  Frame: CheckboxFrame,
  Indicator: CheckboxIndicatorFrame
});
var FORM_NAME = "Form", FormFrame = styled(Stack, {
  name: FORM_NAME,
  tag: "form"
}), [createFormContext] = createContextScope(FORM_NAME), [FormProvider, useFormContext] = createFormContext(FORM_NAME), TRIGGER_NAME$2 = "FormTrigger", FormTriggerFrame = styled(View, {
  name: TRIGGER_NAME$2
}), FormTrigger = FormTriggerFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeForm,
    children,
    onPress
  } = _a, triggerProps = __objRest(_a, [
    "__scopeForm",
    "children",
    "onPress"
  ]), context2 = useFormContext(TRIGGER_NAME$2, __scopeForm);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormTriggerFrame, __spreadProps(__spreadValues({
    tag: "button"
  }, triggerProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers(onPress, context2.onSubmit),
    children
  }));
}), FormComponent = FormFrame.extractable(function(param) {
  var _a = param, {
    onSubmit
  } = _a, props = __objRest(_a, [
    "onSubmit"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormProvider, {
    scope: props.__scopeForm,
    onSubmit,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormFrame, __spreadProps(__spreadValues({}, props), {
      onSubmit: function(e2) {
        return e2.preventDefault();
      }
    }))
  });
}), Form2 = withStaticProperties(FormComponent, {
  Trigger: FormTrigger
});
var MaxIndexContext = /* @__PURE__ */ React__namespace.createContext([]), IndexContext = /* @__PURE__ */ React__namespace.createContext(null);
function useIndex() {
  var maxIndexPath = React__namespace.useContext(MaxIndexContext), indexPathString = React__namespace.useContext(IndexContext);
  return React__namespace.useMemo(function() {
    if (indexPathString === null) return null;
    var indexPath = parseIndexPath(indexPathString), maxIndex = maxIndexPath[maxIndexPath.length - 1], index2 = indexPath[indexPath.length - 1];
    return {
      maxIndex,
      maxIndexPath,
      index: index2,
      indexPath,
      indexPathString,
      isFirst: index2 === 0,
      isLast: index2 === maxIndex,
      isEven: index2 % 2 === 0,
      isOdd: Math.abs(index2 % 2) === 1
    };
  }, [maxIndexPath, indexPathString]);
}
function useIndexedChildren(children) {
  var parentMaxIndexPath = React__namespace.useContext(MaxIndexContext), indexPathString = React__namespace.useContext(IndexContext), childrenCount = React__namespace.Children.count(children), maxIndexPath = React__namespace.useMemo(function() {
    return parentMaxIndexPath.concat(childrenCount - 1);
  }, [childrenCount]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MaxIndexContext.Provider, {
    value: maxIndexPath,
    children: React__namespace.Children.map(children, function(child, index2) {
      return /* @__PURE__ */ React__namespace.isValidElement(child) ? /* @__PURE__ */ jsxRuntimeExports.jsx(IndexContext.Provider, {
        value: indexPathString ? `${indexPathString}.${index2.toString()}` : index2.toString(),
        children: child
      }, child.key) : child;
    })
  });
}
function parseIndexPath(indexPathString) {
  return indexPathString.split(".").map(function(index2) {
    return Number.parseInt(index2, 10);
  });
}
var GROUP_NAME$2 = "Group", [createGroupContext, createGroupScope] = createContextScope(GROUP_NAME$2), [GroupProvider, useGroupContext] = createGroupContext(GROUP_NAME$2), GroupFrame = styled(ThemeableStack, {
  name: "GroupFrame",
  variants: {
    unstyled: {
      false: {
        size: "$true"
      }
    },
    size: function(val, param) {
      var {
        tokens
      } = param, _tokens_radius_val, _ref, borderRadius = (_ref = (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : val) !== null && _ref !== void 0 ? _ref : tokens.radius.$true;
      return {
        borderRadius
      };
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
function createGroup(verticalDefault) {
  return withStaticProperties(GroupFrame.styleable(function(props, ref) {
    var activeProps = useProps(props), _a = activeProps, {
      __scopeGroup,
      children: childrenProp,
      space,
      size = "$true",
      spaceDirection,
      separator,
      scrollable,
      axis = verticalDefault ? "vertical" : "horizontal",
      orientation = axis,
      disabled: disabledProp,
      disablePassBorderRadius: disablePassBorderRadiusProp,
      borderRadius,
      forceUseItem
    } = _a, restProps = __objRest(_a, [
      "__scopeGroup",
      "children",
      "space",
      "size",
      "spaceDirection",
      "separator",
      "scrollable",
      "axis",
      "orientation",
      "disabled",
      "disablePassBorderRadius",
      "borderRadius",
      "forceUseItem"
    ]), vertical = orientation === "vertical", [itemChildrenCount, setItemChildrenCount] = useControllableState({
      defaultProp: forceUseItem ? 1 : 0
    }), isUsingItems = itemChildrenCount > 0, radius = borderRadius != null ? borderRadius : size ? getVariableValue(getTokens().radius[size]) - 1 : void 0, hasRadius = radius !== void 0, disablePassBorderRadius = disablePassBorderRadiusProp != null ? disablePassBorderRadiusProp : !hasRadius, childrenArray = React.Children.toArray(childrenProp), children = isUsingItems ? React.Children.toArray(childrenProp).filter(React.isValidElement) : childrenArray.map(function(child, i) {
      if (!/* @__PURE__ */ React.isValidElement(child) || child.type === React.Fragment) return child;
      var _child_props_disabled, disabled = (_child_props_disabled = child.props.disabled) !== null && _child_props_disabled !== void 0 ? _child_props_disabled : disabledProp, isFirst = i === 0, isLast = i === childrenArray.length - 1, radiusStyles = disablePassBorderRadius === true ? null : getBorderRadius({
        isFirst,
        isLast,
        radius,
        vertical,
        disable: disablePassBorderRadius
      }), _$props = __spreadValues({
        disabled
      }, radiusStyles);
      return cloneElementWithPropOrder(child, _$props);
    }), indexedChildren = useIndexedChildren(spacedChildren({
      direction: spaceDirection,
      separator,
      space,
      children
    })), onItemMount = React.useCallback(function() {
      return setItemChildrenCount(function(prev) {
        return prev + 1;
      });
    }, []), onItemUnmount = React.useCallback(function() {
      return setItemChildrenCount(function(prev) {
        return prev - 1;
      });
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(GroupProvider, {
      disablePassBorderRadius,
      vertical: orientation === "vertical",
      // @ts-ignore this just popped up since new version expo 49
      radius,
      disabled: disabledProp,
      onItemMount,
      onItemUnmount,
      scope: __scopeGroup,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(GroupFrame, __spreadProps(__spreadValues({
        ref,
        size,
        flexDirection: orientation === "horizontal" ? "row" : "column",
        borderRadius
      }, restProps), {
        children: wrapScroll(__spreadProps(__spreadValues({}, activeProps), {
          orientation
        }), indexedChildren)
      }))
    });
  }), {
    Item: GroupItem
  });
}
var GroupItem = /* @__PURE__ */ React.forwardRef(function(props, _ref) {
  var {
    __scopeGroup,
    children,
    forcePlacement
  } = props, groupItemProps = useGroupItem({
    disabled: /* @__PURE__ */ React.isValidElement(children) ? children.props.disabled : false
  }, forcePlacement, __scopeGroup);
  return !/* @__PURE__ */ React.isValidElement(children) || children.type === React.Fragment ? children : /* @__PURE__ */ React.cloneElement(children, groupItemProps);
}), useGroupItem = function(childrenProps, forcePlacement, __scopeGroup) {
  var treeIndex = useIndex(), context2 = useGroupContext("GroupItem", __scopeGroup);
  if (React.useEffect(function() {
    return context2.onItemMount(), function() {
      context2.onItemUnmount();
    };
  }, []), !treeIndex) throw Error("<Group.Item/> should only be used within a <Group/>");
  var isFirst = forcePlacement === "first" || forcePlacement !== "last" && treeIndex.index === 0, isLast = forcePlacement === "last" || forcePlacement !== "first" && treeIndex.index === treeIndex.maxIndex, _childrenProps_disabled, disabled = (_childrenProps_disabled = childrenProps.disabled) !== null && _childrenProps_disabled !== void 0 ? _childrenProps_disabled : context2.disabled, propsToPass = {
    disabled
  };
  if (context2.disablePassBorderRadius !== true) {
    var borderRadius = getBorderRadius({
      radius: context2.radius,
      isFirst,
      isLast,
      vertical: context2.vertical,
      disable: context2.disablePassBorderRadius
    });
    return __spreadValues(__spreadValues({}, propsToPass), borderRadius);
  }
  return propsToPass;
}, Group = createGroup(true), YGroup = Group, XGroup = createGroup(false), wrapScroll = function(param, children) {
  var {
    scrollable,
    orientation,
    showScrollIndicator = false
  } = param;
  return scrollable ? /* @__PURE__ */ jsxRuntimeExports.jsx(ForwardedScrollView, __spreadProps(__spreadValues(__spreadValues({}, orientation === "vertical" && {
    showsVerticalScrollIndicator: showScrollIndicator
  }), orientation === "horizontal" && {
    horizontal: true,
    showsHorizontalScrollIndicator: showScrollIndicator
  }), {
    children
  })) : children;
}, getBorderRadius = function(param) {
  var {
    isFirst,
    isLast,
    radius,
    vertical,
    disable
  } = param;
  return {
    borderTopLeftRadius: isFirst && disable !== "top" && disable !== "start" ? radius : 0,
    borderTopRightRadius: disable !== "top" && disable !== "end" && (vertical && isFirst || !vertical && isLast) ? radius : 0,
    borderBottomLeftRadius: disable !== "bottom" && disable !== "start" && (vertical && isLast || !vertical && isFirst) ? radius : 0,
    borderBottomRightRadius: isLast && disable !== "bottom" && disable !== "end" ? radius : 0
  };
}, cloneElementWithPropOrder = function(child, props) {
  return /* @__PURE__ */ React.cloneElement(__spreadProps(__spreadValues({}, child), {
    props: null
  }), __spreadValues(__spreadValues({}, child.props), props));
};
var Section = styled(View, {
  name: "Section",
  tag: "section",
  flexDirection: "column",
  accessibilityRole: "summary"
}), Article = styled(View, {
  name: "Article",
  tag: "article",
  flexDirection: "column"
}), Main = styled(View, {
  name: "Main",
  tag: "main",
  flexDirection: "column"
}), Header = styled(View, {
  name: "Header",
  tag: "header",
  accessibilityRole: "header",
  flexDirection: "column"
}), Aside = styled(View, {
  name: "Aside",
  tag: "aside",
  flexDirection: "column"
}), Footer = styled(View, {
  name: "Footer",
  tag: "footer",
  flexDirection: "column"
}), Nav = styled(View, {
  name: "Nav",
  tag: "nav",
  flexDirection: "column"
});
var NAME$1 = "ListItem", ListItemFrame = styled(ThemeableStack, {
  name: NAME$1,
  tag: "li",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        alignItems: "center",
        justifyContent: "space-between",
        flexWrap: "nowrap",
        width: "100%",
        borderColor: "$borderColor",
        maxWidth: "100%",
        overflow: "hidden",
        flexDirection: "row",
        backgroundColor: "$background",
        cursor: "default"
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param;
        return {
          minHeight: tokens.size[val],
          paddingHorizontal: tokens.space[val],
          paddingVertical: getSpace(tokens.space[val], {
            shift: -4
          })
        };
      }
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        }
      }
    },
    disabled: {
      true: {
        opacity: 0.5,
        // TODO breaking types
        pointerEvents: "none"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ListItemText = styled(SizableText, {
  name: "ListItemText",
  variants: {
    unstyled: {
      false: {
        color: "$color",
        size: "$true",
        flexGrow: 1,
        flexShrink: 1,
        ellipse: true,
        cursor: "inherit"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ListItemSubtitle = styled(ListItemText, {
  name: "ListItemSubtitle",
  variants: {
    unstyled: {
      false: {
        opacity: 0.6,
        maxWidth: "100%",
        color: "$color"
      }
    },
    size: {
      "...size": function(val, extras) {
        var oneSmaller = getSize(val, {
          shift: -1,
          excludeHalfSteps: true
        }), fontStyle = getFontSized(oneSmaller.key, extras);
        return fontStyle;
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ListItemTitle = styled(ListItemText, {
  name: "ListItemTitle"
}), useListItem = function(propsIn) {
  var {
    Text: Text2 = ListItemText,
    Subtitle = ListItemSubtitle,
    Title = ListItemTitle
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    Text: ListItemText,
    Subtitle: ListItemSubtitle,
    Title: ListItemTitle
  }, props = useProps(propsIn, {
    resolveValues: "none"
  }), _a = props, {
    children,
    icon,
    iconAfter,
    noTextWrap,
    theme: themeName,
    space,
    spaceFlex,
    scaleIcon = 1,
    scaleSpace = 1,
    unstyled = false,
    subTitle,
    title,
    color: color,
    fontWeight,
    fontSize,
    fontFamily,
    letterSpacing,
    textAlign,
    ellipse
  } = _a, rest = __objRest(_a, [
    "children",
    "icon",
    "iconAfter",
    "noTextWrap",
    "theme",
    "space",
    "spaceFlex",
    "scaleIcon",
    "scaleSpace",
    "unstyled",
    "subTitle",
    "title",
    // text props
    "color",
    "fontWeight",
    "fontSize",
    "fontFamily",
    "letterSpacing",
    "textAlign",
    "ellipse"
  ]), textProps = {
    color,
    fontWeight,
    fontSize,
    fontFamily,
    letterSpacing,
    textAlign,
    children
  }, size = props.size || "$true", iconSize = getFontSize(size) * scaleIcon, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color
  }), [themedIcon, themedIconAfter] = [icon, iconAfter].map(getThemedIcon), _getTokens_space_props_space, sizeToken = (_getTokens_space_props_space = getTokens().space[props.space]) !== null && _getTokens_space_props_space !== void 0 ? _getTokens_space_props_space : iconSize, spaceSize = getVariableValue(sizeToken) * scaleSpace, contents = wrapChildrenInText(Text2, textProps);
  return {
    props: __spreadProps(__spreadValues({}, rest), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          themedIcon ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [themedIcon, /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
              size: spaceSize
            })]
          }) : null,
          /* helper for common title/subtitle pttern */
          /* biome-ignore lint/complexity/noExtraBooleanCast: <explanation> */
          title || subTitle ? /* @__PURE__ */ jsxRuntimeExports.jsxs(YStack, {
            flex: 1,
            children: [noTextWrap === "all" ? title : /* @__PURE__ */ jsxRuntimeExports.jsx(Title, {
              size,
              children: title
            }), subTitle ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
              children: typeof subTitle == "string" && noTextWrap !== "all" ? (
                // TODO can use theme but we need to standardize to alt themes
                // or standardize on subtle colors in themes
                /* @__PURE__ */ jsxRuntimeExports.jsx(Subtitle, {
                  unstyled,
                  size,
                  children: subTitle
                })
              ) : subTitle
            }) : null, contents]
          }) : contents,
          themedIconAfter ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {
              size: spaceSize
            }), themedIconAfter]
          }) : null
        ]
      })
    })
  };
}, ListItemComponent = ListItemFrame.styleable(function(props, ref) {
  var {
    props: listItemProps
  } = useListItem(props);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemFrame, __spreadValues({
    ref
  }, listItemProps));
}), ListItem2 = withStaticProperties(ListItemComponent, {
  Text: ListItemText,
  Subtitle: ListItemSubtitle,
  Title: ListItemTitle
});
function Animate(param) {
  var _a = param, {
    children,
    lazyMount,
    type,
    present,
    passThrough
  } = _a, props = __objRest(_a, [
    "children",
    "lazyMount",
    "type",
    "present",
    "passThrough"
  ]), [lazyMounted, setLazyMounted] = React.useState(lazyMount ? false : present);
  React.useEffect(function() {
    passThrough || lazyMount && present && React.startTransition(function() {
      setLazyMounted(present);
    });
  }, [lazyMount, present]);
  var mounted = present ? lazyMount ? lazyMounted : present : false;
  return type === "presence" ? props.keepChildrenMounted ? /* @__PURE__ */ jsxRuntimeExports.jsx(PresenceChild, __spreadProps(__spreadValues({
    isPresent: true
  }, !passThrough && {
    initial: props.initial ? void 0 : false,
    onExitComplete: props.onExitComplete,
    enterVariant: props.enterVariant,
    exitVariant: props.exitVariant,
    enterExitVariant: props.enterExitVariant,
    // BUGFIX: this causes continous re-renders if keepChildrenMounted is true, see HeaderMenu
    // but since we always re-render this component on open changes this should be fine to leave off?
    presenceAffectsLayout: false,
    isPresent: present,
    custom: props.custom
  }), {
    children
  })) : /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, __spreadProps(__spreadValues({
    passThrough
  }, props), {
    children: mounted || passThrough ? children : null
  })) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children
  });
}
const min = Math.min;
const max = Math.max;
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return __spreadValues({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition = (reference, floating, config) => __async(null, null, function* () {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);
  let rects = yield platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = yield fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {
      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)
    });
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? yield platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
});
function detectOverflow(state, options) {
  return __async(this, null, function* () {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(yield platform2.getClippingRect({
      element: ((_await$platform$isEle = yield platform2.isElement == null ? void 0 : platform2.isElement(element)) != null ? _await$platform$isEle : true) ? element : element.contextElement || (yield platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating);
    const offsetScale = (yield platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? (yield platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? yield platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  });
}
const arrow$2 = (options) => ({
  name: "arrow",
  options,
  fn(state) {
    return __async(this, null, function* () {
      const {
        x,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = yield platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = yield platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element);
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !(yield platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: __spreadValues({
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset
        }, shouldAddOffset && {
          alignmentOffset
        }),
        reset: shouldAddOffset
      };
    });
  }
});
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "fallbackPlacements",
          "fallbackStrategy",
          "fallbackAxisSideDirection",
          "flipAlignment"
        ]);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides[0]], overflow[sides[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
            if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
            // overflows the main axis.
            overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      });
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
function convertValueToCoords(state, options) {
  return __async(this, null, function* () {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating);
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  });
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn(state) {
      return __async(this, null, function* () {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x,
          y,
          placement,
          middlewareData
        } = state;
        const diffCoords = yield convertValueToCoords(state, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x + diffCoords.x,
          y: y + diffCoords.y,
          data: __spreadProps(__spreadValues({}, diffCoords), {
            placement
          })
        };
      });
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    fn(state) {
      return __async(this, null, function* () {
        const {
          x,
          y,
          placement
        } = state;
        const _a2 = evaluate(options, state), {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x2,
                y: y2
              } = _ref;
              return {
                x: x2,
                y: y2
              };
            }
          }
        } = _a2, detectOverflowOptions = __objRest(_a2, [
          "mainAxis",
          "crossAxis",
          "limiter"
        ]);
        const coords = {
          x,
          y
        };
        const overflow = yield detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn(__spreadProps(__spreadValues({}, state), {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        }));
        return __spreadProps(__spreadValues({}, limitedCoords), {
          data: {
            x: limitedCoords.x - x,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        });
      });
    }
  };
};
const ORIGIN$1 = {
  x: 0,
  y: 0
};
function isView(reference) {
  return "measure" in reference;
}
const createPlatform = (_ref) => {
  let {
    offsetParent,
    sameScrollView = true,
    scrollOffsets = ORIGIN$1
  } = _ref;
  return {
    getElementRects(_ref2) {
      let {
        reference,
        floating
      } = _ref2;
      return new Promise((resolve) => {
        const onMeasure = function(offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          floating.measure((x, y, width, height) => {
            const floatingRect = __spreadValues({
              width,
              height
            }, ORIGIN$1);
            const method = sameScrollView ? "measure" : "measureInWindow";
            if (isView(reference)) {
              reference[method]((x2, y2, width2, height2) => {
                y2 = y2;
                const referenceRect = {
                  width: width2,
                  height: height2,
                  x: x2 - offsetX,
                  y: y2 - offsetY
                };
                resolve({
                  reference: referenceRect,
                  floating: floatingRect
                });
              });
            } else {
              const boundingRect = reference.getBoundingClientRect();
              const referenceRect = {
                width: boundingRect.width,
                height: boundingRect.height,
                x: boundingRect.x - offsetX,
                y: boundingRect.y - offsetY
              };
              resolve({
                reference: referenceRect,
                floating: floatingRect
              });
            }
          });
        };
        if (offsetParent) {
          offsetParent.measure(onMeasure);
        } else {
          onMeasure();
        }
      });
    },
    getClippingRect() {
      const {
        width: windowWidth,
        height: windowHeight
      } = Dimensions2.get("window");
      const {
        height: screenHeight
      } = Dimensions2.get("screen");
      const navigationBarHeight = 0;
      return Promise.resolve(__spreadValues({
        width: windowWidth,
        height: screenHeight - navigationBarHeight
      }, sameScrollView ? scrollOffsets : ORIGIN$1));
    },
    convertOffsetParentRelativeRectToViewportRelativeRect(_ref3) {
      let {
        rect
      } = _ref3;
      return new Promise((resolve) => {
        const onMeasure = function(offsetX, offsetY) {
          if (offsetX === void 0) {
            offsetX = 0;
          }
          if (offsetY === void 0) {
            offsetY = 0;
          }
          resolve(__spreadProps(__spreadValues({}, rect), {
            x: rect.x + offsetX,
            y: rect.y + offsetY
          }));
        };
        if (offsetParent) {
          offsetParent.measure(onMeasure);
        } else {
          onMeasure();
        }
      });
    },
    getDimensions: (element) => new Promise((resolve) => element.measure((x, y, width, height) => resolve({
      width,
      height
    })))
  };
};
function deepEqual(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b2 && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b2.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
const ORIGIN = {
  x: 0,
  y: 0
};
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    middleware = [],
    sameScrollView = true,
    elements: {
      reference: externalReference,
      floating: externalFloating,
      offsetParent: externalOffsetParent
    } = {}
  } = options;
  const [_reference, _setReference] = React__namespace.useState(null);
  const [_floating, _setFloating] = React__namespace.useState(null);
  const [_offsetParent, _setOffsetParent] = React__namespace.useState(null);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const offsetParentEl = externalOffsetParent || _offsetParent;
  const setReference = React__namespace.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React__namespace.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const setOffsetParent = React__namespace.useCallback((node) => {
    if (node !== offsetParentRef.current) {
      offsetParentRef.current = node;
      _setOffsetParent(node);
    }
  }, []);
  const referenceRef = React__namespace.useRef(null);
  const floatingRef = React__namespace.useRef(null);
  const offsetParentRef = React__namespace.useRef(null);
  const [data, setData] = React__namespace.useState({
    x: 0,
    y: 0,
    placement,
    strategy: "absolute",
    middlewareData: {}
  });
  const [scrollOffsets, setScrollOffsets] = React__namespace.useState(ORIGIN);
  const [latestMiddleware, setLatestMiddleware] = React__namespace.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const platform2 = React__namespace.useMemo(() => createPlatform({
    offsetParent: offsetParentEl,
    scrollOffsets,
    sameScrollView
  }), [offsetParentEl, scrollOffsets, sameScrollView]);
  const update2 = React__namespace.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    computePosition(referenceRef.current, floatingRef.current, {
      middleware: latestMiddleware,
      platform: platform2,
      placement
    }).then((data2) => {
      if (isMountedRef.current) {
        setData(data2);
      }
    });
  }, [latestMiddleware, platform2, placement]);
  React__namespace.useLayoutEffect(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (offsetParentEl) offsetParentRef.current = offsetParentEl;
    const frame = requestAnimationFrame(update2);
    return () => {
      cancelAnimationFrame(frame);
    };
  }, [referenceEl, floatingEl, offsetParentEl, update2]);
  const isMountedRef = React__namespace.useRef(true);
  React__namespace.useLayoutEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const refs = React__namespace.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    offsetParent: offsetParentRef,
    setReference,
    setFloating,
    setOffsetParent
  }), [setReference, setFloating, setOffsetParent]);
  const elements = React__namespace.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl,
    offsetParent: offsetParentEl
  }), [referenceEl, floatingEl, offsetParentEl]);
  const floatingStyles = React__namespace.useMemo(() => {
    if (!elements.floating) {
      return {
        position: "absolute",
        left: 0,
        top: 0
      };
    }
    return {
      position: "absolute",
      left: data.x,
      top: data.y
    };
  }, [elements.floating, data.x, data.y]);
  return React__namespace.useMemo(() => __spreadProps(__spreadValues({}, data), {
    update: update2,
    refs,
    elements,
    floatingStyles,
    offsetParent: setOffsetParent,
    reference: setReference,
    floating: setFloating,
    scrollProps: {
      onScroll: (event) => setScrollOffsets(event.nativeEvent.contentOffset),
      scrollEventThrottle: 16
    }
  }), [data, refs, elements, floatingStyles, setReference, setFloating, setOffsetParent, update2]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => __spreadProps(__spreadValues({}, offset$1(options)), {
  options: [options, deps]
});
const shift = (options, deps) => __spreadProps(__spreadValues({}, shift$1(options)), {
  options: [options, deps]
});
const flip = (options, deps) => __spreadProps(__spreadValues({}, flip$1(options)), {
  options: [options, deps]
});
const arrow = (options, deps) => __spreadProps(__spreadValues({}, arrow$1(options)), {
  options: [options, deps]
});
var autoUpdate = function() {
}, platform = null;
var FloatingOverrideContext = /* @__PURE__ */ React.createContext(null), useFloating = function(props) {
  var _this, context2 = React.useContext(FloatingOverrideContext);
  return (_this = context2 || useFloating$1) === null || _this === void 0 ? void 0 : _this(__spreadProps(__spreadValues({}, props), {
    middleware: [
      // @ts-ignore
      ...props.middleware,
      {
        name: "rounded",
        fn(param) {
          var {
            x,
            y
          } = param;
          return {
            x: Math.round(x),
            y: Math.round(y)
          };
        }
      }
    ]
  }));
};
var PopperContextFast = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "Popper__"
), PopperPositionContext = createStyledContext, {
  useStyledContext: usePopperContext,
  Provider: PopperProviderFast
} = PopperContextFast, PopperContextSlow = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "PopperSlow__"
), {
  useStyledContext: usePopperContextSlow,
  Provider: PopperProviderSlow
} = PopperContextSlow, PopperProvider = function(param) {
  var _a = param, {
    scope,
    children
  } = _a, context2 = __objRest(_a, [
    "scope",
    "children"
  ]), slowContext = getContextSlow(context2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProviderFast, __spreadProps(__spreadValues({
    scope
  }, context2), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProviderSlow, __spreadProps(__spreadValues({
      scope
    }, slowContext), {
      children
    }))
  }));
};
function getContextSlow(context2) {
  return {
    refs: context2.refs,
    size: context2.size,
    arrowRef: context2.arrowRef,
    arrowStyle: context2.arrowStyle,
    onArrowSize: context2.onArrowSize,
    hasFloating: context2.hasFloating,
    strategy: context2.strategy,
    update: context2.update,
    context: context2.context,
    getFloatingProps: context2.getFloatingProps,
    getReferenceProps: context2.getReferenceProps,
    open: context2.open
  };
}
var checkFloating = {
  name: "checkFloating",
  fn(data) {
    return {
      data: {
        hasFloating: !!data.rects.floating.width
      }
    };
  }
}, setupOptions = {};
function setupPopper(options) {
  Object.assign(setupOptions, options);
}
function Popper(props) {
  var {
    children,
    size,
    strategy = "absolute",
    placement = "bottom",
    stayInFrame,
    allowFlip,
    offset: offset$12,
    disableRTL,
    resize,
    passThrough,
    open: open2,
    scope
  } = props, [arrowEl, setArrow] = React__namespace.useState(null), [arrowSize, setArrowSize] = React__namespace.useState(0), offsetOptions = offset$12 != null ? offset$12 : arrowSize;
  React__namespace.useRef({});
  var isOpen = passThrough ? false : open2 || true, floating = useFloating({
    open: isOpen,
    strategy,
    placement,
    sameScrollView: false,
    // this only takes effect on native
    whileElementsMounted: isOpen ? autoUpdate : void 0,
    platform: (disableRTL != null ? disableRTL : setupOptions.disableRTL) ? __spreadProps(__spreadValues({}, platform), {
      isRTL(element) {
        return false;
      }
    }) : platform,
    middleware: [stayInFrame ? shift(typeof stayInFrame == "boolean" ? {} : stayInFrame) : null, allowFlip ? flip(typeof allowFlip == "boolean" ? {} : allowFlip) : null, arrowEl ? arrow({
      element: arrowEl
    }) : null, typeof offsetOptions < "u" ? offset(offsetOptions) : null, checkFloating, null].filter(Boolean)
  }), {
    middlewareData
  } = floating, dimensions2 = useWindowDimensions$1(), [keyboardOpen, setKeyboardOpen] = React__namespace.useState(false);
  React__namespace.useEffect(function() {
    var showSubscription = Keyboard.addListener("keyboardDidShow", function() {
      startTransition(function() {
        setKeyboardOpen(true);
      });
    }), hideSubscription = Keyboard.addListener("keyboardDidHide", function() {
      startTransition(function() {
        setKeyboardOpen(false);
      });
    });
    return function() {
      showSubscription.remove(), hideSubscription.remove();
    };
  }, []), useIsomorphicLayoutEffect(function() {
    passThrough || floating.update();
  }, [passThrough, dimensions2, keyboardOpen]);
  var popperContext = React__namespace.useMemo(function() {
    var _middlewareData_checkFloating;
    return __spreadValues({
      size,
      arrowRef: setArrow,
      arrowStyle: middlewareData.arrow,
      onArrowSize: setArrowSize,
      hasFloating: (_middlewareData_checkFloating = middlewareData.checkFloating) === null || _middlewareData_checkFloating === void 0 ? void 0 : _middlewareData_checkFloating.hasFloating,
      open: !!open2
    }, floating);
  }, [open2, size, floating.x, floating.y, floating.placement, JSON.stringify(middlewareData.arrow || null), floating.isPositioned]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LayoutMeasurementController, {
    disable: !isOpen,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, __spreadProps(__spreadValues({
      scope
    }, popperContext), {
      children
    }))
  });
}
var PopperAnchor = YStack.extractable(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    virtualRef,
    scope
  } = _a, anchorProps = __objRest(_a, [
    "virtualRef",
    "scope"
  ]), context2 = usePopperContextSlow(scope), {
    getReferenceProps,
    refs,
    update: update2
  } = context2, ref = React__namespace.useRef(null);
  React__namespace.useEffect(function() {
    virtualRef && refs.setReference(virtualRef.current);
  }, [virtualRef]);
  var stackProps = anchorProps, safeSetReference = React__namespace.useCallback(function(node) {
    startTransition(function() {
      refs.setReference(node);
    });
  }, [refs.setReference]), refProps = getReferenceProps ? getReferenceProps(stackProps) : null, shouldHandleInHover = isWeb, composedRefs = useComposedRefs(
    forwardedRef,
    ref,
    // web handles this onMouseEnter below so it can support multiple targets + hovering
    safeSetReference
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, stackProps), refProps), {
    ref: composedRefs
  }), shouldHandleInHover));
})), PopperContentFrame = styled(ThemeableStack, {
  name: "PopperContent",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        alignItems: "center",
        radiused: true
      }
    },
    size: {
      "...size": function(val, param) {
        var {
          tokens
        } = param;
        return {
          padding: tokens.space[val],
          borderRadius: tokens.radius[val]
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), PopperContent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope,
    enableAnimationForPositionChange,
    children,
    passThrough
  } = _a, rest = __objRest(_a, [
    "scope",
    "enableAnimationForPositionChange",
    "children",
    "passThrough"
  ]), context2 = usePopperContext(scope), {
    strategy,
    placement,
    refs,
    x,
    y,
    getFloatingProps,
    size,
    isPositioned
  } = context2, safeSetFloating = React__namespace.useCallback(function(node) {
    startTransition(function() {
      refs.setFloating(node);
    });
  }, [refs.setFloating]), contentRefs = useComposedRefs(safeSetFloating, forwardedRef), [needsMeasure, setNeedsMeasure] = React__namespace.useState(enableAnimationForPositionChange);
  useIsomorphicLayoutEffect(function() {
    needsMeasure && x && y && setNeedsMeasure(false);
  }, [needsMeasure, enableAnimationForPositionChange, x, y]);
  var hide = x === 0 && y === 0, disableAnimationProp = (
    // if they want to animate also when re-positioning allow it
    enableAnimationForPositionChange === "even-when-repositioning" ? needsMeasure : !isPositioned || needsMeasure
  ), [disableAnimation, setDisableAnimation] = React__namespace.useState(disableAnimationProp);
  React__namespace.useEffect(function() {
    setDisableAnimation(disableAnimationProp);
  }, [disableAnimationProp]);
  var frameProps = __spreadValues(__spreadValues({
    ref: contentRefs,
    x: x || 0,
    y: y || 0,
    top: 0,
    left: 0,
    position: strategy,
    opacity: 1
  }, enableAnimationForPositionChange && {
    animation: rest.animation,
    animateOnly: disableAnimation ? [] : rest.animateOnly,
    // apply animation but disable it on initial render to avoid animating from 0 to the first position
    animatePresence: false
  }), hide && {
    opacity: 0,
    animateOnly: []
  }), _b = getFloatingProps ? getFloatingProps(frameProps) : frameProps, {
    style
  } = _b, floatingProps = __objRest(_b, [
    "style"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadProps(__spreadValues({
    passThrough,
    ref: contentRefs,
    contain: "layout style"
  }, passThrough ? null : floatingProps), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperContentFrame, __spreadProps(__spreadValues({
      passThrough
    }, !passThrough && __spreadValues(__spreadValues({
      "data-placement": placement,
      "data-strategy": strategy,
      size
    }, style), rest)), {
      children
    }), "popper-content-frame")
  }));
}), PopperArrowFrame = styled(YStack, {
  name: "PopperArrow",
  variants: {
    unstyled: {
      false: {
        borderColor: "$borderColor",
        backgroundColor: "$background",
        position: "relative"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), PopperArrowOuterFrame = styled(YStack, {
  name: "PopperArrowOuter",
  variants: {
    unstyled: {
      false: {
        position: "absolute",
        zIndex: 1e6,
        pointerEvents: "none",
        overflow: "hidden",
        alignItems: "center",
        justifyContent: "center"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), opposites = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, PopperArrow = /* @__PURE__ */ React__namespace.forwardRef(function(propsIn, forwardedRef) {
  var _context_arrowStyle, _context_arrowStyle1, _a = propsIn, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), props = useProps(rest), _b = props, {
    offset: offset2,
    size: sizeProp,
    borderWidth = 0
  } = _b, arrowProps = __objRest(_b, [
    "offset",
    "size",
    "borderWidth"
  ]), context2 = usePopperContext(scope), sizeVal = typeof sizeProp == "number" ? sizeProp : getVariableValue(getSpace(sizeProp != null ? sizeProp : context2.size, {
    shift: -2,
    bounds: [2]
  })), size = Math.max(0, +sizeVal), {
    placement
  } = context2, refs = useComposedRefs(context2.arrowRef, forwardedRef), x = ((_context_arrowStyle = context2.arrowStyle) === null || _context_arrowStyle === void 0 ? void 0 : _context_arrowStyle.x) || 0, y = ((_context_arrowStyle1 = context2.arrowStyle) === null || _context_arrowStyle1 === void 0 ? void 0 : _context_arrowStyle1.y) || 0, primaryPlacement = placement ? placement.split("-")[0] : "top", arrowStyle = {
    x,
    y,
    width: size,
    height: size
  }, innerArrowStyle = {}, isVertical = primaryPlacement === "bottom" || primaryPlacement === "top";
  if (primaryPlacement) {
    arrowStyle[isVertical ? "width" : "height"] = size * 2;
    var oppSide = opposites[primaryPlacement];
    oppSide && (arrowStyle[oppSide] = -size, innerArrowStyle[oppSide] = size / 2), (oppSide === "top" || oppSide === "bottom") && (arrowStyle.left = 0), (oppSide === "left" || oppSide === "right") && (arrowStyle.top = 0), useIsomorphicLayoutEffect(function() {
      var _context_onArrowSize;
      (_context_onArrowSize = context2.onArrowSize) === null || _context_onArrowSize === void 0 || _context_onArrowSize.call(context2, size);
    }, [size, context2.onArrowSize]);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperArrowOuterFrame, __spreadProps(__spreadValues({
    ref: refs
  }, arrowStyle), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperArrowFrame, __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues({
      width: size,
      height: size
    }, arrowProps), innerArrowStyle), {
      rotate: "45deg"
    }), primaryPlacement === "bottom" && {
      borderLeftWidth: borderWidth,
      borderTopWidth: borderWidth
    }), primaryPlacement === "top" && {
      borderBottomWidth: borderWidth,
      borderRightWidth: borderWidth
    }), primaryPlacement === "right" && {
      borderLeftWidth: borderWidth,
      borderBottomWidth: borderWidth
    }), primaryPlacement === "left" && {
      borderTopWidth: borderWidth,
      borderRightWidth: borderWidth
    }))
  }));
});
var useFloatingContext = function() {
  return React.useCallback(function() {
  }, []);
};
var needsRepropagation = isAndroid || isIos && !USE_NATIVE_PORTAL, PopoverContext = createStyledContext(
  // since we always provide this we can avoid setting here
  {},
  "Popover__"
), usePopoverContext = PopoverContext.useStyledContext, PopoverAnchor = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope), {
    onCustomAnchorAdd,
    onCustomAnchorRemove
  } = context2 || {};
  return React__namespace.useEffect(function() {
    return onCustomAnchorAdd(), function() {
      return onCustomAnchorRemove();
    };
  }, [onCustomAnchorAdd, onCustomAnchorRemove]), /* @__PURE__ */ jsxRuntimeExports.jsx(PopperAnchor, __spreadProps(__spreadValues({
    scope
  }, rest), {
    ref: forwardedRef
  }));
}), PopoverTrigger = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope), anchorTo = context2.anchorTo, composedTriggerRef = useComposedRefs(forwardedRef, context2.triggerRef);
  if (!props.children) return null;
  var trigger = /* @__PURE__ */ jsxRuntimeExports.jsx(View, __spreadProps(__spreadValues({
    "aria-expanded": context2.open,
    // TODO not matching
    // aria-controls={context.contentId}
    "data-state": getState$1(context2.open)
  }, rest), {
    // @ts-ignore
    ref: composedTriggerRef,
    onPress: composeEventHandlers(props.onPress, context2.onOpenToggle)
  })), virtualRef = React__namespace.useMemo(function() {
    return anchorTo ? {
      current: __spreadValues({
        getBoundingClientRect: function() {
          return anchorTo;
        }
      }, {
        measure: function(c) {
          return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
        },
        measureInWindow: function(c) {
          return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
        }
      })
    } : null;
  }, [context2.anchorTo, anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.height, anchorTo == null ? void 0 : anchorTo.width]);
  return context2.hasCustomAnchor ? trigger : /* @__PURE__ */ jsxRuntimeExports.jsx(PopperAnchor, __spreadProps(__spreadValues({}, virtualRef && {
    virtualRef
  }), {
    scope,
    asChild: true,
    children: trigger
  }));
}), PopoverContentFrame = styled(PopperContentFrame, {
  name: "Popover"
}), PopoverContent = PopoverContentFrame.extractable(/* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    trapFocus,
    enableRemoveScroll = false,
    zIndex,
    scope
  } = _a, contentImplProps = __objRest(_a, [
    "trapFocus",
    "enableRemoveScroll",
    "zIndex",
    "scope"
  ]), context2 = usePopoverContext(scope), contentRef = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), isRightClickOutsideRef = React__namespace.useRef(false), [isFullyHidden, setIsFullyHidden] = React__namespace.useState(!context2.open);
  if (React__namespace.useEffect(function() {
    context2.open && isFullyHidden && setIsFullyHidden(false);
  }, [context2.open, isFullyHidden]), !context2.keepChildrenMounted && isFullyHidden && !context2.open) return null;
  var _contentImplProps_pointerEvents;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverPortal, {
    passThrough: context2.breakpointActive,
    context: context2,
    zIndex,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, {
      passThrough: context2.breakpointActive,
      pointerEvents: context2.open ? (_contentImplProps_pointerEvents = contentImplProps.pointerEvents) !== null && _contentImplProps_pointerEvents !== void 0 ? _contentImplProps_pointerEvents : "auto" : "none",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentImpl, __spreadProps(__spreadValues({}, contentImplProps), {
        context: context2,
        enableRemoveScroll,
        ref: composedRefs,
        setIsFullyHidden,
        scope,
        // we make sure we're not trapping once it's been closed
        // (closed !== unmounted when animating out)
        trapFocus: trapFocus != null ? trapFocus : context2.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: props.onCloseAutoFocus === false ? void 0 : composeEventHandlers(props.onCloseAutoFocus, function(event) {
          var _context_triggerRef_current;
          event.defaultPrevented || (event.preventDefault(), isRightClickOutsideRef.current || (_context_triggerRef_current = context2.triggerRef.current) === null || _context_triggerRef_current === void 0 || _context_triggerRef_current.focus());
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, function(event) {
          var originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.current = isRightClick;
        }, {
          checkDefaultPrevented: false
        }),
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        onFocusOutside: composeEventHandlers(props.onFocusOutside, function(event) {
          return event.preventDefault();
        }, {
          checkDefaultPrevented: false
        })
      }))
    })
  });
})), useParentContexts = function(scope) {
  var context2 = usePopoverContext(scope), popperContext = usePopperContext(scope), adaptContext = useAdaptContext(context2.adaptScope);
  return {
    popperContext,
    adaptContext,
    context: context2
  };
};
function RepropagateParentContexts(param) {
  var {
    adaptContext,
    children,
    context: context2,
    popperContext
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, __spreadProps(__spreadValues({
    scope: context2.popoverScope
  }, popperContext), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContext.Provider, __spreadProps(__spreadValues({}, context2), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProvideAdaptContext, __spreadProps(__spreadValues({}, adaptContext), {
        children
      }))
    }))
  }));
}
var PortalAdaptSafe = function(param) {
  var {
    children,
    context: context2
  } = param;
  if (needsRepropagation) {
    var parentContexts = useParentContexts(context2.popoverScope);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
      scope: context2.adaptScope,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RepropagateParentContexts, __spreadProps(__spreadValues({}, parentContexts), {
        children
      }))
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
    scope: context2.adaptScope,
    children
  });
};
function PopoverPortal(param) {
  var {
    context: context2,
    zIndex,
    passThrough,
    children,
    onPress
  } = param, themeName = useThemeName(), content = children;
  if (needsRepropagation) {
    var parentContexts = useParentContexts(context2.popoverScope);
    content = /* @__PURE__ */ jsxRuntimeExports.jsx(RepropagateParentContexts, __spreadProps(__spreadValues({}, parentContexts), {
      children: content
    }));
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    passThrough,
    stackZIndex: true,
    zIndex,
    children: (
      /* forceClassName avoids forced re-mount renders for some reason... see the HeadMenu as you change tints a few times */
      /* without this you'll see the site menu re-rendering. It must be something in wrapping children in Theme */
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Theme, {
        passThrough,
        contain: true,
        forceClassName: true,
        name: themeName,
        children: [!!context2.open && !context2.breakpointActive && /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, {
          fullscreen: true,
          onPress: composeEventHandlers(onPress, context2.onOpenToggle)
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(StackZIndexContext, {
          zIndex: resolveViewZIndex(zIndex),
          children: content
        })]
      })
    )
  });
}
var PopoverContentImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    trapFocus,
    scope,
    onOpenAutoFocus,
    onCloseAutoFocus,
    disableOutsidePointerEvents,
    disableFocusScope,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onInteractOutside,
    children,
    enableRemoveScroll,
    freezeContentsWhenHidden,
    setIsFullyHidden,
    lazyMount,
    context: context2
  } = _a, contentProps = __objRest(_a, [
    "trapFocus",
    "scope",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "disableOutsidePointerEvents",
    "disableFocusScope",
    "onEscapeKeyDown",
    "onPointerDownOutside",
    "onFocusOutside",
    "onInteractOutside",
    "children",
    "enableRemoveScroll",
    "freezeContentsWhenHidden",
    "setIsFullyHidden",
    "lazyMount",
    "context"
  ]), {
    open: open2,
    keepChildrenMounted
  } = context2, handleExitComplete = React__namespace.useCallback(function() {
    setIsFullyHidden == null ? void 0 : setIsFullyHidden(true);
  }, [setIsFullyHidden]), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(ResetPresence, {
    disable: context2.breakpointActive,
    children
  });
  return context2.breakpointActive, /* @__PURE__ */ jsxRuntimeExports.jsx(Animate, {
    type: "presence",
    present: !!open2,
    keepChildrenMounted: !!keepChildrenMounted,
    onExitComplete: handleExitComplete,
    lazyMount,
    passThrough: context2.breakpointActive,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopperContent, __spreadProps(__spreadValues({
      scope,
      "data-state": getState$1(open2),
      id: context2.contentId,
      ref: forwardedRef,
      passThrough: context2.breakpointActive
    }, contentProps), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PortalAdaptSafe, {
        context: context2,
        children: contents
      })
    }), context2.contentId)
  });
});
var PopoverClose = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, __spreadProps(__spreadValues({}, rest), {
    ref: forwardedRef,
    componentName: "PopoverClose",
    onPress: composeEventHandlers(props.onPress, function() {
      var _context_onOpenChange;
      return context2 == null || (_context_onOpenChange = context2.onOpenChange) === null || _context_onOpenChange === void 0 ? void 0 : _context_onOpenChange.call(context2, false, "press");
    })
  }));
}), PopoverArrow = PopperArrowFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, rest = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope), isAdapted = useAdaptIsActive(context2.adaptScope);
  return isAdapted ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(PopperArrow, __spreadProps(__spreadValues({
    scope,
    componentName: "PopoverArrow"
  }, rest), {
    ref: forwardedRef
  }));
}), PopoverScrollView = /* @__PURE__ */ React__namespace.forwardRef(function(param, ref) {
  var _a = param, {
    scope
  } = _a, props = __objRest(_a, [
    "scope"
  ]), context2 = usePopoverContext(scope);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollView3, __spreadValues({
    ref,
    // when adapted, no pointer events!
    pointerEvents: context2.breakpointActive ? "none" : void 0,
    scrollEnabled: !context2.breakpointActive,
    passThrough: context2.breakpointActive
  }, props));
}), DEFAULT_SCOPE = "", Popover = withStaticProperties(/* @__PURE__ */ React__namespace.forwardRef(function(param, ref) {
  var _a = param, {
    scope = DEFAULT_SCOPE
  } = _a, props = __objRest(_a, [
    "scope"
  ]), id2 = React__namespace.useId(), adaptScope = `PopoverAdapt${scope}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptParent, {
    scope: adaptScope,
    portal: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverInner, __spreadValues({
      adaptScope,
      ref,
      id: id2,
      scope
    }, props))
  });
}), {
  Anchor: PopoverAnchor,
  Arrow: PopoverArrow,
  Trigger: PopoverTrigger,
  Content: PopoverContent,
  Close: PopoverClose,
  Adapt,
  ScrollView: PopoverScrollView,
  Sheet: Sheet.Controlled,
  FocusScope: FocusScopeControllerComponent
}), PopoverInner = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    scope = DEFAULT_SCOPE,
    keepChildrenMounted: keepChildrenMountedProp,
    hoverable,
    disableFocus,
    id: id2,
    adaptScope
  } = _a, restProps = __objRest(_a, [
    "children",
    "open",
    "defaultOpen",
    "onOpenChange",
    "scope",
    "keepChildrenMounted",
    "hoverable",
    "disableFocus",
    "id",
    "adaptScope"
  ]), triggerRef = React__namespace.useRef(null), [hasCustomAnchor, setHasCustomAnchor] = React__namespace.useState(false), viaRef = React__namespace.useRef(void 0), [keepChildrenMounted] = useControllableState({
    prop: keepChildrenMountedProp,
    defaultProp: false,
    transition: keepChildrenMountedProp === "lazy"
  }), [open2, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen || false,
    onChange: function(val) {
      onOpenChange == null ? void 0 : onOpenChange(val, viaRef.current);
    }
  }), handleOpenChange = useEvent$1(function(val, via) {
    viaRef.current = via, setOpen(val);
  }), isAdapted = useAdaptIsActive(adaptScope);
  useFloatingContext();
  var [anchorTo, setAnchorToRaw] = React__namespace.useState(), setAnchorTo = useCreateShallowSetState(setAnchorToRaw);
  React__namespace.useImperativeHandle(forwardedRef, function() {
    return {
      anchorTo: setAnchorTo,
      toggle: function() {
        return setOpen(function(prev) {
          return !prev;
        });
      },
      open: function() {
        return setOpen(true);
      },
      close: function() {
        return setOpen(false);
      },
      setOpen
    };
  });
  var popoverContext = {
    popoverScope: scope,
    adaptScope,
    id: id2,
    contentId: React__namespace.useId(),
    triggerRef,
    open: open2,
    breakpointActive: isAdapted,
    onOpenChange: handleOpenChange,
    onOpenToggle: useEvent$1(function() {
      open2 && isAdapted || setOpen(!open2);
    }),
    hasCustomAnchor,
    anchorTo,
    onCustomAnchorAdd: React__namespace.useCallback(function() {
      return setHasCustomAnchor(true);
    }, []),
    onCustomAnchorRemove: React__namespace.useCallback(function() {
      return setHasCustomAnchor(false);
    }, []),
    keepChildrenMounted
  }, memoizedChildren = React__namespace.useMemo(function() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContext.Provider, __spreadProps(__spreadValues({
      scope
    }, popoverContext), {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverSheetController, {
        context: popoverContext,
        onOpenChange: setOpen,
        children
      })
    }));
  }, [scope, setOpen, children, ...Object.values(popoverContext)]), contents = /* @__PURE__ */ jsxRuntimeExports.jsx(Popper, __spreadProps(__spreadValues({
    open: open2,
    passThrough: isAdapted,
    scope,
    stayInFrame: true
  }, restProps), {
    children: memoizedChildren
  }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: contents
  });
});
function getState$1(open2) {
  return open2 ? "open" : "closed";
}
var PopoverSheetController = function(param) {
  var _a = param, {
    context: context2
  } = _a, props = __objRest(_a, [
    "context"
  ]), showSheet = useShowPopoverSheet(context2), breakpointActive = context2.breakpointActive, getShowSheet = useGet(showSheet);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetController, {
    onOpenChange: function(val) {
      if (getShowSheet()) {
        var _props_onOpenChange;
        (_props_onOpenChange = props.onOpenChange) === null || _props_onOpenChange === void 0 || _props_onOpenChange.call(props, val);
      }
    },
    open: context2.open,
    hidden: !breakpointActive,
    children: props.children
  });
}, useShowPopoverSheet = function(context2) {
  var isAdapted = useAdaptIsActive(context2.adaptScope);
  return context2.open === false ? false : isAdapted;
};
var PROGRESS_NAME = "Progress", [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME), [ProgressProvider, useProgressContext] = createProgressContext(PROGRESS_NAME), INDICATOR_NAME = "ProgressIndicator", ProgressIndicatorFrame = styled(ThemeableStack, {
  name: INDICATOR_NAME,
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgrounded: true
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ProgressIndicator = ProgressIndicatorFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeProgress,
    animation
  } = _a, indicatorProps = __objRest(_a, [
    "__scopeProgress",
    "animation"
  ]), context2 = useProgressContext(INDICATOR_NAME, __scopeProgress), _context_value, pct = context2.max - ((_context_value = context2.value) !== null && _context_value !== void 0 ? _context_value : 0), x = -(context2.width === 0 ? 300 : context2.width) * (pct / 100), _context_value1;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressIndicatorFrame, __spreadProps(__spreadValues(__spreadValues({
    "data-state": getProgressState(context2.value, context2.max),
    "data-value": (_context_value1 = context2.value) !== null && _context_value1 !== void 0 ? _context_value1 : void 0,
    "data-max": context2.max,
    x,
    width: context2.width
  }, !props.unstyled && {
    animateOnly: ["transform"],
    opacity: context2.width === 0 ? 0 : 1
  }), indicatorProps), {
    ref: forwardedRef,
    // avoid animation on first render so the progress doesn't bounce to initial location
    animation: context2.width ? animation : null
  }));
});
function defaultGetValueLabel(value, max2) {
  return `${Math.round(value / max2 * 100)}%`;
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function isNumber(value) {
  return typeof value == "number";
}
function isValidMaxNumber(max2) {
  return isNumber(max2) && !Number.isNaN(max2) && max2 > 0;
}
function isValidValueNumber(value, max2) {
  return isNumber(value) && !Number.isNaN(value) && value <= max2 && value >= 0;
}
var DEFAULT_MAX = 100, ProgressFrame = styled(ThemeableStack, {
  name: "Progress",
  variants: {
    unstyled: {
      false: {
        borderRadius: 1e5,
        overflow: "hidden",
        backgrounded: true
      }
    },
    size: {
      "...size": function(val) {
        var size = Math.round(getVariableValue(getSize(val)) * 0.25);
        return {
          height: size,
          minWidth: getVariableValue(size) * 20,
          width: "100%"
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Progress = withStaticProperties(ProgressFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeProgress: __scopeProgress,
    value: valueProp,
    max: maxProp,
    getValueLabel = defaultGetValueLabel,
    size = "$true"
  } = _a, progressProps = __objRest(_a, [
    // @ts-expect-error
    "__scopeProgress",
    "value",
    "max",
    "getValueLabel",
    "size"
  ]), max2 = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX, value = isValidValueNumber(valueProp, max2) ? valueProp : null, valueLabel = isNumber(value) ? getValueLabel(value, max2) : void 0, [width, setWidth] = React__namespace.useState(0);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressProvider, {
    scope: __scopeProgress,
    value,
    max: max2,
    width,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressFrame, __spreadProps(__spreadValues(__spreadValues({
      "aria-valuemax": max2,
      "aria-valuemin": 0,
      "aria-valuenow": isNumber(value) ? value : void 0,
      "aria-valuetext": valueLabel,
      // @ts-ignore
      role: "progressbar",
      "data-state": getProgressState(value, max2),
      "data-value": value != null ? value : void 0,
      "data-max": max2
    }, progressProps.unstyled !== true && {
      size
    }), progressProps), {
      onLayout: function(e2) {
        var _progressProps_onLayout;
        setWidth(e2.nativeEvent.layout.width), (_progressProps_onLayout = progressProps.onLayout) === null || _progressProps_onLayout === void 0 || _progressProps_onLayout.call(progressProps, e2);
      },
      ref: forwardedRef
    }))
  });
}), {
  Indicator: ProgressIndicator
});
var RADIO_GROUP_ITEM_NAME = "RadioGroupItem", RadioGroupItemFrame = styled(ThemeableStack, {
  name: RADIO_GROUP_ITEM_NAME,
  tag: "button",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        borderRadius: 1e3,
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        borderWidth: 1,
        borderColor: "$borderColor",
        padding: 0,
        hoverStyle: {
          borderColor: "$borderColorHover",
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          borderColor: "$borderColorHover",
          backgroundColor: "$backgroundHover"
        },
        focusVisibleStyle: {
          outlineStyle: "solid",
          outlineWidth: 2,
          outlineColor: "$outlineColor"
        },
        pressStyle: {
          borderColor: "$borderColorFocus",
          backgroundColor: "$backgroundFocus"
        }
      }
    },
    disabled: {
      true: {
        pointerEvents: "none",
        userSelect: "none",
        cursor: "not-allowed",
        hoverStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        pressStyle: {
          borderColor: "$borderColor",
          backgroundColor: "$background"
        },
        focusVisibleStyle: {
          outlineWidth: 0
        }
      }
    },
    size: {
      "...size": function(value, param) {
        var {
          props
        } = param, _props_scaleSize, size = Math.floor(getVariableValue(getSize(value)) * ((_props_scaleSize = props.scaleSize) !== null && _props_scaleSize !== void 0 ? _props_scaleSize : 0.5));
        return {
          width: size,
          height: size
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), RADIO_GROUP_INDICATOR_NAME = "RadioGroupIndicator", RadioGroupIndicatorFrame = styled(ThemeableStack, {
  name: RADIO_GROUP_INDICATOR_NAME,
  variants: {
    unstyled: {
      false: {
        width: "33%",
        height: "33%",
        borderRadius: 1e3,
        backgroundColor: "$color",
        pressTheme: true
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), RADIO_GROUP_NAME = "RadioGroup", RadioGroupFrame = styled(ThemeableStack, {
  name: RADIO_GROUP_NAME,
  variants: {
    orientation: {
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      },
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      }
    }
  }
});
var BubbleInput = function(props) {
  var _a = props, {
    checked,
    bubbles = true,
    control,
    isHidden,
    accentColor
  } = _a, inputProps = __objRest(_a, [
    "checked",
    "bubbles",
    "control",
    "isHidden",
    "accentColor"
  ]), ref = React.useRef(null), prevChecked = usePrevious(checked);
  return React.useEffect(function() {
    var input = ref.current, inputProto = window.HTMLInputElement.prototype, descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked"), setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      var event = new Event("click", {
        bubbles
      });
      setChecked.call(input, checked), input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]), /* @__PURE__ */ jsxRuntimeExports.jsx("input", __spreadProps(__spreadValues({
    type: "radio",
    defaultChecked: checked
  }, inputProps), {
    tabIndex: -1,
    ref,
    "aria-hidden": isHidden,
    style: __spreadValues(__spreadValues({}, isHidden ? {
      // ...controlSize,
      position: "absolute",
      pointerEvents: "none",
      opacity: 0,
      margin: 0
    } : {
      appearance: "auto",
      accentColor
    }), props.style)
  }));
};
function getState(checked) {
  return checked ? "checked" : "unchecked";
}
function useRadioGroup(params) {
  var {
    value: valueProp,
    onValueChange,
    defaultValue: defaultValue2,
    required,
    disabled,
    name,
    native,
    accentColor,
    orientation
  } = params, [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2,
    onChange: onValueChange
  });
  return {
    providerValue: {
      value,
      onChange: setValue,
      required,
      disabled,
      name,
      native,
      accentColor
    },
    frameAttrs: {
      role: "radiogroup",
      "aria-orientation": orientation,
      "data-disabled": disabled ? "" : void 0
    },
    rovingFocusGroupAttrs: {
      orientation,
      loop: true
    }
  };
}
var useRadioGroupItem = function(params) {
  var {
    radioGroupContext,
    value,
    labelledBy: ariaLabelledby,
    disabled: itemDisabled,
    ref: refProp,
    id: id2,
    onPress
  } = params, {
    value: groupValue,
    disabled,
    required,
    onChange,
    name,
    native,
    accentColor
  } = React.useContext(radioGroupContext), [button, setButton] = React.useState(null), hasConsumerStoppedPropagationRef = React.useRef(false), ref = React.useRef(null), composedRefs = useComposedRefs(refProp, function(node) {
    return setButton(node);
  }, ref);
  React.useRef(false);
  var isFormControl = false, checked = groupValue === value, labelId = useLabelContext(button), labelledBy = ariaLabelledby || labelId;
  React.useEffect(function() {
  }, []), React.useEffect(function() {
    if (id2 && !disabled) return registerFocusable(id2, {
      focusAndSelect: function() {
        onChange == null ? void 0 : onChange(value);
      },
      focus: function() {
      }
    });
  }, [id2, value, disabled]);
  var isDisabled2 = disabled || itemDisabled;
  return {
    providerValue: {
      checked
    },
    checked,
    isFormControl,
    bubbleInput: /* @__PURE__ */ jsxRuntimeExports.jsx(BubbleInput, __spreadValues({
      isHidden: !native,
      control: button,
      bubbles: !hasConsumerStoppedPropagationRef.current,
      name,
      value,
      checked,
      required,
      disabled: isDisabled2
    }, isWeb)),
    native,
    frameAttrs: __spreadValues(__spreadProps(__spreadValues({
      "data-state": getState(checked),
      "data-disabled": isDisabled2 ? "" : void 0,
      role: "radio",
      "aria-labelledby": labelledBy,
      "aria-checked": checked,
      "aria-required": required,
      disabled: isDisabled2,
      ref: composedRefs
    }, isWeb), {
      id: id2,
      onPress: composeEventHandlers(onPress, function(event) {
        checked || (onChange == null ? void 0 : onChange(value));
      })
    }), isWeb),
    rovingFocusGroupAttrs: {
      asChild: "expect-style",
      focusable: !isDisabled2,
      active: checked
    }
  };
};
function useRadioGroupItemIndicator(params) {
  var _a = params, {
    radioGroupItemContext,
    disabled
  } = _a, rest = __objRest(_a, [
    "radioGroupItemContext",
    "disabled"
  ]), {
    checked
  } = React.useContext(radioGroupItemContext);
  return __spreadValues({
    checked,
    "data-state": getState(checked),
    "data-disabled": disabled ? "" : void 0
  }, rest);
}
var ITEM_NAME$1 = "RovingFocusGroupItem", RovingFocusGroupItem = /* @__PURE__ */ React.forwardRef(function(param, _ref) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, __spreadProps(__spreadValues({}, props), {
    children
  }));
});
RovingFocusGroupItem.displayName = ITEM_NAME$1;
var GROUP_NAME$1 = "RovingFocusGroup", RovingFocusGroup = withStaticProperties(/* @__PURE__ */ React.forwardRef(function(param, _ref) {
  var _a = param, {
    children
  } = _a, props = __objRest(_a, [
    "children"
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Stack, __spreadProps(__spreadValues({}, props), {
    children
  }));
}), {
  Item: RovingFocusGroupItem
});
RovingFocusGroup.displayName = GROUP_NAME$1;
var ensureContext = function(x) {
  x.context || (x.context = RadioGroupContext);
}, RadioGroupContext = /* @__PURE__ */ React.createContext({}), RadioGroupItemContext = /* @__PURE__ */ React.createContext({
  checked: false,
  disabled: false
});
function createRadioGroup(createProps) {
  var {
    disableActiveTheme,
    Frame: Frame2 = RadioGroupFrame,
    Indicator = RadioGroupIndicatorFrame,
    Item = RadioGroupItemFrame
  } = createProps;
  ensureContext(Frame2), ensureContext(Indicator), ensureContext(Item);
  var RadioGroupImp = Frame2.styleable(function(props, ref) {
    var _a = props, {
      value,
      defaultValue: defaultValue2,
      onValueChange,
      required = false,
      disabled = false,
      name,
      native,
      accentColor,
      orientation = "vertical"
    } = _a, rest = __objRest(_a, [
      "value",
      "defaultValue",
      "onValueChange",
      "required",
      "disabled",
      "name",
      "native",
      "accentColor",
      "orientation"
    ]), {
      providerValue,
      frameAttrs,
      rovingFocusGroupAttrs
    } = useRadioGroup({
      orientation,
      name,
      defaultValue: defaultValue2,
      value,
      onValueChange,
      required,
      disabled,
      native,
      accentColor
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupContext.Provider, {
      value: providerValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup, __spreadProps(__spreadValues({}, rovingFocusGroupAttrs), {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupFrame, __spreadValues(__spreadProps(__spreadValues({}, frameAttrs), {
          ref
        }), rest))
      }))
    });
  }), RadioGroupItemImp = Item.styleable(function(props, ref) {
    var _a = props, {
      value,
      labelledBy,
      onPress,
      onKeyDown: onKeyDown2,
      disabled,
      id: id2
    } = _a, rest = __objRest(_a, [
      "value",
      "labelledBy",
      "onPress",
      //@ts-expect-error
      "onKeyDown",
      "disabled",
      "id"
    ]), {
      providerValue,
      rovingFocusGroupAttrs,
      frameAttrs,
      isFormControl
    } = useRadioGroupItem({
      radioGroupContext: RadioGroupContext,
      value,
      id: id2,
      labelledBy,
      disabled,
      onPress
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupItemContext.Provider, {
      value: providerValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup.Item, __spreadProps(__spreadValues({}, rovingFocusGroupAttrs), {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupItemFrame, __spreadValues(__spreadProps(__spreadValues({}, frameAttrs), {
            ref
          }), rest))
        })), isFormControl]
      })
    });
  });
  RadioGroupItemImp.displayName = "RadioGroupItem";
  var RadioIndicator = Indicator.styleable(function(props, forwardedRef) {
    var _a = props, {
      forceMount,
      disabled
    } = _a, indicatorProps = __objRest(_a, [
      "forceMount",
      "disabled"
    ]), _b = useRadioGroupItemIndicator({
      radioGroupItemContext: RadioGroupItemContext,
      disabled
    }), {
      checked
    } = _b, useIndicatorRest = __objRest(_b, [
      "checked"
    ]);
    return forceMount || checked ? /* @__PURE__ */ jsxRuntimeExports.jsx(Indicator, __spreadValues(__spreadProps(__spreadValues({}, useIndicatorRest), {
      ref: forwardedRef
    }), indicatorProps)) : null;
  });
  RadioIndicator.displayName = "RadioIndicator";
  var RadioGroup2 = withStaticProperties(RadioGroupImp, {
    Item: RadioGroupItemImp,
    Indicator: RadioIndicator
  });
  return RadioGroup2.displayName = "RadioGroup", RadioGroup2;
}
var RadioGroupStyledContext = createStyledContext({
  size: "$true",
  scaleIcon: 1
}, "RadioGroup");
var RadioGroup = createRadioGroup({
  Frame: RadioGroupFrame,
  Indicator: RadioGroupIndicatorFrame,
  Item: RadioGroupItemFrame
});
var Separator = styled(Stack, {
  name: "Separator",
  borderColor: "$borderColor",
  flexShrink: 0,
  borderWidth: 0,
  flex: 1,
  height: 0,
  maxHeight: 0,
  borderBottomWidth: 1,
  y: -0.5,
  variants: {
    vertical: {
      true: {
        y: 0,
        x: -0.5,
        height: "auto",
        // maxHeight auto WILL BE passed to style attribute, but for some reason not used?
        // almost seems like a react or browser bug, but for now `initial` works
        // also, it doesn't happen for `height`, but for consistency using the same values
        maxHeight: "auto",
        width: 0,
        maxWidth: 0,
        borderBottomWidth: 0,
        borderRightWidth: 1
      }
    }
  }
});
function debounce(func, wait, leading) {
  var timeout, isCancelled = false;
  function debounced() {
    var _this = this;
    isCancelled = false;
    var args = arguments;
    leading && !timeout && func.apply(this, args), clearTimeout(timeout), timeout = setTimeout(function() {
      timeout = null, leading || isCancelled || func.apply(_this, args), isCancelled = false;
    }, wait);
  }
  return debounced.cancel = function() {
    isCancelled = true;
  }, debounced;
}
var defaultOpts = {
  leading: false
};
function useDebounce(fn, wait) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOpts, mountArgs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [fn], dbEffect = React__namespace.useRef(null);
  return React__namespace.useEffect(function() {
    return function() {
      var _dbEffect_current;
      (_dbEffect_current = dbEffect.current) === null || _dbEffect_current === void 0 || _dbEffect_current.cancel();
    };
  }, []), React__namespace.useMemo(function() {
    return dbEffect.current = debounce(fn, wait, options.leading), dbEffect.current;
  }, [options.leading, ...mountArgs]);
}
function useDebounceValue(val) {
  var amt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, [state, setState] = React__namespace.useState(val);
  return React__namespace.useEffect(function() {
    var tm = setTimeout(function() {
      setState(function(prev) {
        return prev === val ? prev : val;
      });
    }, amt);
    return function() {
      clearTimeout(tm);
    };
  }, [val]), state;
}
var {
  Provider: SelectProvider,
  useStyledContext: useSelectContext
} = createStyledContext(null, "Select"), {
  Provider: SelectItemParentProvider,
  useStyledContext: useSelectItemParentContext
} = createStyledContext(null, "SelectItem"), ForwardSelectContext = function(param) {
  var {
    context: context2,
    itemContext,
    children
  } = param;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, __spreadProps(__spreadValues({
    isInSheet: true,
    scope: context2.scopeName
  }, context2), {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemParentProvider, __spreadProps(__spreadValues({
      scope: context2.scopeName
    }, itemContext), {
      children
    }))
  }));
};
var SelectContent = function(param) {
  var {
    children
  } = param;
  return children;
};
var ITEM_NAME = "SelectItem", {
  Provider: SelectItemContextProvider,
  useStyledContext: useSelectItemContext
} = createStyledContext(null, ITEM_NAME), SelectItem = ListItemFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope,
    value,
    disabled = false,
    textValue: textValueProp,
    index: index2
  } = _a, restProps = __objRest(_a, [
    "scope",
    "value",
    "disabled",
    "textValue",
    "index"
  ]), {
    props: listItemProps
  } = useListItem(__spreadValues(__spreadValues({}, !props.unstyled && {
    ellipse: true
  }), restProps)), context2 = useSelectItemParentContext(scope), {
    setSelectedIndex,
    listRef,
    setOpen,
    onChange,
    activeIndexSubscribe,
    valueSubscribe,
    allowMouseUpRef,
    allowSelectRef,
    setValueAtIndex,
    selectTimeoutRef,
    dataRef,
    interactions,
    shouldRenderWebNative,
    size,
    onActiveChange,
    initialValue: initialValue2
  } = context2, [isSelected, setSelected] = React__namespace.useState(initialValue2 === value);
  React__namespace.useEffect(function() {
    return activeIndexSubscribe(function(i) {
      var isActive = index2 === i;
      if (isActive) {
        var _listRef_current_index;
        onActiveChange(value, index2), listRef == null || (_listRef_current_index = listRef.current[index2]) === null || _listRef_current_index === void 0 || _listRef_current_index.focus();
      }
    });
  }, [index2]), React__namespace.useEffect(function() {
    return valueSubscribe(function(val) {
      setSelected(val === value);
    });
  }, [value]);
  var textId = React__namespace.useId(), refCallback = React__namespace.useCallback(function(node) {
  }, []), composedRefs = useComposedRefs(forwardedRef, refCallback);
  useIsomorphicLayoutEffect(function() {
    setValueAtIndex(index2, value);
  }, [index2, setValueAtIndex, value]);
  function handleSelect() {
    setSelectedIndex(index2), onChange(value), setOpen(false);
  }
  var selectItemProps = React__namespace.useMemo(function() {
    return interactions ? interactions.getItemProps({
      onTouchMove() {
        allowSelectRef.current = true, allowMouseUpRef.current = false;
      },
      onTouchEnd() {
        allowSelectRef.current = false, allowMouseUpRef.current = true;
      },
      onKeyDown(event) {
        event.key === "Enter" || event.key === " " && !(dataRef == null ? void 0 : dataRef.current.typing) ? (event.preventDefault(), handleSelect()) : allowSelectRef.current = true;
      },
      onClick() {
        allowSelectRef.current && handleSelect();
      },
      onMouseUp() {
        allowMouseUpRef.current && (allowSelectRef.current && handleSelect(), clearTimeout(selectTimeoutRef.current), selectTimeoutRef.current = setTimeout(function() {
          allowSelectRef.current = true;
        }));
      }
    }) : {
      onPress: handleSelect
    };
  }, [handleSelect]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemContextProvider, {
    scope,
    value,
    textId: textId || "",
    isSelected,
    children: shouldRenderWebNative ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", {
      value,
      children: props.children
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemFrame, __spreadValues(__spreadValues(__spreadValues({
      tag: "div",
      componentName: ITEM_NAME,
      ref: composedRefs,
      "aria-labelledby": textId,
      "aria-selected": isSelected,
      "data-state": isSelected ? "active" : "inactive",
      "aria-disabled": disabled || void 0,
      "data-disabled": disabled ? "" : void 0,
      tabIndex: disabled ? void 0 : -1
    }, !props.unstyled && {
      backgrounded: true,
      pressTheme: true,
      hoverTheme: true,
      focusTheme: true,
      cursor: "default",
      size,
      outlineOffset: -0.5,
      focusVisibleStyle: {
        outlineColor: "$outlineColor",
        outlineWidth: 1,
        outlineStyle: "solid"
      }
    }), listItemProps), selectItemProps))
  });
}, {
  disableTheme: true
});
var ITEM_TEXT_NAME = "SelectItemText", SelectItemTextFrame = styled(SizableText, {
  name: ITEM_TEXT_NAME,
  variants: {
    unstyled: {
      false: {
        userSelect: "none",
        color: "$color",
        ellipse: true
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SelectItemText = SelectItemTextFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    scope,
    className
  } = _a, itemTextProps = __objRest(_a, [
    "scope",
    "className"
  ]), context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), ref = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, ref), itemContext = useSelectItemContext(scope), contents = React__namespace.useRef(null);
  return contents.current = /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemTextFrame, __spreadProps(__spreadValues({
    className,
    size: itemParentContext.size,
    id: itemContext.textId
  }, itemTextProps), {
    ref: composedRefs
  })), useIsomorphicLayoutEffect(function() {
    itemParentContext.initialValue === itemContext.value && !context2.selectedIndex && context2.setSelectedItem(contents.current);
  }, []), useIsomorphicLayoutEffect(function() {
    return itemParentContext.valueSubscribe(function(val) {
      val === itemContext.value && context2.setSelectedItem(contents.current);
    });
  }, [itemContext.value]), itemParentContext.shouldRenderWebNative ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: props.children
  }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: contents.current
  });
});
var SelectScrollUpButton = function(_) {
  return null;
}, SelectScrollDownButton = function(_) {
  return null;
};
var TRIGGER_NAME$1 = "SelectTrigger", SelectTrigger = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _context_floatingContext, _a = props, {
    scope,
    disabled = false,
    unstyled = false
  } = _a, triggerProps = __objRest(_a, [
    "scope",
    "disabled",
    "unstyled"
  ]), context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), composedRefs = useComposedRefs(forwardedRef, (_context_floatingContext = context2.floatingContext) === null || _context_floatingContext === void 0 ? void 0 : _context_floatingContext.refs.setReference);
  return itemParentContext.shouldRenderWebNative ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem2, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    componentName: TRIGGER_NAME$1,
    unstyled,
    tag: "button",
    type: "button",
    id: itemParentContext.id
  }, !unstyled && {
    backgrounded: true,
    radiused: true,
    hoverTheme: true,
    pressTheme: true,
    focusable: true,
    focusVisibleStyle: {
      outlineStyle: "solid",
      outlineWidth: 2,
      outlineColor: "$outlineColor"
    },
    borderWidth: 1,
    size: itemParentContext.size
  }), {
    // aria-controls={context.contentId}
    "aria-expanded": context2.open,
    "aria-autocomplete": "none",
    dir: context2.dir,
    disabled,
    "data-disabled": disabled ? "" : void 0
  }), triggerProps), {
    ref: composedRefs,
    onPress() {
      itemParentContext.setOpen(!context2.open);
    }
  }));
});
var VIEWPORT_NAME = "SelectViewport";
var SelectViewport = function(props) {
  var {
    scope,
    children
  } = props, context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), themeName = useThemeName(), adaptContext = useAdaptContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptPortalContents, {
    scope: context2.adaptScope,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
      name: themeName,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(ForwardSelectContext, {
        itemContext: itemParentContext,
        context: context2,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptContext.Provider, __spreadProps(__spreadValues({}, adaptContext), {
          children
        }))
      })
    })
  });
};
SelectViewport.displayName = VIEWPORT_NAME;
var useShowSelectSheet = function(context2) {
  var breakpointActive = useAdaptIsActive(context2.adaptScope);
  return context2.open === false ? false : breakpointActive;
};
var VALUE_NAME = "SelectValue", SelectValueFrame = styled(SizableText, {
  name: VALUE_NAME,
  userSelect: "none"
}), SelectValue = SelectValueFrame.styleable(function(param, forwardedRef) {
  var _a = param, {
    scope,
    children: childrenProp,
    placeholder
  } = _a, props = __objRest(_a, [
    "scope",
    "children",
    "placeholder"
  ]), _context_renderValue, context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), composedRefs = useComposedRefs(forwardedRef, context2.onValueNodeChange), isEmptyValue = context2.value == null || context2.value === "", renderedValue = (_context_renderValue = context2.renderValue) === null || _context_renderValue === void 0 ? void 0 : _context_renderValue.call(context2, context2.value), _ref, children = (_ref = childrenProp != null ? childrenProp : renderedValue) !== null && _ref !== void 0 ? _ref : context2.selectedItem, selectValueChildren = isEmptyValue ? placeholder != null ? placeholder : children : children;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValueFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, !props.unstyled && {
    size: itemParentContext.size,
    ellipse: true,
    // we don't want events from the portalled `SelectValue` children to bubble
    // through the item they came from
    pointerEvents: "none"
  }), {
    ref: composedRefs
  }), props), {
    children: unwrapSelectItem(selectValueChildren)
  }));
});
function unwrapSelectItem(selectValueChildren) {
  return React__namespace.Children.map(selectValueChildren, function(child) {
    if (child) {
      var _child_type_staticConfig, _child_type, _child_props;
      if (((_child_type = child.type) === null || _child_type === void 0 || (_child_type_staticConfig = _child_type.staticConfig) === null || _child_type_staticConfig === void 0 ? void 0 : _child_type_staticConfig.componentName) === ITEM_TEXT_NAME) return child.props.children;
      if (!((_child_props = child.props) === null || _child_props === void 0) && _child_props.children) return unwrapSelectItem(child.props.children);
    }
    return child;
  });
}
var SelectIcon = styled(XStack, {
  name: "SelectIcon",
  // @ts-ignore
  "aria-hidden": true,
  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Paragraph, {
    children: ""
  })
}), SelectItemIndicatorFrame = styled(XStack, {
  name: "SelectItemIndicator"
}), SelectItemIndicator = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, itemIndicatorProps = __objRest(_a, [
    "scope"
  ]), context2 = useSelectItemParentContext(scope), itemContext = useSelectItemContext(scope);
  return context2.shouldRenderWebNative ? null : itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemIndicatorFrame, __spreadProps(__spreadValues({
    "aria-hidden": true
  }, itemIndicatorProps), {
    ref: forwardedRef
  })) : null;
}), GROUP_NAME = "SelectGroup", {
  Provider: SelectGroupContextProvider,
  useStyledContext: useSelectGroupContext
} = createStyledContext({
  id: ""
}, "SelectGroup"), SelectGroupFrame = styled(YStack, {
  name: GROUP_NAME,
  width: "100%"
}), NativeSelectTextFrame = styled(SizableText, {
  tag: "select",
  backgroundColor: "$background",
  borderColor: "$borderColor",
  hoverStyle: {
    backgroundColor: "$backgroundHover"
  }
}), NativeSelectFrame = styled(ThemeableStack, {
  name: "NativeSelect",
  bordered: true,
  userSelect: "none",
  outlineWidth: 0,
  paddingRight: 10,
  variants: {
    size: {
      "...size": function(val, extras) {
        var {
          tokens
        } = extras, paddingHorizontal = getVariableValue(tokens.space[val]), _tokens_radius_val;
        return {
          borderRadius: (_tokens_radius_val = tokens.radius[val]) !== null && _tokens_radius_val !== void 0 ? _tokens_radius_val : val,
          minHeight: tokens.size[val],
          paddingRight: paddingHorizontal + 20,
          paddingLeft: paddingHorizontal,
          paddingVertical: getSpace(val, {
            shift: -3
          })
        };
      }
    }
  },
  defaultVariants: {
    size: "$2"
  }
}), SelectGroup = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, groupProps = __objRest(_a, [
    "scope"
  ]), groupId = React__namespace.useId(), context2 = useSelectContext(scope), itemParentContext = useSelectItemParentContext(scope), _itemParentContext_size, size = (_itemParentContext_size = itemParentContext.size) !== null && _itemParentContext_size !== void 0 ? _itemParentContext_size : "$true", nativeSelectRef = React__namespace.useRef(null), content = (function() {
    return itemParentContext.shouldRenderWebNative ? /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectFrame, {
      asChild: true,
      size,
      // @ts-expect-error until we support typing based on tag
      value: context2.value,
      id: itemParentContext.id,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectTextFrame, {
        // @ts-ignore it's ok since tag="select"
        onChange: function(event) {
          itemParentContext.onChange(event.currentTarget.value);
        },
        size,
        ref: nativeSelectRef,
        style: {
          color: "var(--color)",
          // @ts-ignore
          appearance: "none"
        },
        children: props.children
      })
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupFrame, __spreadProps(__spreadValues({
      // @ts-ignore
      role: "group",
      "aria-labelledby": groupId
    }, groupProps), {
      ref: forwardedRef
    }));
  })();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, {
    scope,
    id: groupId || "",
    children: content
  });
});
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel", SelectLabel = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    scope
  } = _a, labelProps = __objRest(_a, [
    "scope"
  ]), context2 = useSelectItemParentContext(scope), groupContext = useSelectGroupContext(scope);
  return context2.shouldRenderWebNative ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ListItem2, __spreadProps(__spreadValues({
    tag: "div",
    componentName: LABEL_NAME,
    fontWeight: "800",
    id: groupContext.id,
    size: context2.size
  }, labelProps), {
    ref: forwardedRef
  }));
});
SelectLabel.displayName = LABEL_NAME;
var SelectSeparator = styled(Separator, {
  name: "SelectSeparator"
}), SelectSheetController = function(props) {
  var context2 = useSelectContext(props.scope), showSheet = useShowSelectSheet(context2), isAdapted = useAdaptIsActive(context2.adaptScope), getShowSheet = useGet(showSheet);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SheetController, {
    onOpenChange: function(val) {
      getShowSheet() && props.onOpenChange(val);
    },
    open: context2.open,
    hidden: !isAdapted,
    children: props.children
  });
}, SelectSheetImpl = function(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: props.children
  });
}, Select = withStaticProperties(function(props) {
  var adaptScope = `AdaptSelect${props.scope || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AdaptParent, {
    scope: adaptScope,
    portal: true,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectInner, __spreadValues({
      scope: props.scope,
      adaptScope
    }, props))
  });
}, {
  Adapt,
  Content: SelectContent,
  Group: SelectGroup,
  Icon: SelectIcon,
  Item: SelectItem,
  ItemIndicator: SelectItemIndicator,
  ItemText: SelectItemText,
  Label: SelectLabel,
  ScrollDownButton: SelectScrollDownButton,
  ScrollUpButton: SelectScrollUpButton,
  Trigger: SelectTrigger,
  Value: SelectValue,
  Viewport: SelectViewport,
  Sheet: Sheet.Controlled,
  FocusScope: FocusScopeControllerComponent
});
function useEmitter() {
  var listeners2 = React__namespace.useRef(null);
  listeners2.current || (listeners2.current = /* @__PURE__ */ new Set());
  var emit = function(value) {
    listeners2.current.forEach(function(l) {
      return l(value);
    });
  }, subscribe2 = React__namespace.useCallback(function(listener) {
    return listeners2.current.add(listener), function() {
      listeners2.current.delete(listener);
    };
  }, []);
  return [emit, subscribe2];
}
function SelectInner(props) {
  var {
    scope = "",
    adaptScope,
    native,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange,
    disablePreventBodyScroll,
    size: sizeProp = "$true",
    onActiveChange,
    dir,
    id: id2,
    renderValue
  } = props;
  useAdaptIsActive(adaptScope);
  var SelectImpl = SelectSheetImpl, forceUpdate = React__namespace.useReducer(function() {
    return {};
  }, {})[1], [selectedItem, setSelectedItem] = React__namespace.useState(null), [open2, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen || false,
    onChange: onOpenChange
  }), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2 || "",
    onChange: onValueChange,
    transition: true
  });
  React__namespace.useEffect(function() {
    open2 && emitValue(value);
  }, [open2]), React__namespace.useEffect(function() {
    emitValue(value);
  }, [value]), React__namespace.useEffect(function() {
    if (props.id) return registerFocusable(props.id, {
      focusAndSelect: function() {
        setOpen == null ? void 0 : setOpen(function(value2) {
          return !value2;
        });
      },
      focus: function() {
      }
    });
  }, [props.id]);
  var [activeIndex, setActiveIndex] = React__namespace.useState(0), [emitValue, valueSubscribe] = useEmitter(), [emitActiveIndex, activeIndexSubscribe] = useEmitter(), selectedIndexRef = React__namespace.useRef(null), activeIndexRef = React__namespace.useRef(null), listContentRef = React__namespace.useRef([]), [selectedIndex, setSelectedIndex] = React__namespace.useState(0), [valueNode, setValueNode] = React__namespace.useState(null);
  useIsomorphicLayoutEffect(function() {
    selectedIndexRef.current = selectedIndex, activeIndexRef.current = activeIndex;
  });
  var shouldRenderWebNative = isWeb, setActiveIndexDebounced = useDebounce(function(index2) {
    setActiveIndex(function(prev) {
      return prev !== index2 ? (typeof index2 == "number" && emitActiveIndex(index2), index2) : prev;
    });
  }, 1, {}, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItemParentProvider, {
    scopeName: scope,
    scope,
    adaptScope,
    initialValue: React__namespace.useMemo(function() {
      return value;
    }, [open2]),
    size: sizeProp,
    activeIndexSubscribe,
    valueSubscribe,
    setOpen,
    id: id2,
    onChange: React__namespace.useCallback(function(val) {
      setValue(val), emitValue(val);
    }, []),
    onActiveChange: useEvent$1(function(value2, index2) {
      onActiveChange == null ? void 0 : onActiveChange(value2, index2);
    }),
    setSelectedIndex,
    setValueAtIndex: React__namespace.useCallback(function(index2, value2) {
      listContentRef.current[index2] = value2;
    }, []),
    shouldRenderWebNative,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectProvider, {
      scope,
      scopeName: scope,
      adaptScope,
      disablePreventBodyScroll,
      dir,
      blockSelection: false,
      fallback: false,
      selectedItem,
      setSelectedItem,
      forceUpdate,
      valueNode,
      onValueNodeChange: setValueNode,
      activeIndex,
      selectedIndex,
      setActiveIndex: setActiveIndexDebounced,
      value,
      open: open2,
      native,
      renderValue,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectSheetController, {
        onOpenChange: setOpen,
        scope,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectImpl, __spreadProps(__spreadValues({
          activeIndexRef,
          listContentRef,
          selectedIndexRef
        }, props), {
          open: open2,
          value,
          children
        }))
      })
    })
  });
}
var SLIDER_NAME = "Slider", SliderContext = createStyledContext({
  size: "$true",
  min: 0,
  max: 100,
  orientation: "horizontal"
}), {
  Provider: SliderProvider,
  useStyledContext: useSliderContext
} = SliderContext, {
  Provider: SliderOrientationProvider,
  useStyledContext: useSliderOrientationContext
} = createStyledContext({
  startEdge: "left",
  endEdge: "right",
  sizeProp: "width",
  size: 0,
  direction: 1
}), PAGE_KEYS = ["PageUp", "PageDown"], ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], BACK_KEYS = {
  ltr: ["ArrowDown", "Home", "ArrowLeft", "PageDown"],
  rtl: ["ArrowDown", "Home", "ArrowRight", "PageDown"]
};
function getNextSortedValues() {
  var prevValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], nextValue = arguments.length > 1 ? arguments[1] : void 0, atIndex = arguments.length > 2 ? arguments[2] : void 0, nextValues = [...prevValues];
  return nextValues[atIndex] = nextValue, nextValues.sort(function(a, b2) {
    return a - b2;
  });
}
function convertValueToPercentage(value, min2, max2) {
  var maxSteps = max2 - min2, percentPerStep = 100 / maxSteps;
  return percentPerStep * (value - min2);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) return `Value ${index2 + 1} of ${totalValues}`;
  if (totalValues === 2) return ["Minimum", "Maximum"][index2];
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  var distances = values.map(function(value) {
    return Math.abs(value - nextValue);
  }), closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  var quarterWidth = width / 4, halfPercent = 50, offset2 = linearScale([0, halfPercent], [0, quarterWidth]);
  return (quarterWidth - offset2(left)) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map(function(value, index2) {
    return values[index2 + 1] - value;
  });
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    var stepsBetweenValues = getStepsBetweenValues(values), actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return function(value) {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    var ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  var rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var SliderFrame = styled(YStack, {
  position: "relative",
  variants: {
    orientation: {
      horizontal: {},
      vertical: {}
    },
    size: function(val, extras) {
      if (val) {
        var orientation = extras.props.orientation, size = Math.round(getVariableValue(getSize(val)) / 6);
        return orientation === "horizontal" ? {
          height: size,
          borderRadius: size,
          justifyContent: "center"
        } : {
          width: size,
          borderRadius: size,
          alignItems: "center"
        };
      }
    }
  }
}), SliderImpl = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider,
    onSlideStart,
    onSlideMove,
    onSlideEnd,
    onHomeKeyDown,
    onEndKeyDown,
    onStepKeyDown
  } = _a, sliderProps = __objRest(_a, [
    "__scopeSlider",
    "onSlideStart",
    "onSlideMove",
    "onSlideEnd",
    "onHomeKeyDown",
    "onEndKeyDown",
    "onStepKeyDown"
  ]), context2 = useSliderContext(__scopeSlider);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    size: "$4"
  }, sliderProps), {
    "data-orientation": sliderProps.orientation,
    ref: forwardedRef
  }), isWeb), {
    onMoveShouldSetResponderCapture: function() {
      return true;
    },
    onScrollShouldSetResponder: function() {
      return true;
    },
    onScrollShouldSetResponderCapture: function() {
      return true;
    },
    onMoveShouldSetResponder: function() {
      return true;
    },
    onStartShouldSetResponder: function() {
      return true;
    },
    // onStartShouldSetResponderCapture={() => true}
    onResponderTerminationRequest: function() {
      return false;
    },
    onResponderGrant: composeEventHandlers(props.onResponderGrant, function(event) {
      var target = event.target, thumbIndex = context2.thumbs.get(target), isStartingOnThumb = thumbIndex !== void 0;
      isStartingOnThumb && (context2.valueIndexToChangeRef.current = thumbIndex), onSlideStart(event, isStartingOnThumb ? "thumb" : "track");
    }),
    onResponderMove: composeEventHandlers(props.onResponderMove, function(event) {
      event.stopPropagation(), onSlideMove(event);
    }),
    onResponderRelease: composeEventHandlers(props.onResponderRelease, function(event) {
      onSlideEnd(event);
    })
  }));
});
var SliderHorizontal = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    min: min2,
    max: max2,
    dir,
    onSlideStart,
    onSlideMove,
    onStepKeyDown,
    onSlideEnd
  } = _a, sliderProps = __objRest(_a, [
    "min",
    "max",
    "dir",
    "onSlideStart",
    "onSlideMove",
    "onStepKeyDown",
    "onSlideEnd"
  ]), direction = useDirection(dir), isDirectionLTR = direction === "ltr", sliderRef = React__namespace.useRef(null), [state, setState_] = React__namespace.useState(function() {
    return {
      size: 0,
      offset: 0
    };
  }), setState = useCreateShallowSetState(setState_);
  function getValueFromPointer(pointerPosition) {
    var input = [0, state.size], output = isDirectionLTR ? [min2, max2] : [max2, min2], value = linearScale(input, output);
    return value(pointerPosition);
  }
  var measure2 = function() {
    var _sliderRef_current;
    (_sliderRef_current = sliderRef.current) === null || _sliderRef_current === void 0 || _sliderRef_current.measure(function(_x, _y, width, _height, pageX, _pageY) {
      setState({
        size: width,
        offset: pageX
      });
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: isDirectionLTR ? "left" : "right",
    endEdge: isDirectionLTR ? "right" : "left",
    direction: isDirectionLTR ? 1 : -1,
    sizeProp: "width",
    size: state.size,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SliderImpl, __spreadProps(__spreadValues({
      ref: composeRefs(forwardedRef, sliderRef),
      dir: direction
    }, sliderProps), {
      orientation: "horizontal",
      onLayout: measure2,
      onSlideStart: function(event, target) {
        var value = getValueFromPointer(event.nativeEvent.locationX);
        value && (onSlideStart == null ? void 0 : onSlideStart(value, target, event));
      },
      onSlideMove: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        value && (onSlideMove == null ? void 0 : onSlideMove(value, event));
      },
      onSlideEnd: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        value && (onSlideEnd == null ? void 0 : onSlideEnd(event, value));
      },
      onStepKeyDown: function(event) {
        var isBackKey = BACK_KEYS[direction].includes(event.key);
        onStepKeyDown == null ? void 0 : onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    }))
  });
});
var SliderVertical = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    min: min2,
    max: max2,
    onSlideStart,
    onSlideMove,
    onStepKeyDown,
    onSlideEnd
  } = _a, sliderProps = __objRest(_a, [
    "min",
    "max",
    "onSlideStart",
    "onSlideMove",
    "onStepKeyDown",
    "onSlideEnd"
  ]), [state, setState_] = React__namespace.useState(function() {
    return {
      size: 0,
      offset: 0
    };
  }), setState = useCreateShallowSetState(setState_), sliderRef = React__namespace.useRef(null);
  function getValueFromPointer(pointerPosition) {
    var input = [0, state.size], output = [max2, min2], value = linearScale(input, output);
    return value(pointerPosition);
  }
  var measure2 = function() {
    var _sliderRef_current;
    (_sliderRef_current = sliderRef.current) === null || _sliderRef_current === void 0 || _sliderRef_current.measure(function(_x, _y, _width, height, _pageX, pageY) {
      setState({
        size: height,
        offset: pageY
      });
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: "bottom",
    endEdge: "top",
    sizeProp: "height",
    size: state.size,
    direction: 1,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SliderImpl, __spreadProps(__spreadValues({
      ref: composeRefs(forwardedRef, sliderRef)
    }, sliderProps), {
      orientation: "vertical",
      onLayout: measure2,
      onSlideStart: function(event, target) {
        var value = getValueFromPointer(event.nativeEvent.locationY);
        value && (onSlideStart == null ? void 0 : onSlideStart(value, target, event));
      },
      onSlideMove: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        value && (onSlideMove == null ? void 0 : onSlideMove(value, event));
      },
      onSlideEnd: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        onSlideEnd == null ? void 0 : onSlideEnd(event, value);
      },
      onStepKeyDown: function(event) {
        var isBackKey = BACK_KEYS.ltr.includes(event.key);
        onStepKeyDown == null ? void 0 : onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    }))
  });
}), TRACK_NAME = "SliderTrack", SliderTrackFrame = styled(SliderFrame, {
  name: "SliderTrack",
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgroundColor: "$background",
        position: "relative",
        borderRadius: 1e5,
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SliderTrack = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider
  } = _a, trackProps = __objRest(_a, [
    "__scopeSlider"
  ]), context2 = useSliderContext(__scopeSlider);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderTrackFrame, __spreadProps(__spreadValues({
    "data-disabled": context2.disabled ? "" : void 0,
    "data-orientation": context2.orientation,
    orientation: context2.orientation,
    size: context2.size
  }, trackProps), {
    ref: forwardedRef
  }));
});
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderTrackActive", SliderTrackActiveFrame = styled(SliderFrame, {
  name: "SliderTrackActive",
  backgroundColor: "$background",
  position: "absolute",
  pointerEvents: "box-none"
}), SliderTrackActive = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider
  } = _a, rangeProps = __objRest(_a, [
    "__scopeSlider"
  ]), context2 = useSliderContext(__scopeSlider), orientation = useSliderOrientationContext(__scopeSlider), ref = React__namespace.useRef(null), composedRefs = useComposedRefs(forwardedRef, ref), valuesCount = context2.values.length, percentages = context2.values.map(function(value) {
    return convertValueToPercentage(value, context2.min, context2.max);
  }), offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0, offsetEnd = 100 - Math.max(...percentages);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderTrackActiveFrame, __spreadValues(__spreadProps(__spreadValues({
    orientation: context2.orientation,
    "data-orientation": context2.orientation,
    "data-disabled": context2.disabled ? "" : void 0,
    size: context2.size,
    animateOnly: ["left", "top", "right", "bottom"]
  }, rangeProps), {
    ref: composedRefs,
    [orientation.startEdge]: `${offsetStart}%`,
    [orientation.endEdge]: `${offsetEnd}%`
  }), orientation.sizeProp === "width" ? {
    height: "100%"
  } : {
    left: 0,
    right: 0
  }));
});
SliderTrackActive.displayName = RANGE_NAME;
var getThumbSize = function(val) {
  var tokens = getTokens(), size = typeof val == "number" ? val : getSize(tokens.size[val], {
    shift: -1
  });
  return {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size
  };
}, SliderThumbFrame = styled(ThemeableStack, {
  name: "SliderThumb",
  variants: {
    size: {
      "...size": getThumbSize
    },
    unstyled: {
      false: {
        position: "absolute",
        bordered: 2,
        borderWidth: 2,
        backgrounded: true,
        pressTheme: isWeb,
        focusTheme: isWeb,
        hoverTheme: isWeb
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SliderThumb = SliderThumbFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeSlider,
    index: index2,
    circular: circular2,
    size: sizeProp
  } = _a, thumbProps = __objRest(_a, [
    "__scopeSlider",
    "index",
    "circular",
    "size"
  ]), context2 = useSliderContext(__scopeSlider), orientation = useSliderOrientationContext(__scopeSlider), [thumb, setThumb] = React__namespace.useState(null), composedRefs = useComposedRefs(forwardedRef, setThumb), value = context2.values[index2], percent = value === void 0 ? 0 : convertValueToPercentage(value, context2.min, context2.max), label = getLabel(index2, context2.values.length), _ref, sizeIn = (_ref = sizeProp != null ? sizeProp : context2.size) !== null && _ref !== void 0 ? _ref : "$true", [size, setSize] = React__namespace.useState(function() {
    var estimatedSize = getVariableValue(getThumbSize(sizeIn).width);
    return estimatedSize;
  }), thumbInBoundsOffset = size ? getThumbInBoundsOffset(size, percent, orientation.direction) : 0;
  React__namespace.useEffect(function() {
    if (thumb) return context2.thumbs.set(thumb, index2), function() {
      context2.thumbs.delete(thumb);
    };
  }, [thumb, context2.thumbs, index2]);
  var positionalStyles = context2.orientation === "horizontal" ? __spreadValues({
    x: (thumbInBoundsOffset - size / 2) * orientation.direction,
    y: -size / 2,
    top: "50%"
  }, size === 0 && {
    top: "auto",
    bottom: "auto"
  }) : __spreadValues({
    x: -size / 2,
    y: size / 2,
    left: "50%"
  }, size === 0 && {
    left: "auto",
    right: "auto"
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({
    ref: composedRefs,
    role: "slider",
    "aria-label": props["aria-label"] || label,
    "aria-valuemin": context2.min,
    "aria-valuenow": value,
    "aria-valuemax": context2.max,
    "aria-orientation": context2.orientation,
    "data-orientation": context2.orientation,
    "data-disabled": context2.disabled ? "" : void 0,
    tabIndex: context2.disabled ? void 0 : 0,
    animateOnly: ["transform", "left", "top", "right", "bottom"]
  }, positionalStyles), {
    [orientation.startEdge]: `${percent}%`,
    size: sizeIn,
    circular: circular2
  }), thumbProps), {
    onLayout: function(e2) {
      setSize(e2.nativeEvent.layout[orientation.sizeProp]);
    },
    /**
     * There will be no value on initial render while we work out the index so we hide thumbs
     * without a value, otherwise SSR will render them in the wrong position before they
     * snap into the correct position during hydration which would be visually jarring for
     * slower connections.
     */
    // style={value === undefined ? { display: 'none' } : props.style}
    onFocus: composeEventHandlers(props.onFocus, function() {
      context2.valueIndexToChangeRef.current = index2;
    })
  }));
}, {
  staticConfig: {
    memo: true
  }
}), SliderComponent = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    name,
    min: min2 = 0,
    max: max2 = 100,
    step = 1,
    orientation = "horizontal",
    disabled = false,
    minStepsBetweenThumbs = 0,
    defaultValue: defaultValue2 = [min2],
    value,
    onValueChange = function() {
    },
    size: sizeProp,
    onSlideEnd,
    onSlideMove,
    onSlideStart
  } = _a, sliderProps = __objRest(_a, [
    "name",
    "min",
    "max",
    "step",
    "orientation",
    "disabled",
    "minStepsBetweenThumbs",
    "defaultValue",
    "value",
    "onValueChange",
    "size",
    "onSlideEnd",
    "onSlideMove",
    "onSlideStart"
  ]), sliderRef = React__namespace.useRef(null), composedRefs = useComposedRefs(sliderRef, forwardedRef), thumbRefs = React__namespace.useRef(/* @__PURE__ */ new Map()), valueIndexToChangeRef = React__namespace.useRef(0), isHorizontal = orientation === "horizontal", [values = [], setValues] = useControllableState({
    prop: value,
    defaultProp: defaultValue2,
    transition: true,
    onChange: function(value2) {
      updateThumbFocus(valueIndexToChangeRef.current), onValueChange(value2);
    }
  });
  function updateThumbFocus(focusIndex) {
  }
  function handleSlideMove(value2, event) {
    updateValues(value2, valueIndexToChangeRef.current), onSlideMove == null ? void 0 : onSlideMove(event, value2);
  }
  function updateValues(value2, atIndex) {
    var decimalCount = getDecimalCount(step), snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount), nextValue = clamp$1(snapToStep, [min2, max2]);
    setValues(function() {
      var prevValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
      return hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step) ? (valueIndexToChangeRef.current = nextValues.indexOf(nextValue), String(nextValues) === String(prevValues) ? prevValues : nextValues) : prevValues;
    });
  }
  var SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderProvider, {
    scope: props.__scopeSlider,
    disabled,
    min: min2,
    max: max2,
    valueIndexToChangeRef,
    thumbs: thumbRefs.current,
    values,
    orientation,
    size: sizeProp,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SliderOriented, __spreadProps(__spreadValues({
      "aria-disabled": disabled,
      "data-disabled": disabled ? "" : void 0
    }, sliderProps), {
      ref: composedRefs,
      min: min2,
      max: max2,
      onSlideEnd,
      onSlideStart: disabled ? void 0 : function(value2, target, event) {
        if (target !== "thumb") {
          var closestIndex = getClosestValueIndex(values, value2);
          updateValues(value2, closestIndex);
        }
        onSlideStart == null ? void 0 : onSlideStart(event, value2, target);
      },
      onSlideMove: disabled ? void 0 : handleSlideMove,
      onHomeKeyDown: function() {
        return !disabled && updateValues(min2, 0);
      },
      onEndKeyDown: function() {
        return !disabled && updateValues(max2, values.length - 1);
      },
      onStepKeyDown: function(param) {
        var {
          event,
          direction: stepDirection
        } = param;
        if (!disabled) {
          var isPageKey = PAGE_KEYS.includes(event.key), isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key), multiplier = isSkipKey ? 10 : 1, atIndex = valueIndexToChangeRef.current, value2 = values[atIndex], stepInDirection = step * multiplier * stepDirection;
          updateValues(value2 + stepInDirection, atIndex);
        }
      }
    }))
  });
}), Slider = withStaticProperties(SliderComponent, {
  Track: SliderTrack,
  TrackActive: SliderTrackActive,
  Thumb: SliderThumb
});
Slider.displayName = SLIDER_NAME;
var Track = SliderTrack, Range = SliderTrackActive, Thumb = SliderThumb;
function useSwitch(props, param, ref) {
  var [checked, setChecked] = param;
  return {
    switchProps: {
      onPress() {
        setChecked(function(prevChecked) {
          return !prevChecked;
        });
      }
    },
    switchRef: ref,
    bubbleInput: null
  };
}
var SwitchStyledContext = createStyledContext({
  size: void 0,
  unstyled: process.env.TAMAGUI_HEADLESS === "1"
});
var SwitchThumb = styled(ThemeableStack, {
  name: "SwitchThumb",
  variants: {
    unstyled: {
      false: {
        size: "$true",
        backgroundColor: "$background",
        borderRadius: 1e3
      }
    },
    checked: {
      true: {}
    },
    size: {
      "...size": function(val) {
        var size = getSwitchHeight(val);
        return {
          height: size,
          width: size
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), getSwitchHeight = function(val) {
  return Math.round(getVariableValue(getSize(val)) * 0.65);
}, getSwitchWidth = function(val) {
  return getSwitchHeight(val) * 2;
}, SwitchFrame = styled(YStack, {
  name: "Switch",
  tag: "button",
  tabIndex: 0,
  variants: {
    unstyled: {
      false: {
        borderRadius: 1e3,
        backgroundColor: "$background",
        borderWidth: 2,
        borderColor: "$background",
        focusVisibleStyle: {
          outlineColor: "$outlineColor",
          outlineStyle: "solid",
          outlineWidth: 2
        }
      }
    },
    checked: {
      true: {}
    },
    size: {
      "...size": function(val) {
        var height = getSwitchHeight(val) + 4, width = getSwitchWidth(val) + 4;
        return {
          height,
          minHeight: height,
          width
        };
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
var SwitchContext = /* @__PURE__ */ React__namespace.createContext({
  checked: false,
  disabled: false,
  frameWidth: 0
});
function createSwitch(createProps) {
  var {
    disableActiveTheme,
    Frame: Frame2 = SwitchFrame,
    Thumb: Thumb2 = SwitchThumb
  } = createProps;
  Frame2.staticConfig.context = SwitchStyledContext, Thumb2.staticConfig.context = SwitchStyledContext;
  var SwitchThumbComponent = Thumb2.styleable(function(props, forwardedRef) {
    var _a = props, {
      size: sizeProp,
      unstyled: unstyledProp,
      nativeID
    } = _a, thumbProps = __objRest(_a, [
      "size",
      "unstyled",
      "nativeID"
    ]), context2 = React__namespace.useContext(SwitchContext), {
      checked,
      disabled,
      frameWidth
    } = context2, styledContext = SwitchStyledContext.useStyledContext(), {
      unstyled: unstyledContext,
      size: sizeContext
    } = styledContext, _ref, unstyled = process.env.TAMAGUI_HEADLESS === "1" ? true : (_ref = unstyledProp != null ? unstyledProp : unstyledContext) !== null && _ref !== void 0 ? _ref : false, _ref1, size = (_ref1 = sizeProp != null ? sizeProp : sizeContext) !== null && _ref1 !== void 0 ? _ref1 : "$true", initialChecked = React__namespace.useRef(checked).current, initialWidth = getVariableValue(props.width, "size"), [thumbWidth, setThumbWidth] = React__namespace.useState(typeof initialWidth == "number" ? initialWidth : 0), distance = frameWidth - thumbWidth, x = initialChecked ? checked ? 0 : -distance : checked ? distance : 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb2, __spreadValues(__spreadProps(__spreadValues({
      ref: forwardedRef,
      unstyled
    }, unstyled === false && __spreadValues({
      size
    }, !disableActiveTheme && !unstyled && {
      theme: checked ? "active" : null
    })), {
      alignSelf: initialChecked ? "flex-end" : "flex-start",
      x,
      onLayout: composeEventHandlers(props.onLayout, function(e2) {
        var next = e2.nativeEvent.layout.width;
        next !== thumbWidth && setThumbWidth(next);
      }),
      // expected variants
      checked,
      disabled
    }), thumbProps));
  }), SwitchComponent = Frame2.styleable(function(_props, forwardedRef) {
    var _a = _props, {
      native,
      nativeProps,
      checked: checkedProp,
      defaultChecked,
      onCheckedChange
    } = _a, props = __objRest(_a, [
      "native",
      "nativeProps",
      "checked",
      "defaultChecked",
      "onCheckedChange"
    ]), [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked || false,
      onChange: onCheckedChange,
      transition: true
    }), styledContext = React__namespace.useContext(SwitchStyledContext.context), estimatedInitialWidth = 0, estWidth = getVariableValue(getShorthandValue(props, "width"), "size");
    if (estWidth) {
      var _getShorthandValue, _ref, estPad = (_ref = (_getShorthandValue = getShorthandValue(props, "paddingHorizontal")) !== null && _getShorthandValue !== void 0 ? _getShorthandValue : getShorthandValue(props, "padding")) !== null && _ref !== void 0 ? _ref : 0, _getShorthandValue1, _ref1, estLeftPad = (_ref1 = (_getShorthandValue1 = getShorthandValue(props, "paddingLeft")) !== null && _getShorthandValue1 !== void 0 ? _getShorthandValue1 : estPad) !== null && _ref1 !== void 0 ? _ref1 : 0, _getShorthandValue2, _ref2, estRightPad = (_ref2 = (_getShorthandValue2 = getShorthandValue(props, "paddingRight")) !== null && _getShorthandValue2 !== void 0 ? _getShorthandValue2 : estPad) !== null && _ref2 !== void 0 ? _ref2 : 0;
      estimatedInitialWidth = estWidth - (estLeftPad ? getVariableValue(estLeftPad, "size") : 0) - (estRightPad ? getVariableValue(estRightPad, "size") : 0);
    }
    var [frameWidth, setFrameInnerWidth] = React__namespace.useState(estimatedInitialWidth), {
      switchProps,
      bubbleInput,
      switchRef
    } = useSwitch(
      // @ts-ignore
      props,
      [checked, setChecked],
      // @ts-ignore TODO tamagui react 19 type error
      forwardedRef
    );
    React__namespace.useEffect(function() {
      if (props.id && !props.disabled) return registerFocusable(props.id, {
        focusAndSelect: function() {
          setChecked == null ? void 0 : setChecked(function(value2) {
            return !value2;
          });
        },
        focus: function() {
        }
      });
    }, [props.id, props.disabled]);
    var renderNative = shouldRenderNativePlatform(native);
    if (renderNative === "android" || renderNative === "ios") return /* @__PURE__ */ jsxRuntimeExports.jsx(UnimplementedView, __spreadValues({
      value: checked,
      onValueChange: setChecked
    }, nativeProps));
    var disabled = props.disabled, value = React__namespace.useMemo(function() {
      return {
        checked,
        disabled,
        frameWidth
      };
    }, [checked, disabled, frameWidth]), handleLayout = function(e2) {
      var next = e2.nativeEvent.layout.width;
      next !== frameWidth && setFrameInnerWidth(next);
    }, _styledContext_unstyled, _ref3, unstyled = (_ref3 = (_styledContext_unstyled = styledContext.unstyled) !== null && _styledContext_unstyled !== void 0 ? _styledContext_unstyled : props.unstyled) !== null && _ref3 !== void 0 ? _ref3 : false, _styledContext_size, _ref4;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchContext.Provider, {
      value,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Frame2, __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues({
        ref: switchRef,
        tag: "button"
      }, isWeb), !unstyled && {
        size: (_ref4 = (_styledContext_size = styledContext.size) !== null && _styledContext_size !== void 0 ? _styledContext_size : props.size) !== null && _ref4 !== void 0 ? _ref4 : "$true"
      }), {
        unstyled
      }), props), switchProps), !disableActiveTheme && !props.unstyled && {
        theme: checked ? "active" : null
      }), {
        // expected variants
        checked,
        disabled,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(View$1, {
          style: measureContainerStyle,
          onLayout: handleLayout,
          children: frameWidth ? props.children : null
        })
      })), bubbleInput]
    });
  }, {
    disableTheme: true
  });
  return withStaticProperties(SwitchComponent, {
    Thumb: SwitchThumbComponent
  });
}
var measureContainerStyle = {
  alignSelf: "stretch",
  flex: 1
};
var Switch = createSwitch({
  Frame: SwitchFrame,
  Thumb: SwitchThumb
});
var TABS_NAME = "Tabs", DefaultTabsFrame = styled(SizableStack, {
  name: TABS_NAME
}), TRIGGER_NAME = "TabsTrigger", DefaultTabsTabFrame = styled(ThemeableStack, {
  name: TRIGGER_NAME,
  tag: "button",
  variants: {
    size: {
      "...size": getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    },
    unstyled: {
      false: {
        borderWidth: 0,
        backgroundColor: "$background",
        userSelect: "none",
        justifyContent: "center",
        alignItems: "center",
        flexWrap: "nowrap",
        flexDirection: "row",
        cursor: "pointer",
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          backgroundColor: "$backgroundFocus"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), CONTENT_NAME = "TabsContent", DefaultTabsContentFrame = styled(ThemeableStack, {
  name: CONTENT_NAME
});
var {
  Provider: TabsProvider,
  useStyledContext: useTabsContext
} = createStyledContext();
function createTabs(createProps) {
  var {
    ContentFrame = DefaultTabsContentFrame,
    TabFrame = DefaultTabsTabFrame,
    TabsFrame = DefaultTabsFrame
  } = createProps, TABS_CONTEXT = "TabsContext", TAB_LIST_NAME = "TabsList", TabsList = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      loop = true,
      children
    } = _a, listProps = __objRest(_a, [
      "__scopeTabs",
      "loop",
      "children"
    ]), context2 = useTabsContext(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup, {
      __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
      orientation: context2.orientation,
      dir: context2.dir,
      loop,
      asChild: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Group, __spreadProps(__spreadValues({
        role: "tablist",
        componentName: TAB_LIST_NAME,
        "aria-orientation": context2.orientation,
        ref: forwardedRef,
        orientation: context2.orientation
      }, listProps), {
        children
      }))
    });
  });
  TabsList.displayName = TAB_LIST_NAME;
  var TRIGGER_NAME2 = "TabsTrigger", TabsTrigger = TabFrame.styleable(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      value,
      disabled = false,
      onInteraction,
      disableActiveTheme
    } = _a, triggerProps = __objRest(_a, [
      "__scopeTabs",
      "value",
      "disabled",
      "onInteraction",
      "disableActiveTheme"
    ]), context2 = useTabsContext(__scopeTabs), triggerId = makeTriggerId(context2.baseId, value), contentId = makeContentId(context2.baseId, value), isSelected = value === context2.value, [layout, setLayout] = React__namespace.useState(null), triggerRef = React__namespace.useRef(null), groupItemProps = useGroupItem({
      disabled: !!disabled
    });
    React__namespace.useEffect(function() {
      return context2.registerTrigger(), function() {
        return context2.unregisterTrigger();
      };
    }, []), React__namespace.useEffect(function() {
      if (!triggerRef.current || !isWeb) return;
    }, [context2.triggersCount]), React__namespace.useEffect(function() {
      isSelected && layout && (onInteraction == null ? void 0 : onInteraction("select", layout));
    }, [isSelected, value, layout]);
    var _props_onPress;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, {
      name: isSelected && !disableActiveTheme ? "active" : null,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup.Item, {
        __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
        asChild: true,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabFrame, __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
          onLayout: function(event) {
            setLayout(event.nativeEvent.layout);
          },
          onHoverIn: composeEventHandlers(props.onHoverIn, function() {
            layout && (onInteraction == null ? void 0 : onInteraction("hover", layout));
          }),
          onHoverOut: composeEventHandlers(props.onHoverOut, function() {
            onInteraction == null ? void 0 : onInteraction("hover", null);
          }),
          role: "tab",
          "aria-selected": isSelected,
          "aria-controls": contentId,
          "data-state": isSelected ? "active" : "inactive",
          "data-disabled": disabled ? "" : void 0,
          disabled,
          id: triggerId
        }, !props.unstyled && {
          size: context2.size
        }), isSelected && {
          forceStyle: "focus"
        }), groupItemProps), triggerProps), {
          ref: composeRefs(forwardedRef, triggerRef),
          onPress: composeEventHandlers((_props_onPress = props.onPress) !== null && _props_onPress !== void 0 ? _props_onPress : void 0, function(event) {
            var webChecks = !isWeb;
            !disabled && !isSelected && webChecks ? context2.onChange(value) : event.preventDefault();
          })
        }), isWeb))
      })
    });
  });
  TabsTrigger.displayName = TRIGGER_NAME2;
  var TabsContent = ContentFrame.styleable(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      value,
      forceMount,
      children
    } = _a, contentProps = __objRest(_a, [
      "__scopeTabs",
      "value",
      "forceMount",
      "children"
    ]), context2 = useTabsContext(__scopeTabs), isSelected = value === context2.value, show = forceMount || isSelected, triggerId = makeTriggerId(context2.baseId, value), contentId = makeContentId(context2.baseId, value);
    return show ? /* @__PURE__ */ jsxRuntimeExports.jsx(ContentFrame, __spreadProps(__spreadValues({
      "data-state": isSelected ? "active" : "inactive",
      "data-orientation": context2.orientation,
      role: "tabpanel",
      "aria-labelledby": triggerId,
      // @ts-ignore
      hidden: !show,
      id: contentId,
      tabIndex: 0
    }, contentProps), {
      ref: forwardedRef,
      children
    }), value) : null;
  }), TabsComponent = TabsFrame.styleable(function(props, forwardedRef) {
    var _a = props, {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue: defaultValue2,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      size = "$true"
    } = _a, tabsProps = __objRest(_a, [
      "__scopeTabs",
      "value",
      "onValueChange",
      "defaultValue",
      "orientation",
      "dir",
      "activationMode",
      "size"
    ]), direction = useDirection(dir), [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue2 != null ? defaultValue2 : ""
    }), [triggersCount, setTriggersCount] = React__namespace.useState(0), registerTrigger = useEvent$1(function() {
      return setTriggersCount(function(v) {
        return v + 1;
      });
    }), unregisterTrigger = useEvent$1(function() {
      return setTriggersCount(function(v) {
        return v - 1;
      });
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsProvider, {
      scope: __scopeTabs,
      baseId: React__namespace.useId(),
      value,
      onChange: setValue,
      orientation,
      dir: direction,
      activationMode,
      size,
      registerTrigger,
      triggersCount,
      unregisterTrigger,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TabsFrame, __spreadProps(__spreadValues({
        direction,
        //   dir={direction}
        "data-orientation": orientation
      }, tabsProps), {
        ref: forwardedRef
      }))
    });
  });
  return withStaticProperties(TabsComponent, {
    List: TabsList,
    /**
    * @deprecated Use Tabs.Tab instead
    */
    Trigger: TabsTrigger,
    Tab: TabsTrigger,
    Content: TabsContent
  });
}
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Tabs = createTabs({
  ContentFrame: DefaultTabsContentFrame,
  TabFrame: DefaultTabsTabFrame,
  TabsFrame: DefaultTabsFrame
});
function mutateThemes(param) {
  var _a = param, {
    themes: themes2,
    batch,
    insertCSS = true
  } = _a, props = __objRest(_a, [
    "themes",
    "batch",
    "insertCSS"
  ]), allThemesProxied = {}, allThemesRaw = {}, _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
  try {
    for (var _iterator = themes2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var {
        name,
        theme
      } = _step.value, res = _mutateTheme(__spreadProps(__spreadValues({}, props), {
        name,
        theme,
        // we'll do one update at the end
        avoidUpdate: true,
        // always add which also replaces but doesnt fail first time
        mutationType: "add"
      }));
      res && (allThemesProxied[name] = res.theme, allThemesRaw[name] = res.themeRaw);
    }
  } catch (err) {
    _didIteratorError = true, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError) throw _iteratorError;
    }
  }
  var cssRules = insertCSS ? insertThemeCSS() : [];
  return startTransition(function() {
    for (var themeName in allThemesProxied) {
      var theme2 = allThemesProxied[themeName];
      updateThemeConfig(themeName, theme2);
    }
    updateThemeStates();
  }), {
    themes: allThemesProxied,
    themesRaw: allThemesRaw,
    cssRules
  };
}
function _mutateTheme(props) {
  var config = getConfig(), {
    name: themeName,
    theme: themeIn,
    insertCSS,
    mutationType
  } = props;
  var _config_themes_themeName, theme1 = __spreadValues(__spreadValues({}, mutationType === "update" ? (_config_themes_themeName = config.themes[themeName]) !== null && _config_themes_themeName !== void 0 ? _config_themes_themeName : {} : {}), themeIn);
  for (var key in theme1) ensureThemeVariable(theme1, key);
  var themeProxied = proxyThemeToParents(themeName, theme1), response = {
    themeRaw: theme1,
    theme: themeProxied,
    cssRules: []
  };
  return props.avoidUpdate || (insertCSS && (response.cssRules = insertThemeCSS()), updateThemeConfig(themeName, themeProxied), updateThemeStates()), response;
}
function updateThemeConfig(themeName, theme) {
  var config = getConfig();
  config.themes[themeName] = theme, updateConfig("themes", config.themes);
}
function updateThemeStates() {
  forceUpdateThemes();
}
function insertThemeCSS(themes2) {
  return [];
}
function addTheme(props) {
  return _mutateTheme(__spreadProps(__spreadValues({}, props), {
    insertCSS: true,
    mutationType: "add"
  }));
}
function updateTheme(param) {
  var {
    name,
    theme
  } = param;
  return _mutateTheme({
    name,
    theme,
    insertCSS: true,
    mutationType: "update"
  });
}
function replaceTheme(param) {
  var {
    name,
    theme
  } = param, next = _mutateTheme({
    name,
    theme,
    insertCSS: true,
    mutationType: "replace"
  });
  return next;
}
var context = createStyledContext({
  color: "",
  toggledStyle: null
}), NAME = "Toggle", ToggleFrame = styled(ThemeableStack, {
  name: NAME,
  tag: "button",
  context,
  variants: {
    unstyled: {
      false: {
        pressTheme: true,
        backgroundColor: "$background",
        alignItems: "center",
        justifyContent: "center",
        display: "flex",
        borderColor: "$borderColor",
        borderWidth: 1,
        margin: -1,
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        focusStyle: {
          borderColor: "$borderColorFocus"
        },
        focusVisibleStyle: {
          outlineColor: "$outlineColor",
          outlineWidth: 2,
          outlineStyle: "solid"
        }
      }
    },
    active: {
      true: function(_, param) {
        var {
          props,
          context: context2
        } = param, toggledStyle = context2 == null ? void 0 : context2.toggledStyle;
        return __spreadValues(__spreadValues({
          zIndex: 1
        }, !props.unstyled && !toggledStyle && {
          backgroundColor: "$background",
          hoverStyle: {
            backgroundColor: "$background"
          },
          focusStyle: {
            backgroundColor: "$background",
            borderColor: "$borderColor"
          }
        }), toggledStyle);
      }
    },
    orientation: {
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      },
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), Toggle = /* @__PURE__ */ React__namespace.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    pressed: pressedProp,
    defaultPressed = false,
    onPressedChange
  } = _a, buttonProps = __objRest(_a, [
    "pressed",
    "defaultPressed",
    "onPressedChange"
  ]), [pressed = false, setPressed] = useControllableState({
    prop: pressedProp,
    onChange: onPressedChange,
    defaultProp: defaultPressed
  }), _props_onPress;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleFrame, __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, !props.unstyled && {
    theme: pressed ? "active" : null,
    themeShallow: true
  }), {
    active: pressed,
    "aria-pressed": pressed,
    "data-state": pressed ? "on" : "off",
    "data-disabled": props.disabled ? "" : void 0
  }), buttonProps), {
    ref: forwardedRef,
    onPress: composeEventHandlers((_props_onPress = props.onPress) !== null && _props_onPress !== void 0 ? _props_onPress : void 0, function() {
      props.disabled || setPressed(function(prev) {
        return !prev;
      });
    })
  }));
});
var TOGGLE_GROUP_NAME = "ToggleGroup", TOGGLE_GROUP_ITEM_NAME = "ToggleGroupItem", TOGGLE_GROUP_CONTEXT = "ToggleGroup", {
  Provider: ToggleGroupItemProvider
} = createStyledContext(), {
  Provider: ToggleGroupContext,
  useStyledContext: useToggleGroupContext
} = createStyledContext(), ToggleGroupItem = ToggleFrame.styleable(function(props, forwardedRef) {
  var valueContext = useToggleGroupValueContext(props.__scopeToggleGroup), context$1 = useToggleGroupContext(props.__scopeToggleGroup), toggleContext = context.useStyledContext(props.__scopeToggleGroup), pressed = valueContext == null ? void 0 : valueContext.value.includes(props.value), toggledStyle = props.toggledStyle || toggleContext.toggledStyle, color = props.color || toggleContext.color, _a = props, {
    disablePassStyles,
    toggledStyle: _
  } = _a, rest = __objRest(_a, [
    "disablePassStyles",
    "toggledStyle"
  ]), disabled = context$1.disabled || props.disabled || false, groupItemProps = useGroupItem({
    disabled
  }), _props_size, size = (_props_size = props.size) !== null && _props_size !== void 0 ? _props_size : context$1.size, sizeProps = props.unstyled ? {} : {
    width: void 0,
    height: void 0,
    padding: getVariableValue(size) * 0.6
  }, iconSize = (typeof size == "number" ? size * 0.7 : getFontSize(size)) * 1.2, theme = useTheme(), toggledColor = toggledStyle == null ? void 0 : toggledStyle.color, activeColor = pressed && toggledColor ? toggledColor : color, getThemedIcon = useGetThemedIcon({
    size: iconSize,
    color: activeColor || theme.color
  }), childrens = React.Children.toArray(props.children), children = childrens.map(function(child) {
    return props.disablePassStyles || !/* @__PURE__ */ React.isValidElement(child) ? child : /* @__PURE__ */ React.cloneElement(getThemedIcon(child), {
      active: pressed
    });
  }), commonProps = __spreadProps(__spreadValues(__spreadValues({
    pressed,
    disabled
  }, sizeProps), rest), {
    children
  }), inner = /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemImpl, __spreadValues(__spreadProps(__spreadValues({}, commonProps), {
    ref: forwardedRef,
    // focusable={!disabled}
    tabIndex: disabled ? -1 : 0,
    disabled
  }), groupItemProps));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupItemProvider, {
    scope: props.__scopeToggleGroup,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(context.Provider, {
      color,
      toggledStyle,
      children: context$1.rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup.Item, {
        asChild: "except-style",
        __scopeRovingFocusGroup: props.__scopeToggleGroup || TOGGLE_GROUP_CONTEXT,
        focusable: !disabled,
        active: pressed,
        children: inner
      }) : inner
    })
  });
});
ToggleGroupItem.displayName = TOGGLE_GROUP_ITEM_NAME;
var ToggleGroupItemImpl = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    __scopeToggleGroup,
    value
  } = _a, itemProps = __objRest(_a, [
    "__scopeToggleGroup",
    "value"
  ]), valueContext = useToggleGroupValueContext(__scopeToggleGroup), singleProps = {
    "aria-pressed": void 0
  }, typeProps = valueContext.type === "single" ? singleProps : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, __spreadProps(__spreadValues(__spreadValues({}, typeProps), itemProps), {
    ref: forwardedRef,
    onPressedChange: function(pressed) {
      pressed ? valueContext.onItemActivate(value) : valueContext.onItemDeactivate(value);
    }
  }));
}), ToggleGroup = withStaticProperties(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    type
  } = _a, toggleGroupProps = __objRest(_a, [
    "type"
  ]);
  if (React.useEffect(function() {
    if (props.id) return registerFocusable(props.id, {
      // TODO: would be nice to focus on the first child later - could be done with reforest
      // for now leaving it empty
      focus: function() {
      }
    });
  }, [props.id]), type === "single") {
    var singleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplSingle, __spreadProps(__spreadValues({}, singleProps), {
      ref: forwardedRef
    }));
  }
  if (type === "multiple") {
    var multipleProps = toggleGroupProps;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplMultiple, __spreadProps(__spreadValues({}, multipleProps), {
      ref: forwardedRef
    }));
  }
  throw new Error(`Missing prop \`type\` expected on \`${TOGGLE_GROUP_NAME}\``);
}), {
  Item: ToggleGroupItem
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var {
  Provider: ToggleGroupValueProvider,
  useStyledContext: useToggleGroupValueContext
} = createStyledContext(), ToggleGroupImplSingle = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange = function() {
    },
    disableDeactivation = false
  } = _a, toggleGroupSingleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange",
    "disableDeactivation"
  ]), [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2,
    onChange: onValueChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupValueProvider, {
    scope: props.__scopeToggleGroup,
    type: "single",
    value: value ? [value] : [],
    defaultValue: value,
    onItemActivate: setValue,
    onItemDeactivate: React.useCallback(function() {
      return disableDeactivation ? null : setValue("");
    }, [setValue, disableDeactivation]),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, __spreadProps(__spreadValues({}, toggleGroupSingleProps), {
      ref: forwardedRef
    }))
  });
}), ToggleGroupImplMultiple = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _a = props, {
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange = function() {
    },
    disableDeactivation
  } = _a, toggleGroupMultipleProps = __objRest(_a, [
    "value",
    "defaultValue",
    "onValueChange",
    "disableDeactivation"
  ]), [value = [], setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2,
    onChange: onValueChange
  }), handleButtonActivate = React.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return [...prevValue, itemValue];
    });
  }, [setValue]), handleButtonDeactivate = React.useCallback(function(itemValue) {
    return setValue(function() {
      var prevValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      return prevValue.filter(function(value2) {
        return value2 !== itemValue;
      });
    });
  }, [setValue]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupValueProvider, {
    scope: props.__scopeToggleGroup,
    type: "multiple",
    value,
    defaultValue: value,
    onItemActivate: handleButtonActivate,
    onItemDeactivate: handleButtonDeactivate,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImpl, __spreadProps(__spreadValues({}, toggleGroupMultipleProps), {
      ref: forwardedRef
    }))
  });
});
ToggleGroup.displayName = TOGGLE_GROUP_NAME;
var ToggleGroupImplElementFrame = styled(Group, {
  name: TOGGLE_GROUP_NAME,
  variants: {
    unstyled: {
      false: {
        backgroundColor: "$background"
      }
    },
    orientation: {
      vertical: {
        flexDirection: "column",
        spaceDirection: "vertical"
      },
      horizontal: {
        flexDirection: "row",
        spaceDirection: "horizontal"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), ToggleGroupImpl = ToggleGroupImplElementFrame.styleable(function(props, forwardedRef) {
  var _a = props, {
    __scopeToggleGroup,
    disabled = false,
    orientation = "horizontal",
    dir,
    rovingFocus = true,
    loop = true,
    unstyled = false,
    size: sizeProp = "$true",
    sizeAdjust = 0,
    toggledStyle,
    color
  } = _a, toggleGroupProps = __objRest(_a, [
    "__scopeToggleGroup",
    "disabled",
    "orientation",
    "dir",
    "rovingFocus",
    "loop",
    "unstyled",
    "size",
    "sizeAdjust",
    "toggledStyle",
    "color"
  ]), direction = useDirection(dir), commonProps = __spreadValues({
    role: "group",
    dir: direction
  }, toggleGroupProps), adjustedSize = getVariableValue(getSize(sizeProp, {
    shift: sizeAdjust
  })), size = Math.round(adjustedSize * 0.45);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupContext, {
    scope: __scopeToggleGroup,
    rovingFocus,
    disabled,
    size,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(context.Provider, {
      color,
      toggledStyle,
      children: rovingFocus ? /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroup, {
        asChild: "except-style",
        __scopeRovingFocusGroup: __scopeToggleGroup || TOGGLE_GROUP_CONTEXT,
        orientation,
        dir: direction,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplElementFrame, __spreadValues({
          "aria-orientation": orientation,
          orientation,
          // axis={orientation}
          ref: forwardedRef,
          "data-disabled": disabled ? "" : void 0,
          unstyled
        }, commonProps))
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleGroupImplElementFrame, __spreadValues({
        "aria-orientation": orientation,
        ref: forwardedRef,
        orientation,
        "data-disabled": disabled ? "" : void 0,
        unstyled
      }, commonProps))
    })
  });
});
var RenderChildren$1 = function(props) {
  return props.children;
}, RenderNull = function(props) {
  return null;
}, TooltipGroup = function() {
  return null;
}, closeOpenTooltips = function() {
}, Tooltip = withStaticProperties(RenderChildren$1, {
  Anchor: RenderChildren$1,
  Arrow: RenderNull,
  Close: RenderNull,
  Content: RenderNull,
  Trigger: RenderChildren$1
});
var RenderChildren = function(props) {
  return props.children;
}, TooltipSimple = RenderChildren;
function getWindowSize() {
  return Dimensions2.get("window");
}
var cbs = /* @__PURE__ */ new Set();
Dimensions2.addEventListener("change", function(param) {
  var {
    window: window2
  } = param;
  cbs.forEach(function(cb) {
    return cb(window2);
  });
});
function subscribe(cb) {
  return cbs.add(cb), function() {
    return cbs.delete(cb);
  };
}
var initialValue = {
  width: 800,
  height: 600,
  scale: 1,
  fontScale: 1
};
function configureInitialWindowDimensions(next) {
  Object.assign(initialValue, next);
}
function useWindowDimensions() {
  var {
    serverValue = initialValue
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return React.useSyncExternalStore(subscribe, getWindowSize, function() {
    return getWindowSize();
  });
}
var VisuallyHidden = styled(Text$4, {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  zIndex: -1e4,
  overflow: "hidden",
  opacity: 1e-8,
  pointerEvents: "none",
  variants: {
    preserveDimensions: {
      true: {
        position: "relative",
        width: "auto",
        height: "auto"
      }
    },
    visible: {
      true: {
        position: "relative",
        width: "auto",
        height: "auto",
        margin: 0,
        zIndex: 1,
        overflow: "visible",
        opacity: 1,
        pointerEvents: "auto"
      }
    }
  }
});
VisuallyHidden.isVisuallyHidden = true;
const createTamagui = createTamagui$1;
const TamaguiProvider = (_c) => {
  var _d = _c, { children } = _d, props = __objRest(_d, ["children"]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TamaguiProvider$1, __spreadProps(__spreadValues({}, props), { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ZIndexStackContext.Provider, { value: 1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { shouldAddRootHost: true, children }) }) }));
};
const AnchorFrame = styled(SizableText, {
  name: "Anchor",
  tag: "a",
  accessibilityRole: "link"
});
const Anchor = AnchorFrame.styleable(
  (_e, ref) => {
    var _f = _e, { href, target } = _f, props = __objRest(_f, ["href", "target"]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AnchorFrame,
      __spreadProps(__spreadValues(__spreadValues({}, props), {
        onPress: (event) => {
          var _a;
          (_a = props.onPress) == null ? void 0 : _a.call(props, event);
          if (href !== void 0) {
            LinkingInstance.openURL(href);
          }
        }
      }), {
        ref
      })
    );
  }
);
const EnsureFlexed = styled(Text$1, {
  opacity: 0,
  lineHeight: 0,
  height: 0,
  display: "flex",
  fontSize: 200,
  children: "wwwwwwwwwwwwwwwwwww",
  pointerEvents: "none"
});
EnsureFlexed["isVisuallyHidden"] = true;
const Fieldset = styled(YStack, {
  name: "Fieldset",
  tag: "fieldset",
  // remove browser default styling
  borderWidth: 0,
  variants: {
    horizontal: {
      true: {
        flexDirection: "row",
        alignItems: "center"
      }
    }
  }
});
var defaultStyles = __spreadProps(__spreadValues({
  size: "$true",
  fontFamily: "$body",
  borderWidth: 1,
  outlineWidth: 0,
  color: "$color"
}, {
  focusable: true
}), {
  borderColor: "$borderColor",
  backgroundColor: "$background",
  // this fixes a flex bug where it overflows container
  minWidth: 0,
  hoverStyle: {
    borderColor: "$borderColorHover"
  },
  focusStyle: {
    borderColor: "$borderColorFocus"
  },
  focusVisibleStyle: {
    outlineColor: "$outlineColor",
    outlineWidth: 2,
    outlineStyle: "solid"
  }
}), inputSizeVariant = function() {
  var val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "$true", extras = arguments.length > 1 ? arguments[1] : void 0;
  if (extras.props.tag === "textarea" || extras.props.rows > 1 || extras.props.multiline || extras.props.numberOfLines > 1) return textAreaSizeVariant(val, extras);
  var buttonStyles = getButtonSized(val, extras), paddingHorizontal = getSpace(val, {
    shift: -1,
    bounds: [2]
  }), fontStyle = getFontSized(val, extras);
  return fontStyle && delete fontStyle.lineHeight, __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, fontStyle), buttonStyles), {
    paddingHorizontal
  }), !extras.props.unstyled && {
    textAlignVertical: "center",
    paddingVertical: 0,
    paddingTop: 0,
    paddingBottom: 0
  });
}, textAreaSizeVariant = function() {
  var val = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "$true", extras = arguments.length > 1 ? arguments[1] : void 0, {
    props
  } = extras, buttonStyles = getButtonSized(val, extras), fontStyle = getFontSized(val, extras), _props_rows, lines = (_props_rows = props.rows) !== null && _props_rows !== void 0 ? _props_rows : props.numberOfLines, height = typeof lines == "number" ? lines * getVariableValue(fontStyle.lineHeight) : "auto", paddingVertical = getSpace(val, {
    shift: -2,
    bounds: [2]
  }), paddingHorizontal = getSpace(val, {
    shift: -1,
    bounds: [2]
  });
  return __spreadProps(__spreadValues(__spreadValues({}, buttonStyles), fontStyle), {
    paddingVertical,
    paddingHorizontal,
    height
  });
}, INPUT_NAME = "Input", styledBody = [{
  name: INPUT_NAME,
  tag: "input",
  variants: {
    unstyled: {
      false: defaultStyles
    },
    size: {
      "...size": inputSizeVariant
    },
    disabled: {
      true: {}
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}, {
  isInput: true,
  accept: {
    placeholderTextColor: "color",
    selectionColor: "color"
  },
  validStyles: Text$1.staticConfig.validStyles
}];
var StyledInput = styled(TextInput, styledBody[0], styledBody[1]), Input = StyledInput.styleable(function(inProps, forwardedRef) {
  var _a = inProps, {
    type: type,
    dirname: dirname,
    max: max2,
    min: min2,
    minLength,
    multiple,
    name,
    required,
    step,
    disabled,
    id: id2,
    caretColor,
    onChange,
    onInput,
    rows,
    enterKeyHint,
    returnKeyType,
    onKeyDown: onKeyDown2,
    inputMode,
    tag
  } = _a, rest = __objRest(_a, [
    // some of destructed props are just to avoid passing them to ...rest because they are not in native.
    "type",
    //@ts-ignore
    "dirname",
    "max",
    "min",
    "minLength",
    "multiple",
    "name",
    "required",
    "step",
    "disabled",
    "id",
    "caretColor",
    "onChange",
    "onInput",
    "rows",
    "enterKeyHint",
    "returnKeyType",
    "onKeyDown",
    "inputMode",
    "tag"
  ]), ref = React.useRef(null), composedRefs = useComposedRefs(forwardedRef, ref), secureTextEntry = false, cursorColor = caretColor, _returnKeyType = returnKeyType, _enterKeyHint = enterKeyHint;
  enterKeyHint === "go" && (_returnKeyType = "go", _enterKeyHint = void 0);
  var _inputMode = inputMode;
  type === "email" ? _inputMode = "email" : type === "tel" ? _inputMode = "tel" : type === "search" ? _inputMode = "search" : type === "url" ? _inputMode = "url" : type === "password" ? (secureTextEntry = true, _inputMode = "text") : type === "number" ? _inputMode = "numeric" : _inputMode = "text";
  var showSoftInputOnFocus = true;
  inputMode === "none" && (showSoftInputOnFocus = false);
  var finalProps = __spreadProps(__spreadValues({}, rest), {
    inputMode: _inputMode,
    showSoftInputOnFocus,
    disabled,
    id: id2,
    cursorColor,
    enterKeyHint: _enterKeyHint,
    returnKeyType: _returnKeyType,
    secureTextEntry,
    numberOfLines: rows || rest.numberOfLines
  });
  return tag === "textarea" && (finalProps.multiline = true), onKeyDown2 && (finalProps.onKeyPress = function(e2) {
    var {
      key
    } = e2.nativeEvent;
    (key === "Backspace" || tag === "textarea" && key === "Enter" || key.length === 1) && onKeyDown2({
      key,
      type: "keydown"
    });
  }, finalProps.onSubmitEditing = function(e2) {
    onKeyDown2({
      key: "Enter",
      type: "keydown"
    });
  }), (onChange || onInput) && (finalProps.onChange = function(e2) {
    var {
      text
    } = e2.nativeEvent;
    onChange && onChange({
      target: {
        value: text
      },
      type: "change"
    }), onInput == null ? void 0 : onInput({
      target: {
        value: text
      },
      type: "input"
    });
  }), React.useEffect(function() {
    if (id2 && !disabled) return registerFocusable(id2, {
      focusAndSelect: function() {
        var _ref_current;
        (_ref_current = ref.current) === null || _ref_current === void 0 || _ref_current.focus();
      },
      focus: function() {
      }
    });
  }, [id2, disabled]), /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, __spreadValues({
    onChange: function(e2) {
    },
    ref: composedRefs
  }, finalProps));
});
var TextArea = styled(Input, {
  name: "TextArea",
  tag: "textarea",
  // this attribute fixes firefox newline issue
  // @ts-ignore
  whiteSpace: "pre-wrap",
  variants: {
    unstyled: {
      false: __spreadProps(__spreadValues({
        height: "auto"
      }, defaultStyles), {
        numberOfLines: 3
      })
    },
    size: {
      "...size": textAreaSizeVariant
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
const Spinner = YStack.extractable(
  themeable(
    React__namespace.forwardRef((props, ref) => {
      const _a = props, { size, color: colorProp } = _a, stackProps = __objRest(_a, ["size", "color"]);
      const theme = useTheme();
      let color = colorProp;
      if (color && color[0] === "$") {
        color = variableToString(theme[color]);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(YStack, __spreadProps(__spreadValues({ ref }, stackProps), { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ActivityIndicator, { size, color }) }));
    }),
    {
      componentName: "Spinner"
    }
  )
);
const Text = styled(Text$1, {
  variants: {
    unstyled: {
      false: {
        color: "$color"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
});
exports.ACTIONS = ACTIONS;
exports.Accordion = Accordion;
exports.Adapt = Adapt;
exports.AdaptContents = AdaptContents;
exports.AdaptContext = AdaptContext;
exports.AdaptParent = AdaptParent;
exports.AdaptPortalContents = AdaptPortalContents;
exports.AlertDialog = AlertDialog;
exports.AlertDialogAction = AlertDialogAction;
exports.AlertDialogCancel = AlertDialogCancel;
exports.AlertDialogContent = AlertDialogContent;
exports.AlertDialogDescription = AlertDialogDescription;
exports.AlertDialogOverlay = AlertDialogOverlay;
exports.AlertDialogPortal = AlertDialogPortal;
exports.AlertDialogTitle = AlertDialogTitle;
exports.AlertDialogTrigger = AlertDialogTrigger;
exports.Anchor = Anchor;
exports.AnimatePresence = AnimatePresence;
exports.Article = Article;
exports.Aside = Aside;
exports.Avatar = Avatar;
exports.AvatarFallback = AvatarFallback;
exports.AvatarFallbackFrame = AvatarFallbackFrame;
exports.AvatarFrame = AvatarFrame;
exports.AvatarImage = AvatarImage;
exports.Button = Button2;
exports.ButtonContext = ButtonContext;
exports.ButtonFrame = ButtonFrame;
exports.ButtonIcon = ButtonIcon;
exports.ButtonNestingContext = ButtonNestingContext;
exports.ButtonText = ButtonText;
exports.Card = Card;
exports.CardBackground = CardBackground;
exports.CardFooter = CardFooter;
exports.CardFrame = CardFrame;
exports.CardHeader = CardHeader;
exports.Checkbox = Checkbox;
exports.CheckboxContext = CheckboxContext;
exports.CheckboxFrame = CheckboxFrame;
exports.CheckboxIndicatorFrame = CheckboxIndicatorFrame;
exports.CheckboxStyledContext = CheckboxStyledContext;
exports.Circle = Circle;
exports.ClientOnly = ClientOnly;
exports.ComponentContext = ComponentContext;
exports.Configuration = Configuration;
exports.Dialog = Dialog;
exports.DialogClose = DialogClose;
exports.DialogContent = DialogContent;
exports.DialogContext = DialogContext;
exports.DialogDescription = DialogDescription;
exports.DialogOverlay = DialogOverlay;
exports.DialogOverlayFrame = DialogOverlayFrame;
exports.DialogPortal = DialogPortal;
exports.DialogPortalFrame = DialogPortalFrame;
exports.DialogProvider = DialogProvider;
exports.DialogTitle = DialogTitle;
exports.DialogTrigger = DialogTrigger;
exports.DialogWarningProvider = DialogWarningProvider;
exports.EnsureFlexed = EnsureFlexed;
exports.Fieldset = Fieldset;
exports.FontLanguage = FontLanguage;
exports.Footer = Footer;
exports.Form = Form2;
exports.FormFrame = FormFrame;
exports.FormProvider = FormProvider;
exports.FormTrigger = FormTrigger;
exports.ForwardSelectContext = ForwardSelectContext;
exports.Frame = Frame;
exports.Group = Group;
exports.GroupContext = GroupContext;
exports.GroupFrame = GroupFrame;
exports.H1 = H1;
exports.H2 = H2;
exports.H3 = H3;
exports.H4 = H4;
exports.H5 = H5;
exports.H6 = H6;
exports.Handle = Handle;
exports.Header = Header;
exports.Heading = Heading;
exports.INITIAL_STATE = INITIAL_STATE;
exports.IS_FABRIC = IS_FABRIC;
exports.Image = Image;
exports.Input = Input;
exports.Label = Label;
exports.LabelFrame = LabelFrame;
exports.ListItem = ListItem2;
exports.ListItemFrame = ListItemFrame;
exports.ListItemSubtitle = ListItemSubtitle;
exports.ListItemText = ListItemText;
exports.ListItemTitle = ListItemTitle;
exports.Main = Main;
exports.Nav = Nav;
exports.Overlay = Overlay;
exports.Paragraph = Paragraph;
exports.ParentSheetContext = ParentSheetContext;
exports.Popover = Popover;
exports.PopoverAnchor = PopoverAnchor;
exports.PopoverArrow = PopoverArrow;
exports.PopoverClose = PopoverClose;
exports.PopoverContent = PopoverContent;
exports.PopoverContext = PopoverContext;
exports.PopoverTrigger = PopoverTrigger;
exports.Popper = Popper;
exports.PopperAnchor = PopperAnchor;
exports.PopperArrow = PopperArrow;
exports.PopperArrowFrame = PopperArrowFrame;
exports.PopperContent = PopperContent;
exports.PopperContentFrame = PopperContentFrame;
exports.PopperContextFast = PopperContextFast;
exports.PopperContextSlow = PopperContextSlow;
exports.PopperPositionContext = PopperPositionContext;
exports.PopperProvider = PopperProvider;
exports.PopperProviderFast = PopperProviderFast;
exports.PopperProviderSlow = PopperProviderSlow;
exports.Portal = Portal;
exports.PortalHost = PortalHost;
exports.PortalItem = GorhomPortalItem;
exports.PortalProvider = PortalProvider;
exports.PresenceChild = PresenceChild;
exports.PresenceContext = PresenceContext;
exports.Progress = Progress;
exports.ProgressFrame = ProgressFrame;
exports.ProgressIndicator = ProgressIndicator;
exports.ProgressIndicatorFrame = ProgressIndicatorFrame;
exports.ProvideAdaptContext = ProvideAdaptContext;
exports.RadioGroup = RadioGroup;
exports.RadioGroupFrame = RadioGroupFrame;
exports.RadioGroupIndicatorFrame = RadioGroupIndicatorFrame;
exports.RadioGroupItemFrame = RadioGroupItemFrame;
exports.RadioGroupStyledContext = RadioGroupStyledContext;
exports.Range = Range;
exports.ResetPresence = ResetPresence;
exports.ScrollView = ScrollView3;
exports.Section = Section;
exports.Select = Select;
exports.SelectGroupFrame = SelectGroupFrame;
exports.SelectIcon = SelectIcon;
exports.SelectItemParentProvider = SelectItemParentProvider;
exports.SelectProvider = SelectProvider;
exports.SelectSeparator = SelectSeparator;
exports.Separator = Separator;
exports.Sheet = Sheet;
exports.SheetController = SheetController;
exports.SheetControllerContext = SheetControllerContext;
exports.SheetHandleFrame = SheetHandleFrame;
exports.SheetInsideSheetContext = SheetInsideSheetContext;
exports.SheetOverlayFrame = SheetOverlayFrame;
exports.SheetScrollView = SheetScrollView;
exports.SizableStack = SizableStack;
exports.SizableText = SizableText;
exports.Slider = Slider;
exports.SliderContext = SliderContext;
exports.SliderFrame = SliderFrame;
exports.SliderThumb = SliderThumb;
exports.SliderThumbFrame = SliderThumbFrame;
exports.SliderTrack = SliderTrack;
exports.SliderTrackActive = SliderTrackActive;
exports.SliderTrackActiveFrame = SliderTrackActiveFrame;
exports.SliderTrackFrame = SliderTrackFrame;
exports.Spacer = Spacer;
exports.Spinner = Spinner;
exports.Square = Square;
exports.Stack = Stack;
exports.StyleObjectIdentifier = StyleObjectIdentifier;
exports.StyleObjectProperty = StyleObjectProperty;
exports.StyleObjectPseudo = StyleObjectPseudo;
exports.StyleObjectRules = StyleObjectRules;
exports.StyleObjectValue = StyleObjectValue;
exports.Switch = Switch;
exports.SwitchContext = SwitchContext;
exports.SwitchFrame = SwitchFrame;
exports.SwitchStyledContext = SwitchStyledContext;
exports.SwitchThumb = SwitchThumb;
exports.Tabs = Tabs;
exports.TabsProvider = TabsProvider;
exports.TamaguiProvider = TamaguiProvider;
exports.Text = Text;
exports.TextArea = TextArea;
exports.Theme = Theme;
exports.ThemeableStack = ThemeableStack;
exports.Thumb = Thumb;
exports.ToggleGroup = ToggleGroup;
exports.Tooltip = Tooltip;
exports.TooltipGroup = TooltipGroup;
exports.TooltipSimple = TooltipSimple;
exports.Track = Track;
exports.USE_NATIVE_PORTAL = USE_NATIVE_PORTAL;
exports.Unspaced = Unspaced;
exports.View = View;
exports.VisuallyHidden = VisuallyHidden;
exports.XGroup = XGroup;
exports.XStack = XStack;
exports.YGroup = YGroup;
exports.YStack = YStack;
exports.ZStack = ZStack;
exports.addTheme = addTheme;
exports.allPortalHosts = allPortalHosts;
exports.clamp = clamp$1;
exports.closeOpenTooltips = closeOpenTooltips;
exports.composeEventHandlers = composeEventHandlers;
exports.composeRefs = composeRefs;
exports.configureInitialWindowDimensions = configureInitialWindowDimensions;
exports.createAvatarScope = createAvatarScope;
exports.createCheckbox = createCheckbox;
exports.createComponent = createComponent;
exports.createContext = createContext;
exports.createContextScope = createContextScope;
exports.createFont = createFont;
exports.createMedia = createMedia;
exports.createProgressScope = createProgressScope;
exports.createRadioGroup = createRadioGroup;
exports.createSheet = createSheet;
exports.createSheetScope = createSheetScope;
exports.createShorthands = createShorthands;
exports.createStyledContext = createStyledContext;
exports.createSwitch = createSwitch;
exports.createTabs = createTabs;
exports.createTamagui = createTamagui;
exports.createTheme = createTheme;
exports.createTokens = createTokens;
exports.createVariable = createVariable;
exports.debounce = debounce;
exports.fullscreenStyle = fullscreenStyle;
exports.getCSSStylesAtomic = getCSSStylesAtomic;
exports.getConfig = getConfig;
exports.getFontSize = getFontSize;
exports.getFontSizeToken = getFontSizeToken;
exports.getFontSizeVariable = getFontSizeVariable;
exports.getMedia = getMedia;
exports.getNativeSheet = getNativeSheet;
exports.getShapeSize = getShapeSize;
exports.getThemes = getThemes;
exports.getToken = getToken;
exports.getTokenValue = getTokenValue;
exports.getTokens = getTokens;
exports.getVariable = getVariable;
exports.getVariableName = getVariableName;
exports.getVariableValue = getVariableValue;
exports.inputSizeVariant = inputSizeVariant;
exports.insertFont = insertFont;
exports.isChrome = isChrome;
exports.isClient = isClient;
exports.isPresent = isPresent;
exports.isServer = isServer;
exports.isServerSide = isServerSide;
exports.isTamaguiComponent = isTamaguiComponent;
exports.isTamaguiElement = isTamaguiElement;
exports.isTouchable = isTouchable;
exports.isVariable = isVariable;
exports.isWeb = isWeb;
exports.isWebTouchable = isWebTouchable;
exports.matchMedia = matchMedia$1;
exports.mediaObjectToString = mediaObjectToString;
exports.mediaQueryConfig = mediaQueryConfig;
exports.mutateThemes = mutateThemes;
exports.portalListeners = portalListeners;
exports.prevent = prevent;
exports.replaceTheme = replaceTheme;
exports.resolveViewZIndex = resolveViewZIndex;
exports.setConfig = setConfig;
exports.setOnLayoutStrategy = setOnLayoutStrategy;
exports.setRef = setRef;
exports.setupDev = setupDev;
exports.setupNativeSheet = setupNativeSheet;
exports.setupPopper = setupPopper;
exports.setupReactNative = setupReactNative;
exports.shouldRenderNativePlatform = shouldRenderNativePlatform;
exports.simpleHash = simpleHash;
exports.spacedChildren = spacedChildren;
exports.stylePropsAll = stylePropsAll;
exports.stylePropsText = stylePropsText;
exports.stylePropsTextOnly = stylePropsTextOnly;
exports.stylePropsTransform = stylePropsTransform;
exports.stylePropsUnitless = stylePropsUnitless;
exports.stylePropsView = stylePropsView;
exports.styled = styled;
exports.textAreaSizeVariant = textAreaSizeVariant;
exports.themeable = themeable;
exports.themeableVariants = themeableVariants;
exports.tokenCategories = tokenCategories;
exports.updateTheme = updateTheme;
exports.useAdaptContext = useAdaptContext;
exports.useAdaptIsActive = useAdaptIsActive;
exports.useButton = useButton;
exports.useComposedRefs = useComposedRefs;
exports.useConfiguration = useConfiguration;
exports.useControllableState = useControllableState;
exports.useCurrentColor = useCurrentColor;
exports.useDebounce = useDebounce;
exports.useDebounceValue = useDebounceValue;
exports.useDialogContext = useDialogContext;
exports.useDidFinishSSR = useDidFinishSSR;
exports.useEvent = useEvent$1;
exports.useFloatingContext = useFloatingContext;
exports.useForceUpdate = useForceUpdate;
exports.useFormContext = useFormContext;
exports.useGet = useGet;
exports.useGetThemedIcon = useGetThemedIcon;
exports.useGroupItem = useGroupItem;
exports.useIsPresent = useIsPresent;
exports.useIsTouchDevice = useIsTouchDevice;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useLabelContext = useLabelContext;
exports.useListItem = useListItem;
exports.useMedia = useMedia;
exports.usePopoverContext = usePopoverContext;
exports.usePopperContext = usePopperContext;
exports.usePopperContextSlow = usePopperContextSlow;
exports.usePortal = usePortal;
exports.usePresence = usePresence;
exports.useProps = useProps;
exports.usePropsAndStyle = usePropsAndStyle;
exports.useSelectContext = useSelectContext;
exports.useSelectItemParentContext = useSelectItemParentContext;
exports.useSheet = useSheet;
exports.useSheetController = useSheetController;
exports.useSheetOffscreenSize = useSheetOffscreenSize;
exports.useSheetOpenState = useSheetOpenState;
exports.useStyle = useStyle;
exports.useTabsContext = useTabsContext;
exports.useTheme = useTheme;
exports.useThemeName = useThemeName;
exports.useWindowDimensions = useWindowDimensions;
exports.validPseudoKeys = validPseudoKeys;
exports.validStyles = validStyles;
exports.variableToString = variableToString;
exports.withStaticProperties = withStaticProperties;
exports.wrapChildrenInText = wrapChildrenInText;
